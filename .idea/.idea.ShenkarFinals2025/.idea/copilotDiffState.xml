<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/GameFlowManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/GameFlowManager.cs" />
              <option name="originalContent" value="using System;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using Player.Components;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameFlowManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Game Settings&quot;)]&#10;        [SerializeField] private bool autoStartGame = true;&#10;        [SerializeField] private float restartDelay = 2f;&#10;        &#10;        [Header(&quot;Victory Settings&quot;)]&#10;        [SerializeField] private string victorySceneName = &quot;YouWonScene&quot;;&#10;        [SerializeField] private float victoryTransitionDelay = 3f;&#10;&#10;        private string _currentLevelName = &quot;Unknown&quot;;&#10;        private float _levelStartTime;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;&#10;        public GameState CurrentState { get; private set; } = GameState.MainMenu;&#10;        public bool IsPlaying =&gt; CurrentState == GameState.Playing;&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, GameDataCoordinator gameDataCoordinator)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            _currentLevelName = GetCurrentLevelName();&#10;&#10;            if (autoStartGame)&#10;            {&#10;                StartGame();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            UnsubscribeFromEvents();&#10;        }&#10;&#10;        private void StartGame()&#10;        {&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = _currentLevelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void PauseGame()&#10;        {&#10;            if (CurrentState == GameState.Playing)&#10;                ChangeState(GameState.Paused);&#10;        }&#10;&#10;        public void ResumeGame()&#10;        {&#10;            if (CurrentState == GameState.Paused)&#10;                ChangeState(GameState.Playing);&#10;        }&#10;&#10;        public void RestartLevel()&#10;        {&#10;            SceneManager.LoadScene(SceneManager.GetActiveScene().name);&#10;        }&#10;&#10;        public void HandlePlayerDeath(Vector3 deathPosition)&#10;        {&#10;            _eventBus?.Publish(new PlayerDeathEvent&#10;            {&#10;                DeathPosition = deathPosition,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void CompleteLevel(string currentLevelName)&#10;        {&#10;            float completionTime = Time.time - _levelStartTime;&#10;            &#10;            _eventBus?.Publish(new LevelCompletedEvent&#10;            {&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void RequestLevelLoad(string levelName, string sceneName)&#10;        {&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                SceneName = sceneName&#10;            });&#10;        }&#10;&#10;        public void SelectLevel(string levelName, int levelIndex)&#10;        {&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                LevelIndex = levelIndex&#10;            });&#10;        }&#10;&#10;        public void NavigateLevel(int previousIndex, int newIndex, Vector2 direction)&#10;        {&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = newIndex,&#10;                Direction = direction&#10;            });&#10;        }&#10;&#10;        public void NavigateToLevelSelection()&#10;        {&#10;            try&#10;            {&#10;                ChangeState(GameState.LevelSelection);&#10;                SceneManager.LoadScene(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to navigate to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void OnGameOver(GameOverEvent gameOverEvent)&#10;        {&#10;            ChangeState(GameState.GameOver);&#10;            RestartLevelAfterDelayAsync(restartDelay);&#10;        }&#10;&#10;        private async void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            ChangeState(GameState.Victory);&#10;&#10;            // First, check if the level was already completed&#10;            bool wasAlreadyCompleted = _gameDataCoordinator.IsLevelCompleted(levelEvent.LevelName);&#10;&#10;            // Now, update the progress (marks as complete, updates best time, etc.)&#10;            _gameDataCoordinator.UpdateLevelProgress(levelEvent.LevelName, true, levelEvent.CompletionTime);&#10;&#10;            // If it's the first time completing this level, unlock the next one&#10;            if (!wasAlreadyCompleted)&#10;            {&#10;                await UnlockNextLevelByIndex(levelEvent.LevelName);&#10;            }&#10;&#10;            if (await IsGameCompletedAsync())&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] All levels completed! Transitioning to YouWonScene...&quot;);&#10;                TransitionToVictorySceneAsync();&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] Level {levelEvent.LevelName} completed. Returning to level selection...&quot;);&#10;                ReturnToLevelSelectionAsync();&#10;            }&#10;        }&#10;&#10;        private async Task UnlockNextLevelByIndex(string completedLevelName)&#10;        {&#10;            Debug.Log($&quot;[GameFlowManager] UnlockNextLevelByIndex called for: {completedLevelName}&quot;);&#10;            &#10;            var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            if (allLevels == null || allLevels.Count == 0) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] No levels discovered for unlocking next level&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Found {allLevels.Count} levels total&quot;);&#10;            &#10;            var completedLevel = allLevels.FirstOrDefault(l =&gt; l.levelName == completedLevelName);&#10;            if (completedLevel == null) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] Could not find completed level: {completedLevelName}&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Completed level index: {completedLevel.levelIndex}&quot;);&#10;            int nextLevelIndex = completedLevel.levelIndex + 1;&#10;&#10;            if (nextLevelIndex &lt; allLevels.Count)&#10;            {&#10;                var nextLevel = allLevels.FirstOrDefault(l =&gt; l.levelIndex == nextLevelIndex);&#10;                if (nextLevel != null)&#10;                {&#10;                    bool isAlreadyUnlocked = _gameDataCoordinator.IsLevelUnlocked(nextLevel.levelName);&#10;                    Debug.Log($&quot;[GameFlowManager] Next level '{nextLevel.levelName}' (index {nextLevelIndex}) - Already unlocked: {isAlreadyUnlocked}&quot;);&#10;                    &#10;                    if (!isAlreadyUnlocked)&#10;                    {&#10;                        _gameDataCoordinator.UnlockLevel(nextLevel.levelName);&#10;                        Debug.Log($&quot;[GameFlowManager] Unlocked next level: {nextLevel.levelName}&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        Debug.Log($&quot;[GameFlowManager] Next level {nextLevel.levelName} was already unlocked&quot;);&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;[GameFlowManager] Could not find level with index {nextLevelIndex}&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] No more levels to unlock (completed level was the last one)&quot;);&#10;            }&#10;        }&#10;&#10;        private async Task&lt;bool&gt; IsGameCompletedAsync()&#10;        {&#10;            try&#10;            {&#10;                // Get all available levels through GameDataCoordinator&#10;                var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;                &#10;                if (allLevels == null || allLevels.Count == 0)&#10;                {&#10;                    Debug.LogWarning(&quot;[GameFlowManager] No levels found in discovery service&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Get completed levels using wrapper method&#10;                var completedLevels = _gameDataCoordinator?.GetCompletedLevels();&#10;                if (completedLevels == null) return false;&#10;&#10;                // Check if all levels are in the completed list&#10;                var completedCount = 0;&#10;                foreach (var level in allLevels)&#10;                {&#10;                    if (completedLevels.Contains(level.levelName))&#10;                    {&#10;                        completedCount++;&#10;                    }&#10;                }&#10;                &#10;                Debug.Log($&quot;[GameFlowManager] Game completion check: {completedCount}/{allLevels.Count} levels completed&quot;);&#10;                &#10;                if (completedCount &gt;= allLevels.Count)&#10;                {&#10;                    Debug.Log(&quot;[GameFlowManager] All levels completed!&quot;);&#10;                    return true;&#10;                }&#10;&#10;                var remainingLevels = allLevels.Where(l =&gt; !completedLevels.Contains(l.levelName)).Select(l =&gt; l.levelName);&#10;                Debug.Log($&quot;[GameFlowManager] Remaining levels: {string.Join(&quot;, &quot;, remainingLevels)}&quot;);&#10;                return false;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Error checking game completion: {e}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private async void TransitionToVictorySceneAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(victoryTransitionDelay * 1000));&#10;                &#10;                _eventBus?.Publish(new GameCompletedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    FinalLevelName = _currentLevelName&#10;                });&#10;                &#10;                SceneManager.LoadScene(victorySceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to transition to victory scene: {e}&quot;);&#10;                SceneManager.LoadScene(&quot;Level Select&quot;);&#10;            }&#10;        }&#10;&#10;        private async void ReturnToLevelSelectionAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(2f * 1000));&#10;                SceneManager.LoadScene(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to return to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnPlayerLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            bool lostLife = livesEvent.PreviousLives &gt; livesEvent.CurrentLives;&#10;            bool isGameOver = livesEvent.CurrentLives == 0;&#10;&#10;            if (isGameOver)&#10;            {&#10;                ChangeState(GameState.GameOver);&#10;                _gameDataCoordinator?.ResetAllData();&#10;                _eventBus?.Publish(new GameOverEvent { Timestamp = Time.time });&#10;            }&#10;&#10;            if (lostLife)&#10;            {&#10;                _eventBus?.Publish(new PlayerDeathEvent&#10;                {&#10;                    DeathPosition = PlayerLocator.PlayerTransform.position,&#10;                    Timestamp = Time.time&#10;                });&#10;            }&#10;&#10;            if (isGameOver || lostLife)&#10;            {&#10;                Time.timeScale = 0.01f;&#10;                RestartLevelAfterDelayAsync(restartDelay);&#10;            }&#10;        }&#10;&#10;        private static async void RestartLevelAfterDelayAsync(float delay)&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(delay * 1000));&#10;                SceneManager.LoadScene(SceneManager.GetActiveScene().name);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to restart level after delay: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ChangeState(GameState newState)&#10;        {&#10;            if (CurrentState == newState) return;&#10;&#10;            GameState oldState = CurrentState;&#10;            CurrentState = newState;&#10;&#10;            _eventBus?.Publish(new GameStateChangedEvent&#10;            {&#10;                PreviousState = oldState,&#10;                NewState = newState,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private string GetCurrentLevelName() =&gt; SceneManager.GetActiveScene().name;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using Player.Components;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameFlowManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Game Settings&quot;)]&#10;        [SerializeField] private bool autoStartGame = true;&#10;        [SerializeField] private float restartDelay = 2f;&#10;        &#10;        [Header(&quot;Victory Settings&quot;)]&#10;        [SerializeField] private string victorySceneName = &quot;YouWonScene&quot;;&#10;        [SerializeField] private float victoryTransitionDelay = 3f;&#10;&#10;        private string _currentLevelName = &quot;Unknown&quot;;&#10;        private float _levelStartTime;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;&#10;        public GameState CurrentState { get; private set; } = GameState.MainMenu;&#10;        public bool IsPlaying =&gt; CurrentState == GameState.Playing;&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, GameDataCoordinator gameDataCoordinator)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            _currentLevelName = GetCurrentLevelName();&#10;&#10;            if (autoStartGame)&#10;            {&#10;                StartGame();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            UnsubscribeFromEvents();&#10;        }&#10;&#10;        private void StartGame()&#10;        {&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = _currentLevelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void PauseGame()&#10;        {&#10;            if (CurrentState == GameState.Playing)&#10;                ChangeState(GameState.Paused);&#10;        }&#10;&#10;        public void ResumeGame()&#10;        {&#10;            if (CurrentState == GameState.Paused)&#10;                ChangeState(GameState.Playing);&#10;        }&#10;&#10;        public void RestartLevel()&#10;        {&#10;            SceneManager.LoadScene(SceneManager.GetActiveScene().name);&#10;        }&#10;&#10;        public void HandlePlayerDeath(Vector3 deathPosition)&#10;        {&#10;            _eventBus?.Publish(new PlayerDeathEvent&#10;            {&#10;                DeathPosition = deathPosition,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void CompleteLevel(string currentLevelName)&#10;        {&#10;            float completionTime = Time.time - _levelStartTime;&#10;            &#10;            _eventBus?.Publish(new LevelCompletedEvent&#10;            {&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void RequestLevelLoad(string levelName, string sceneName)&#10;        {&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                SceneName = sceneName&#10;            });&#10;        }&#10;&#10;        public void SelectLevel(string levelName, int levelIndex)&#10;        {&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                LevelIndex = levelIndex&#10;            });&#10;        }&#10;&#10;        public void NavigateLevel(int previousIndex, int newIndex, Vector2 direction)&#10;        {&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = newIndex,&#10;                Direction = direction&#10;            });&#10;        }&#10;&#10;        public void NavigateToLevelSelection()&#10;        {&#10;            try&#10;            {&#10;                ChangeState(GameState.LevelSelection);&#10;                SceneManager.LoadScene(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to navigate to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void OnGameOver(GameOverEvent gameOverEvent)&#10;        {&#10;            ChangeState(GameState.GameOver);&#10;            RestartLevelAfterDelayAsync(restartDelay);&#10;        }&#10;&#10;        private async void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            ChangeState(GameState.Victory);&#10;&#10;            // First, check if the level was already completed&#10;            bool wasAlreadyCompleted = _gameDataCoordinator.IsLevelCompleted(levelEvent.LevelName);&#10;&#10;            // Now, update the progress (marks as complete, updates best time, etc.)&#10;            _gameDataCoordinator.UpdateLevelProgress(levelEvent.LevelName, true, levelEvent.CompletionTime);&#10;&#10;            // If it's the first time completing this level, unlock the next one&#10;            if (!wasAlreadyCompleted)&#10;            {&#10;                await UnlockNextLevelByIndex(levelEvent.LevelName);&#10;            }&#10;&#10;            if (await IsGameCompletedAsync())&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] All levels completed! Transitioning to YouWonScene...&quot;);&#10;                TransitionToVictorySceneAsync();&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] Level {levelEvent.LevelName} completed. Returning to level selection...&quot;);&#10;                ReturnToLevelSelectionAsync();&#10;            }&#10;        }&#10;&#10;        private async Task UnlockNextLevelByIndex(string completedLevelName)&#10;        {&#10;            Debug.Log($&quot;[GameFlowManager] UnlockNextLevelByIndex called for: {completedLevelName}&quot;);&#10;            &#10;            var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            if (allLevels == null || allLevels.Count == 0) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] No levels discovered for unlocking next level&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Found {allLevels.Count} levels total&quot;);&#10;            &#10;            var completedLevel = allLevels.FirstOrDefault(l =&gt; l.levelName == completedLevelName);&#10;            if (completedLevel == null) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] Could not find completed level: {completedLevelName}&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Completed level index: {completedLevel.levelIndex}&quot;);&#10;            int nextLevelIndex = completedLevel.levelIndex + 1;&#10;&#10;            if (nextLevelIndex &lt; allLevels.Count)&#10;            {&#10;                var nextLevel = allLevels.FirstOrDefault(l =&gt; l.levelIndex == nextLevelIndex);&#10;                if (nextLevel != null)&#10;                {&#10;                    bool isAlreadyUnlocked = _gameDataCoordinator.IsLevelUnlocked(nextLevel.levelName);&#10;                    Debug.Log($&quot;[GameFlowManager] Next level '{nextLevel.levelName}' (index {nextLevelIndex}) - Already unlocked: {isAlreadyUnlocked}&quot;);&#10;                    &#10;                    if (!isAlreadyUnlocked)&#10;                    {&#10;                        _gameDataCoordinator.UnlockLevel(nextLevel.levelName);&#10;                        Debug.Log($&quot;[GameFlowManager] Unlocked next level: {nextLevel.levelName}&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        Debug.Log($&quot;[GameFlowManager] Next level {nextLevel.levelName} was already unlocked&quot;);&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;[GameFlowManager] Could not find level with index {nextLevelIndex}&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] No more levels to unlock (completed level was the last one)&quot;);&#10;            }&#10;        }&#10;&#10;        private async Task&lt;bool&gt; IsGameCompletedAsync()&#10;        {&#10;            try&#10;            {&#10;                // Get all available levels through GameDataCoordinator&#10;                var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;                &#10;                if (allLevels == null || allLevels.Count == 0)&#10;                {&#10;                    Debug.LogWarning(&quot;[GameFlowManager] No levels found in discovery service&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Get completed levels using wrapper method&#10;                var completedLevels = _gameDataCoordinator?.GetCompletedLevels();&#10;                if (completedLevels == null) return false;&#10;&#10;                // Check if all levels are in the completed list&#10;                var completedCount = 0;&#10;                foreach (var level in allLevels)&#10;                {&#10;                    if (completedLevels.Contains(level.levelName))&#10;                    {&#10;                        completedCount++;&#10;                    }&#10;                }&#10;                &#10;                Debug.Log($&quot;[GameFlowManager] Game completion check: {completedCount}/{allLevels.Count} levels completed&quot;);&#10;                &#10;                if (completedCount &gt;= allLevels.Count)&#10;                {&#10;                    Debug.Log(&quot;[GameFlowManager] All levels completed!&quot;);&#10;                    return true;&#10;                }&#10;&#10;                var remainingLevels = allLevels.Where(l =&gt; !completedLevels.Contains(l.levelName)).Select(l =&gt; l.levelName);&#10;                Debug.Log($&quot;[GameFlowManager] Remaining levels: {string.Join(&quot;, &quot;, remainingLevels)}&quot;);&#10;                return false;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Error checking game completion: {e}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private async void TransitionToVictorySceneAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(victoryTransitionDelay * 1000));&#10;                &#10;                _eventBus?.Publish(new GameCompletedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    FinalLevelName = _currentLevelName&#10;                });&#10;                &#10;                SceneManager.LoadScene(victorySceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to transition to victory scene: {e}&quot;);&#10;                SceneManager.LoadScene(&quot;Level Select&quot;);&#10;            }&#10;        }&#10;&#10;        private async void ReturnToLevelSelectionAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(2f * 1000));&#10;                ChangeState(GameState.LevelSelection);&#10;                SceneManager.LoadScene(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to return to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnPlayerLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            bool lostLife = livesEvent.PreviousLives &gt; livesEvent.CurrentLives;&#10;            bool isGameOver = livesEvent.CurrentLives == 0;&#10;&#10;            if (isGameOver)&#10;            {&#10;                ChangeState(GameState.GameOver);&#10;                _gameDataCoordinator?.ResetAllData();&#10;                _eventBus?.Publish(new GameOverEvent { Timestamp = Time.time });&#10;            }&#10;&#10;            if (lostLife)&#10;            {&#10;                _eventBus?.Publish(new PlayerDeathEvent&#10;                {&#10;                    DeathPosition = PlayerLocator.PlayerTransform.position,&#10;                    Timestamp = Time.time&#10;                });&#10;            }&#10;&#10;            if (isGameOver || lostLife)&#10;            {&#10;                Time.timeScale = 0.01f;&#10;                RestartLevelAfterDelayAsync(restartDelay);&#10;            }&#10;        }&#10;&#10;        private static async void RestartLevelAfterDelayAsync(float delay)&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(delay * 1000));&#10;                SceneManager.LoadScene(SceneManager.GetActiveScene().name);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to restart level after delay: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ChangeState(GameState newState)&#10;        {&#10;            if (CurrentState == newState) return;&#10;&#10;            GameState oldState = CurrentState;&#10;            CurrentState = newState;&#10;&#10;            _eventBus?.Publish(new GameStateChangedEvent&#10;            {&#10;                PreviousState = oldState,&#10;                NewState = newState,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private string GetCurrentLevelName() =&gt; SceneManager.GetActiveScene().name;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameListener.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameListener.cs" />
              <option name="originalContent" value="using Core;&#10;using UnityEngine;&#10;using UnityEngine.EventSystems;&#10;&#10;namespace StartGame&#10;{&#10;    public class StartGameListener : MonoBehaviour, ISubmitHandler&#10;    {&#10;        [SerializeField] private GameFlowManager gameFlowManager;&#10;&#10;        public void OnSubmit(BaseEventData eventData)&#10;        {&#10;            StartGame();&#10;        }&#10;&#10;        private void StartGame()&#10;        {&#10;            if (gameFlowManager != null)&#10;            {&#10;                gameFlowManager.NavigateToLevelSelection();&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;GameFlowManager is not assigned.&quot;);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Core;&#10;using UnityEngine;&#10;using UnityEngine.EventSystems;&#10;&#10;namespace StartGame&#10;{&#10;    public class StartGameListener : MonoBehaviour, ISubmitHandler&#10;    {&#10;        [SerializeField] private GameFlowManager gameFlowManager;&#10;&#10;        public void OnSubmit(BaseEventData eventData)&#10;        {&#10;            StartGame();&#10;        }&#10;&#10;        private void StartGame()&#10;        {&#10;            if (gameFlowManager != null)&#10;            {&#10;                gameFlowManager.NavigateToLevelSelection();&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;GameFlowManager is not assigned.&quot;);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>