<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scenes/LevelsTemplatePipeline.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scenes/LevelsTemplatePipeline.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using UnityEditor.SceneTemplate;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;&#10;public class LevelsTemplatePipeline : ISceneTemplatePipeline&#10;{&#10;    public virtual bool IsValidTemplateForInstantiation(SceneTemplateAsset sceneTemplateAsset)&#10;    {&#10;        return true;&#10;    }&#10;&#10;    public virtual void BeforeTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, bool isAdditive, string sceneName)&#10;    {&#10;        &#10;    }&#10;&#10;    public virtual void AfterTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, Scene scene, bool isAdditive, string sceneName)&#10;    {&#10;        var sceneFolder = System.IO.Path.Combine(&quot;Assets&quot;, &quot;Scenes&quot;);&#10;        var sceneFiles = System.IO.Directory.GetFiles(sceneFolder, &quot;Level*.unity&quot;);&#10;        int levelPrefixLength = &quot;Level&quot;.Length;&#10;        int maxLevel = sceneFiles&#10;            .Select(System.IO.Path.GetFileNameWithoutExtension)&#10;            .Where(fileName =&gt; fileName.StartsWith(&quot;Level&quot;))&#10;            .Select(fileName =&gt; int.TryParse(fileName[levelPrefixLength..], out int num) ? num : 0)&#10;            .DefaultIfEmpty(0)&#10;            .Max();&#10;        string newLevelName = $&quot;Level{maxLevel + 1}&quot;;&#10;        scene.name = newLevelName;&#10;        SceneManager.SetActiveScene(scene);&#10;        Debug.Log($&quot;[LevelsTemplatePipeline] Instantiated new level: {newLevelName}&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Linq;&#10;using UnityEditor.SceneTemplate;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;&#10;public class LevelsTemplatePipeline : ISceneTemplatePipeline&#10;{&#10;    public virtual bool IsValidTemplateForInstantiation(SceneTemplateAsset sceneTemplateAsset)&#10;    {&#10;        return true;&#10;    }&#10;&#10;    public virtual void BeforeTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, bool isAdditive, string sceneName)&#10;    {&#10;        &#10;    }&#10;&#10;    public virtual void AfterTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, Scene scene, bool isAdditive, string sceneName)&#10;    {&#10;        var sceneFolder = System.IO.Path.Combine(&quot;Assets&quot;, &quot;Scenes&quot;);&#10;        var sceneFiles = System.IO.Directory.GetFiles(sceneFolder, &quot;Level*.unity&quot;);&#10;        int levelPrefixLength = &quot;Level&quot;.Length;&#10;        int maxLevel = sceneFiles&#10;            .Select(System.IO.Path.GetFileNameWithoutExtension)&#10;            .Where(fileName =&gt; fileName.StartsWith(&quot;Level&quot;))&#10;            .Select(fileName =&gt; int.TryParse(fileName[levelPrefixLength..], out int num) ? num : 0)&#10;            .DefaultIfEmpty(0)&#10;            .Max();&#10;        string newLevelName = $&quot;Level{maxLevel + 1}&quot;;&#10;        scene.name = newLevelName;&#10;        SceneManager.SetActiveScene(scene);&#10;        Debug.Log($&quot;[LevelsTemplatePipeline] Instantiated new level: {newLevelName}&quot;);&#10;&#10;        // Show save file dialog with the new scene name as default&#10;#if UNITY_EDITOR&#10;        string savePath = UnityEditor.EditorUtility.SaveFilePanel(&#10;            &quot;Save New Scene&quot;,&#10;            sceneFolder,&#10;            newLevelName,&#10;            &quot;unity&quot;&#10;        );&#10;        if (!string.IsNullOrEmpty(savePath))&#10;        {&#10;            UnityEditor.SceneManagement.EditorSceneManager.SaveScene(scene, savePath);&#10;            Debug.Log($&quot;[LevelsTemplatePipeline] Scene saved to: {savePath}&quot;);&#10;        }&#10;#endif&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/ScoreCollectionTracker.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/ScoreCollectionTracker.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/DI/GameLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/DI/GameLifetimeScope.cs" />
              <option name="originalContent" value="using Collectables.Score;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection;&#10;using Player.Components;&#10;using Player.Interfaces;&#10;using Player.Services;&#10;using Player.UI;&#10;using Pooling;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;using Weapons.Models;&#10;using Weapons.Services;&#10;&#10;namespace Core.DI&#10;{&#10;    public class GameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Awake()&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Awake called.&quot;);&#10;            AddToAutoInject&lt;FireballWeapon&gt;();&#10;            base.Awake();&#10;        }&#10;&#10;        public void AddToAutoInject&lt;T&gt;() where T : Component&#10;        {&#10;&#10;            var components = FindObjectsByType&lt;T&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;&#10;            foreach (T comp in components)&#10;            {&#10;                autoInjectGameObjects.Add(comp.gameObject);&#10;            }&#10;        }&#10;&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Configuring DI container...&quot;);&#10;&#10;            // Register Core Services&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;&#10;            // Register EventBus as IEventPublisher as well (since EventBus implements IEventPublisher)&#10;            builder.Register&lt;IEventPublisher&gt;(resolver =&gt; resolver.Resolve&lt;IEventBus&gt;(), Lifetime.Singleton);&#10;&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IScoreService, ScoreService&gt;(Lifetime.Singleton);&#10;&#10;            // Register Level Selection components&#10;            builder.RegisterComponentInHierarchy&lt;LevelSelectionManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;LevelSelector&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;ItemSelectScreen&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;NESCrossfade&gt;();&#10;&#10;            // Register Player Services&#10;            builder.Register&lt;IPlayerLivesService&gt;(resolver&#10;                =&gt; new PlayerLivesService(&#10;                    resolver.Resolve&lt;IGameDataService&gt;(),&#10;                    resolver.Resolve&lt;IEventBus&gt;()&#10;                ), Lifetime.Singleton);&#10;&#10;            // Game Management&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;            // Pooling System&#10;            builder.RegisterComponentInHierarchy&lt;PoolManager&gt;().As&lt;IPoolService&gt;();&#10;&#10;            // Weapons&#10;            builder.RegisterComponentInHierarchy&lt;AxeWeapon&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;WeaponManagerService&gt;();&#10;&#10;            // Health&#10;            builder.RegisterComponentInHierarchy&lt;PlayerHealthController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerLivesUIController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerAnimationController&gt;();&#10;&#10;            // Score System&#10;            builder.RegisterComponentInHierarchy&lt;ScoreController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PopupTextService&gt;();&#10;&#10;&#10;            Debug.Log(&quot;[GameLifetimeScope] DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Collectables.Score;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using Player.Components;&#10;using Player.Interfaces;&#10;using Player.Services;&#10;using Player.UI;&#10;using Pooling;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;using Weapons.Models;&#10;using Weapons.Services;&#10;&#10;namespace Core.DI&#10;{&#10;    public class GameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Awake()&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Awake called.&quot;);&#10;            AddToAutoInject&lt;FireballWeapon&gt;();&#10;            base.Awake();&#10;        }&#10;&#10;        public void AddToAutoInject&lt;T&gt;() where T : Component&#10;        {&#10;&#10;            var components = FindObjectsByType&lt;T&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;&#10;            foreach (T comp in components)&#10;            {&#10;                autoInjectGameObjects.Add(comp.gameObject);&#10;            }&#10;        }&#10;&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Configuring DI container...&quot;);&#10;&#10;            // Register Core Services&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;&#10;            // Register EventBus as IEventPublisher as well (since EventBus implements IEventPublisher)&#10;            builder.Register&lt;IEventPublisher&gt;(resolver =&gt; resolver.Resolve&lt;IEventBus&gt;(), Lifetime.Singleton);&#10;&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IScoreService, ScoreService&gt;(Lifetime.Singleton);&#10;&#10;            // Level Selection components are now handled by LevelSelectionLifetimeScope&#10;&#10;            // Register Player Services&#10;            builder.Register&lt;IPlayerLivesService&gt;(resolver&#10;                =&gt; new PlayerLivesService(&#10;                    resolver.Resolve&lt;IGameDataService&gt;(),&#10;                    resolver.Resolve&lt;IEventBus&gt;()&#10;                ), Lifetime.Singleton);&#10;&#10;            // Game Management&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;            // Pooling System&#10;            builder.RegisterComponentInHierarchy&lt;PoolManager&gt;().As&lt;IPoolService&gt;();&#10;&#10;            // Weapons&#10;            builder.RegisterComponentInHierarchy&lt;AxeWeapon&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;WeaponManagerService&gt;();&#10;&#10;            // Health&#10;            builder.RegisterComponentInHierarchy&lt;PlayerHealthController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerLivesUIController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerAnimationController&gt;();&#10;&#10;            // Score System&#10;            builder.RegisterComponentInHierarchy&lt;ScoreController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PopupTextService&gt;();&#10;&#10;&#10;            Debug.Log(&quot;[GameLifetimeScope] DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Data/GameData.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Data/GameData.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Core.Data&#10;{&#10;    [Serializable]&#10;    public class GameData&#10;    {&#10;        [Header(&quot;Player Data&quot;)] public const int MaxLives = 3;&#10;        [Header(&quot;Player Data&quot;)] public int lives = 3;&#10;&#10;        public int score;&#10;&#10;        [Header(&quot;Level Progress&quot;)] public string currentLevel = &quot;Level_01&quot;;&#10;&#10;        // Level Selection Data&#10;        public List&lt;string&gt; unlockedLevels = new() { &quot;Level_01&quot; };&#10;        public List&lt;string&gt; completedLevels = new(); // Added for EndLevelZone&#10;        public int selectedLevelIndex;&#10;&#10;        public float bestTime = float.MaxValue;&#10;&#10;        [Header(&quot;Power-ups&quot;)] public bool hasFireball;&#10;&#10;        public bool hasAxe;&#10;&#10;        [Header(&quot;Settings&quot;)] public float musicVolume = 1.0f;&#10;&#10;        public float sfxVolume = 1.0f;&#10;&#10;        [Header(&quot;Collectables&quot;)] public int fruitCollected;&#10;        public Dictionary&lt;string, float&gt; levelBestTimes = new();&#10;        public Dictionary&lt;string, bool&gt; levelCompleted = new();&#10;&#10;        // Constructor for easy initialization&#10;        public GameData()&#10;        {&#10;            // Default values are set by field initializers&#10;        }&#10;&#10;        // Copy constructor&#10;        public GameData(GameData other)&#10;        {&#10;            lives = other.lives;&#10;            score = other.score;&#10;            currentLevel = other.currentLevel;&#10;            bestTime = other.bestTime;&#10;            hasFireball = other.hasFireball;&#10;            hasAxe = other.hasAxe;&#10;            musicVolume = other.musicVolume;&#10;            sfxVolume = other.sfxVolume;&#10;            fruitCollected = other.fruitCollected;&#10;            unlockedLevels = new List&lt;string&gt;(other.unlockedLevels);&#10;            selectedLevelIndex = other.selectedLevelIndex;&#10;            levelBestTimes = new Dictionary&lt;string, float&gt;(other.levelBestTimes);&#10;            levelCompleted = new Dictionary&lt;string, bool&gt;(other.levelCompleted);&#10;        }&#10;&#10;        // Reset to default values&#10;        public void Reset()&#10;        {&#10;            lives = MaxLives;&#10;            score = 0;&#10;            currentLevel = &quot;Level_01&quot;;&#10;            bestTime = float.MaxValue;&#10;            hasFireball = false;&#10;            hasAxe = false;&#10;            musicVolume = 1.0f;&#10;            sfxVolume = 1.0f;&#10;            fruitCollected = 0;&#10;&#10;            // Reset level selection data&#10;            unlockedLevels = new List&lt;string&gt; { &quot;Level_01&quot; };&#10;            selectedLevelIndex = 0;&#10;            levelBestTimes = new Dictionary&lt;string, float&gt;();&#10;            levelCompleted = new Dictionary&lt;string, bool&gt;();&#10;        }&#10;&#10;        private static GameData CreateDefaultData() =&gt;&#10;            new()&#10;            {&#10;                lives = MaxLives,&#10;                score = 0,&#10;                currentLevel = &quot;Level_01&quot;,&#10;                bestTime = float.MaxValue,&#10;                hasFireball = false,&#10;                hasAxe = false,&#10;                musicVolume = 1.0f,&#10;                sfxVolume = 1.0f,&#10;                fruitCollected = 0,&#10;                unlockedLevels = new List&lt;string&gt; { &quot;Level_01&quot; },&#10;                selectedLevelIndex = 0,&#10;                levelBestTimes = new Dictionary&lt;string, float&gt;(),&#10;                levelCompleted = new Dictionary&lt;string, bool&gt;()&#10;            };&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Core.Data&#10;{&#10;    [Serializable]&#10;    public class GameData&#10;    {&#10;        [Header(&quot;Player Data&quot;)] &#10;        public const int MaxLives = 3;&#10;        public int lives = 3;&#10;        public int score;&#10;        public int maxScore; // Track highest score ever achieved&#10;&#10;        [Header(&quot;Level Progress&quot;)] &#10;        public string currentLevel = &quot;Level_01&quot;;&#10;&#10;        // Level Selection Data&#10;        public List&lt;string&gt; unlockedLevels = new() { &quot;Level_01&quot; };&#10;        public List&lt;string&gt; completedLevels = new(); // Added for EndLevelZone&#10;        public int selectedLevelIndex;&#10;&#10;        // Enhanced timing and scoring data&#10;        public Dictionary&lt;string, float&gt; levelBestTimes = new();&#10;        public Dictionary&lt;string, int&gt; levelBestScores = new(); // Best score per level&#10;        public Dictionary&lt;string, bool&gt; levelCompleted = new();&#10;        &#10;        public float bestTime = float.MaxValue; // Overall best time&#10;&#10;        [Header(&quot;Power-ups&quot;)] &#10;        public bool hasFireball;&#10;        public bool hasAxe;&#10;&#10;        [Header(&quot;Settings&quot;)] &#10;        public float musicVolume = 1.0f;&#10;        public float sfxVolume = 1.0f;&#10;&#10;        [Header(&quot;Collectables&quot;)] &#10;        public int fruitCollected;&#10;&#10;        // Constructor for easy initialization&#10;        public GameData()&#10;        {&#10;            // Default values are set by field initializers&#10;        }&#10;&#10;        // Copy constructor&#10;        public GameData(GameData other)&#10;        {&#10;            lives = other.lives;&#10;            score = other.score;&#10;            maxScore = other.maxScore;&#10;            currentLevel = other.currentLevel;&#10;            bestTime = other.bestTime;&#10;            hasFireball = other.hasFireball;&#10;            hasAxe = other.hasAxe;&#10;            musicVolume = other.musicVolume;&#10;            sfxVolume = other.sfxVolume;&#10;            fruitCollected = other.fruitCollected;&#10;            unlockedLevels = new List&lt;string&gt;(other.unlockedLevels);&#10;            completedLevels = new List&lt;string&gt;(other.completedLevels);&#10;            selectedLevelIndex = other.selectedLevelIndex;&#10;            levelBestTimes = new Dictionary&lt;string, float&gt;(other.levelBestTimes);&#10;            levelBestScores = new Dictionary&lt;string, int&gt;(other.levelBestScores);&#10;            levelCompleted = new Dictionary&lt;string, bool&gt;(other.levelCompleted);&#10;        }&#10;&#10;        // Reset to default values&#10;        public void Reset()&#10;        {&#10;            lives = MaxLives;&#10;            score = 0;&#10;            maxScore = 0;&#10;            currentLevel = &quot;Level_01&quot;;&#10;            bestTime = float.MaxValue;&#10;            hasFireball = false;&#10;            hasAxe = false;&#10;            musicVolume = 1.0f;&#10;            sfxVolume = 1.0f;&#10;            fruitCollected = 0;&#10;            &#10;            // Reset level selection data&#10;            unlockedLevels = new List&lt;string&gt; { &quot;Level_01&quot; };&#10;            completedLevels = new List&lt;string&gt;();&#10;            selectedLevelIndex = 0;&#10;            levelBestTimes = new Dictionary&lt;string, float&gt;();&#10;            levelBestScores = new Dictionary&lt;string, int&gt;();&#10;            levelCompleted = new Dictionary&lt;string, bool&gt;();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Update best time for a specific level&#10;        /// &lt;/summary&gt;&#10;        public void UpdateLevelBestTime(string levelName, float completionTime)&#10;        {&#10;            if (string.IsNullOrEmpty(levelName)) return;&#10;            &#10;            if (!levelBestTimes.ContainsKey(levelName) || completionTime &lt; levelBestTimes[levelName])&#10;            {&#10;                levelBestTimes[levelName] = completionTime;&#10;                &#10;                // Update overall best time if this is better&#10;                if (completionTime &lt; bestTime)&#10;                {&#10;                    bestTime = completionTime;&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Update best score for a specific level&#10;        /// &lt;/summary&gt;&#10;        public void UpdateLevelBestScore(string levelName, int levelScore)&#10;        {&#10;            if (string.IsNullOrEmpty(levelName)) return;&#10;            &#10;            if (!levelBestScores.ContainsKey(levelName) || levelScore &gt; levelBestScores[levelName])&#10;            {&#10;                levelBestScores[levelName] = levelScore;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Update max score if current score is higher&#10;        /// &lt;/summary&gt;&#10;        public void UpdateMaxScore(int currentScore)&#10;        {&#10;            if (currentScore &gt; maxScore)&#10;            {&#10;                maxScore = currentScore;&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Get best time for a specific level&#10;        /// &lt;/summary&gt;&#10;        public float GetLevelBestTime(string levelName)&#10;        {&#10;            return levelBestTimes.TryGetValue(levelName, out float time) ? time : float.MaxValue;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Get best score for a specific level&#10;        /// &lt;/summary&gt;&#10;        public int GetLevelBestScore(string levelName)&#10;        {&#10;            return levelBestScores.TryGetValue(levelName, out int score) ? score : 0;&#10;        }&#10;&#10;        private static GameData CreateDefaultData() =&gt;&#10;            new()&#10;            {&#10;                lives = MaxLives,&#10;                score = 0,&#10;                currentLevel = &quot;Level_01&quot;,&#10;                bestTime = float.MaxValue,&#10;                hasFireball = false,&#10;                hasAxe = false,&#10;                musicVolume = 1.0f,&#10;                sfxVolume = 1.0f,&#10;                fruitCollected = 0,&#10;                unlockedLevels = new List&lt;string&gt; { &quot;Level_01&quot; },&#10;                selectedLevelIndex = 0,&#10;                levelBestTimes = new Dictionary&lt;string, float&gt;(),&#10;                levelCompleted = new Dictionary&lt;string, bool&gt;()&#10;            };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/GameEvents.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/GameEvents.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Core.Events&#10;{&#10;    public enum GameState&#10;    {&#10;        MainMenu,&#10;        LevelSelection, // Added LevelSelection state&#10;        Loading,&#10;        Playing,&#10;        Paused,&#10;        GameOver,&#10;        Victory,&#10;        Restarting&#10;    }&#10;&#10;    public struct GameStateChangedEvent&#10;    {&#10;        public GameState PreviousState;&#10;        public GameState NewState;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerHealthChangedEvent&#10;    {&#10;        public int CurrentHp;&#10;        public int MaxHp;&#10;        public int Damage;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerLivesChangedEvent&#10;    {&#10;        public int PreviousLives;&#10;        public int CurrentLives;&#10;        public int MaxLives;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct ScoreChangedEvent&#10;    {&#10;        public Vector3 Position;&#10;        public int ScoreAmount; // Delta amount&#10;        public int TotalScore; // Overall score&#10;    }&#10;&#10;    // Base event structure for consistency&#10;    public interface IGameEvent&#10;    {&#10;        float Timestamp { get; }&#10;    }&#10;&#10;    public struct PlayerDeathEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public Vector3 DeathPosition;&#10;    }&#10;&#10;    public struct LevelStartedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Event published when a level is completed&#10;    /// &lt;/summary&gt;&#10;    public struct LevelCompletedEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string CompletedLevelName { get; set; }&#10;        public string UnlockedLevelName { get; set; }&#10;    }&#10;&#10;&#10;    public struct GameOverEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;    }&#10;&#10;    // Level Selection Events&#10;    public struct LevelSelectedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;        public int LevelIndex;&#10;    }&#10;&#10;    public struct LevelNavigationEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public int PreviousIndex;&#10;        public int NewIndex;&#10;        public Vector2 Direction;&#10;    }&#10;&#10;    public struct ItemSelectScreenRequestedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;    }&#10;&#10;    public struct LevelLoadRequestedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;        public string SceneName;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Core.Events&#10;{&#10;    public enum GameState&#10;    {&#10;        MainMenu,&#10;        LevelSelection, // Added LevelSelection state&#10;        Loading,&#10;        Playing,&#10;        Paused,&#10;        GameOver,&#10;        Victory,&#10;        Restarting&#10;    }&#10;&#10;    public struct GameStateChangedEvent&#10;    {&#10;        public GameState PreviousState;&#10;        public GameState NewState;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerHealthChangedEvent&#10;    {&#10;        public int CurrentHp;&#10;        public int MaxHp;&#10;        public int Damage;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerLivesChangedEvent&#10;    {&#10;        public int PreviousLives;&#10;        public int CurrentLives;&#10;        public int MaxLives;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct ScoreChangedEvent&#10;    {&#10;        public Vector3 Position;&#10;        public int ScoreAmount; // Delta amount&#10;        public int TotalScore; // Overall score&#10;    }&#10;&#10;    // Base event structure for consistency&#10;    public interface IGameEvent&#10;    {&#10;        float Timestamp { get; }&#10;    }&#10;&#10;    public struct PlayerDeathEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public Vector3 DeathPosition;&#10;    }&#10;&#10;    public struct LevelStartedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;    }&#10;&#10;    public struct LevelCompletedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;        public float CompletionTime;&#10;    }&#10;&#10;    public struct GameOverEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;    }&#10;&#10;    // Level Selection Events&#10;    public struct LevelSelectedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;        public int LevelIndex;&#10;    }&#10;&#10;    public struct LevelNavigationEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public int PreviousIndex;&#10;        public int NewIndex;&#10;        public Vector2 Direction;&#10;    }&#10;&#10;    public struct ItemSelectScreenRequestedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;    }&#10;&#10;    public struct LevelLoadRequestedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;        public string SceneName;&#10;    }&#10;&#10;    public struct LevelUnlockedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string CompletedLevelName;&#10;        public string UnlockedLevelName;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/GameDataCoordinator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/GameDataCoordinator.cs" />
              <option name="originalContent" value="using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Coordinates between game events and data storage.&#10;    ///     Responsible only for translating events into data updates and managing save operations.&#10;    /// &lt;/summary&gt;&#10;    public class GameDataCoordinator : MonoBehaviour&#10;    {&#10;        [SerializeField] private float autoSaveInterval = 30;&#10;        private IAutoSaveService _autoSaveService;&#10;        private IEventBus _eventBus;&#10;        private IGameDataService _gameDataService;&#10;        private bool _isInitialized;&#10;&#10;        #region VContainer Injection&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            IGameDataService gameDataService,&#10;            IEventBus eventBus,&#10;            IAutoSaveService autoSaveService)&#10;        {&#10;            _gameDataService = gameDataService;&#10;            _eventBus = eventBus;&#10;            _autoSaveService = autoSaveService;&#10;            _isInitialized = true;&#10;&#10;&#10;            // Initialize after dependencies are injected&#10;            Initialize();&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Initialization&#10;&#10;        private void Initialize()&#10;        {&#10;            // Subscribe to events - only subscribe to events that affect game data&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted); // For best time tracking&#10;            _eventBus?.Subscribe&lt;LevelStartedEvent&gt;(OnLevelStarted); // For current level tracking&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnLivesChanged); // For lives tracking&#10;            _eventBus?.Subscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged); // For game state changes&#10;&#10;            _eventBus?.Subscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;&#10;            if (_gameDataService != null)&#10;                _gameDataService.OnDataChanged += OnGameDataChanged;&#10;&#10;            if (_autoSaveService != null)&#10;            {&#10;                _autoSaveService.OnSaveRequested += SaveData;&#10;                _autoSaveService.SaveInterval = autoSaveInterval;&#10;                _autoSaveService.IsEnabled = true;&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Private Methods&#10;&#10;        private void SaveData()&#10;        {&#10;            _gameDataService?.SaveData();&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Unity Lifecycle&#10;&#10;        private void Start()&#10;        {&#10;            // If not yet initialized (dependencies not injected), wait&#10;            if (!_isInitialized)&#10;            {&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.Update();&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (!_isInitialized) return;&#10;&#10;            // Unsubscribe from events&#10;            if (_eventBus != null)&#10;            {&#10;                _eventBus.Unsubscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;                _eventBus.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;                _eventBus.Unsubscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;                _eventBus.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnLivesChanged);&#10;                _eventBus.Unsubscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged);&#10;            }&#10;&#10;&#10;            if (_gameDataService != null)&#10;                _gameDataService.OnDataChanged -= OnGameDataChanged;&#10;&#10;            if (_autoSaveService != null)&#10;            {&#10;                _autoSaveService.OnSaveRequested -= SaveData;&#10;                _autoSaveService.ForceSave();&#10;            }&#10;        }&#10;&#10;        private void OnApplicationPause(bool pauseStatus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationPause(pauseStatus);&#10;        }&#10;&#10;        private void OnApplicationFocus(bool hasFocus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationFocus(hasFocus);&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Event Handlers&#10;&#10;        private void OnPlayerDied(PlayerDeathEvent deathEvent)&#10;        {&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateBestTime(levelEvent.CompletionTime);&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnGameStateChanged(GameStateChangedEvent stateEvent)&#10;        {&#10;            // Handle data operations based on state changes&#10;            if (stateEvent.NewState is GameState.Victory or GameState.GameOver)&#10;            {&#10;                _autoSaveService?.ForceSave();&#10;            }&#10;        }&#10;        private void OnLevelStarted(LevelStartedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateCurrentLevel(levelEvent.LevelName);&#10;        }&#10;        private void OnLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            Debug.Log(&#10;                $&quot;[GameDataCoordinator] Received PlayerLivesChangedEvent: CurrentLives={livesEvent.CurrentLives}&quot;);&#10;&#10;            _gameDataService?.UpdateLives(livesEvent.CurrentLives);&#10;            Debug.Log($&quot;[GameDataCoordinator] Updated GameData lives to: {_gameDataService?.CurrentData.lives}&quot;);&#10;        }&#10;&#10;        private void OnGameDataChanged(GameData newData)&#10;        {&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Public API&#10;&#10;        public GameData GetCurrentData()&#10;        {&#10;            if (!_isInitialized || _gameDataService == null) return null;&#10;&#10;            return _gameDataService.CurrentData;&#10;        }&#10;&#10;        public void ResetAllData()&#10;        {&#10;            if (!_isInitialized) return;&#10;&#10;            _gameDataService?.ResetAllData();&#10;        }&#10;&#10;        #endregion&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Coordinates between game events and data storage.&#10;    ///     Responsible only for translating events into data updates and managing save operations.&#10;    /// &lt;/summary&gt;&#10;    public class GameDataCoordinator : MonoBehaviour&#10;    {&#10;        [SerializeField] private float autoSaveInterval = 30;&#10;        private IAutoSaveService _autoSaveService;&#10;        private IEventBus _eventBus;&#10;        private IGameDataService _gameDataService;&#10;        private bool _isInitialized;&#10;&#10;        #region VContainer Injection&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            IGameDataService gameDataService,&#10;            IEventBus eventBus,&#10;            IAutoSaveService autoSaveService)&#10;        {&#10;            _gameDataService = gameDataService;&#10;            _eventBus = eventBus;&#10;            _autoSaveService = autoSaveService;&#10;            _isInitialized = true;&#10;&#10;&#10;            // Initialize after dependencies are injected&#10;            Initialize();&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Initialization&#10;&#10;        private void Initialize()&#10;        {&#10;            // Subscribe to events - only subscribe to events that affect game data&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted); // For best time tracking&#10;            _eventBus?.Subscribe&lt;LevelStartedEvent&gt;(OnLevelStarted); // For current level tracking&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnLivesChanged); // For lives tracking&#10;            _eventBus?.Subscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged); // For game state changes&#10;&#10;            _eventBus?.Subscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;&#10;            // Level Selection Events&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;&#10;            if (_gameDataService != null)&#10;                _gameDataService.OnDataChanged += OnGameDataChanged;&#10;&#10;            if (_autoSaveService != null)&#10;            {&#10;                _autoSaveService.OnSaveRequested += SaveData;&#10;                _autoSaveService.SaveInterval = autoSaveInterval;&#10;                _autoSaveService.IsEnabled = true;&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Private Methods&#10;&#10;        private void SaveData()&#10;        {&#10;            _gameDataService?.SaveData();&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Unity Lifecycle&#10;&#10;        private void Start()&#10;        {&#10;            // If not yet initialized (dependencies not injected), wait&#10;            if (!_isInitialized)&#10;            {&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.Update();&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (!_isInitialized) return;&#10;&#10;            // Unsubscribe from events&#10;            if (_eventBus != null)&#10;            {&#10;                _eventBus.Unsubscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;                _eventBus.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;                _eventBus.Unsubscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;                _eventBus.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnLivesChanged);&#10;                _eventBus.Unsubscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged);&#10;            }&#10;&#10;&#10;            if (_gameDataService != null)&#10;                _gameDataService.OnDataChanged -= OnGameDataChanged;&#10;&#10;            if (_autoSaveService != null)&#10;            {&#10;                _autoSaveService.OnSaveRequested -= SaveData;&#10;                _autoSaveService.ForceSave();&#10;            }&#10;        }&#10;&#10;        private void OnApplicationPause(bool pauseStatus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationPause(pauseStatus);&#10;        }&#10;&#10;        private void OnApplicationFocus(bool hasFocus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationFocus(hasFocus);&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Event Handlers&#10;&#10;        private void OnPlayerDied(PlayerDeathEvent deathEvent)&#10;        {&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateBestTime(levelEvent.CompletionTime);&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnGameStateChanged(GameStateChangedEvent stateEvent)&#10;        {&#10;            // Handle data operations based on state changes&#10;            if (stateEvent.NewState is GameState.Victory or GameState.GameOver)&#10;            {&#10;                _autoSaveService?.ForceSave();&#10;            }&#10;        }&#10;        private void OnLevelStarted(LevelStartedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateCurrentLevel(levelEvent.LevelName);&#10;        }&#10;        private void OnLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            Debug.Log(&#10;                $&quot;[GameDataCoordinator] Received PlayerLivesChangedEvent: CurrentLives={livesEvent.CurrentLives}&quot;);&#10;&#10;            _gameDataService?.UpdateLives(livesEvent.CurrentLives);&#10;            Debug.Log($&quot;[GameDataCoordinator] Updated GameData lives to: {_gameDataService?.CurrentData.lives}&quot;);&#10;        }&#10;&#10;        private void OnGameDataChanged(GameData newData)&#10;        {&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent levelEvent)&#10;        {&#10;            // Update selected level index in game data&#10;            var gameData = _gameDataService?.GetGameData();&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = levelEvent.LevelIndex;&#10;                gameData.currentLevel = levelEvent.LevelName;&#10;            }&#10;            Debug.Log($&quot;[GameDataCoordinator] Level selected: {levelEvent.LevelName}&quot;);&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            // Update selected level index in game data&#10;            var gameData = _gameDataService?.GetGameData();&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = navigationEvent.NewIndex;&#10;            }&#10;            Debug.Log($&quot;[GameDataCoordinator] Level navigation: from {navigationEvent.PreviousIndex} to {navigationEvent.NewIndex}&quot;);&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Public API&#10;&#10;        public GameData GetCurrentData()&#10;        {&#10;            if (!_isInitialized || _gameDataService == null) return null;&#10;&#10;            return _gameDataService.CurrentData;&#10;        }&#10;&#10;        public void ResetAllData()&#10;        {&#10;            if (!_isInitialized) return;&#10;&#10;            _gameDataService?.ResetAllData();&#10;        }&#10;&#10;        #endregion&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/FrogProximityJump.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/FrogProximityJump.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using Player.Components;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Emits an event when the player is within a certain distance&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class FrogProximityTrigger : MonoBehaviour, ITrigger&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float triggerDistance = 3f;&#10;        [SerializeField] private float jumpCooldown = 2f;&#10;        [SerializeField] private int checkEveryNFrames = 1;&#10;&#10;        private int _frameCounter;&#10;        private bool _grounded;&#10;        private float _lastTriggerTime;&#10;        private Transform _player;&#10;&#10;        private void Start()&#10;        {&#10;            _player = PlayerLocator.PlayerTransform;&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public bool IsTriggered { get; private set; }&#10;&#10;        public void CheckTrigger()&#10;        {&#10;            if (++_frameCounter % checkEveryNFrames != 0 || !_player) return;&#10;&#10;            Vector2 toPlayer = _player.position - transform.position;&#10;            float sqrDist = toPlayer.sqrMagnitude;&#10;            float sqrTrigger = triggerDistance * triggerDistance;&#10;&#10;            if (sqrDist &lt; sqrTrigger &amp;&amp; Time.time - _lastTriggerTime &gt; jumpCooldown &amp;&amp; _grounded)&#10;            {&#10;                IsTriggered = true;&#10;                _lastTriggerTime = Time.time;&#10;            }&#10;            else&#10;            {&#10;                IsTriggered = false;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using Player.Components;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Emits an event when the player is within a certain distance&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class FrogProximityTrigger : MonoBehaviour, ITrigger&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float triggerDistance = 3f;&#10;        [SerializeField] private float jumpCooldown = 2f;&#10;        [SerializeField] private int checkEveryNFrames = 1;&#10;&#10;        private int _frameCounter;&#10;        private bool _grounded;&#10;        private float _lastTriggerTime;&#10;        private Transform _player;&#10;&#10;        private void Start()&#10;        {&#10;            _player = PlayerLocator.PlayerTransform;&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public bool IsTriggered { get; private set; }&#10;&#10;        public void CheckTrigger()&#10;        {&#10;            if (++_frameCounter % checkEveryNFrames != 0 || !_player) return;&#10;&#10;            Vector2 toPlayer = _player.position - transform.position;&#10;            float sqrDist = toPlayer.sqrMagnitude;&#10;            float sqrTrigger = triggerDistance * triggerDistance;&#10;&#10;            if (sqrDist &lt; sqrTrigger &amp;&amp; Time.time - _lastTriggerTime &gt; jumpCooldown &amp;&amp; _grounded)&#10;            {&#10;                IsTriggered = true;&#10;                _lastTriggerTime = Time.time;&#10;            }&#10;            else&#10;            {&#10;                IsTriggered = false;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/JumpMover.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/JumpMover.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to make the enemy jump forward&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class JumpCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float jumpForceX = 2f;&#10;        [SerializeField] private float jumpForceY = 5f;&#10;&#10;        private bool _grounded;&#10;        private Rigidbody2D _rb;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (_grounded)&#10;            {&#10;                Vector2 jumpDir = new(transform.localScale.x * jumpForceX, jumpForceY);&#10;                _rb.linearVelocity = jumpDir;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to make the enemy jump forward&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class JumpCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float jumpForceX = 2f;&#10;        [SerializeField] private float jumpForceY = 5f;&#10;&#10;        private bool _grounded;&#10;        private Rigidbody2D _rb;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (_grounded)&#10;            {&#10;                Vector2 jumpDir = new(transform.localScale.x * jumpForceX, jumpForceY);&#10;                _rb.linearVelocity = jumpDir;&#10;            }&#10;        }&#10;&#10;        public void ResetState()&#10;        {&#10;            _grounded = false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/ProjectileShooter.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/ProjectileShooter.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using Weapons.Models;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to shoot a projectile at intervals&#10;    public class ProjectileShootCommand : MonoBehaviour, IAttackCommand&#10;    {&#10;        [SerializeField] private FireballWeapon fireballWeapon;&#10;        [SerializeField] private float fireInterval = 2f;&#10;&#10;        private float _lastFireTime;&#10;&#10;        private void Start()&#10;        {&#10;            fireballWeapon.Equip();&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (!fireballWeapon)&#10;                return;&#10;&#10;            if (Time.time - _lastFireTime &lt; fireInterval)&#10;                return;&#10;&#10;            fireballWeapon.Shoot();&#10;            _lastFireTime = Time.time;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using Weapons.Models;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to shoot a projectile at intervals&#10;    public class ProjectileShootCommand : MonoBehaviour, IAttackCommand&#10;    {&#10;        [SerializeField] private FireballWeapon fireballWeapon;&#10;        [SerializeField] private float fireInterval = 2f;&#10;&#10;        private float _lastFireTime;&#10;&#10;        private void Start()&#10;        {&#10;            fireballWeapon.Equip();&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (!fireballWeapon)&#10;                return;&#10;&#10;            if (Time.time - _lastFireTime &lt; fireInterval)&#10;                return;&#10;&#10;            fireballWeapon.Shoot();&#10;            _lastFireTime = Time.time;&#10;        }&#10;&#10;        public void ResetCooldown()&#10;        {&#10;            _lastFireTime = 0f;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/VerticalMover.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/VerticalMover.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy up and down&#10;    public class VerticalMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float amplitude = 2f;&#10;        [SerializeField] private float frequency = 0.8f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocityY = (y - _rb.position.y) / Time.fixedDeltaTime;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy up and down&#10;    public class VerticalMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float amplitude = 2f;&#10;        [SerializeField] private float frequency = 0.8f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocityY = (y - _rb.position.y) / Time.fixedDeltaTime;&#10;        }&#10;&#10;        public void ResetPosition()&#10;        {&#10;            _rb.position = new Vector2(_rb.position.x, _startY);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/WaveMover.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/WaveMover.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy in a wave pattern&#10;    public class WaveMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float speed = 2f;&#10;        [SerializeField] private float amplitude = 1f;&#10;        [SerializeField] private float frequency = 1.11f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocity = new Vector2(-speed, (y - _rb.position.y) / Time.fixedDeltaTime);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy in a wave pattern&#10;    public class WaveMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float speed = 2f;&#10;        [SerializeField] private float amplitude = 1f;&#10;        [SerializeField] private float frequency = 1.11f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocity = new Vector2(-speed, (y - _rb.position.y) / Time.fixedDeltaTime);&#10;        }&#10;&#10;        public void ResetPosition()&#10;        {&#10;            _rb.position = new Vector2(_rb.position.x, _startY);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/BehaviorOrchestrator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/BehaviorOrchestrator.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyBehaviorController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyBehaviorController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Wires up modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyBehaviorController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (ITriggerBehavior trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;            foreach (IMovementBehavior move in _movementBehaviors) move.Move();&#10;            foreach (IAttackBehavior attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Coordinates modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyBehaviorController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (ITriggerBehavior trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;        }&#10;&#10;        private void FixedUpdate()&#10;        {&#10;            foreach (IMovementBehavior move in _movementBehaviors) move.Move();&#10;        }&#10;&#10;        private void LateUpdate()&#10;        {&#10;            foreach (IAttackBehavior attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyController.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Wires up modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (var trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;            foreach (var move in _movementBehaviors) move.Move();&#10;            foreach (var attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/TriggerManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/TriggerManager.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using System.Linq;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Manages periodic checks for all triggers in the scene&#10;    public class TriggerManager : MonoBehaviour&#10;    {&#10;        private TriggerGroup[] _triggerGroups;&#10;&#10;        private void Awake()&#10;        {&#10;            _triggerGroups = FindObjectsOfType&lt;MonoBehaviour&gt;().OfType&lt;TriggerGroup&gt;().ToArray();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (var group in _triggerGroups)&#10;            {&#10;                group.Update();&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using System.Linq;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Manages periodic checks for all triggers in the scene&#10;    public class TriggerManager : MonoBehaviour&#10;    {&#10;        private TriggerGroup[] _triggerGroups;&#10;&#10;        private void Awake()&#10;        {&#10;            _triggerGroups = FindObjectsOfType&lt;MonoBehaviour&gt;().OfType&lt;TriggerGroup&gt;().ToArray();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/DeathEffectData.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/DeathEffectData.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/DeathEffectFactory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/DeathEffectFactory.cs" />
              <option name="updatedContent" value="using Enemies.DeathEffects.Builder;&#10;        }&#10;&#10;        public IDeathEffectBuilder GetBuilder(DeathEffectType type)&#10;        {&#10;            switch (type)&#10;            {&#10;                case DeathEffectType.Falling:&#10;                    return new FallingDeathEffectBuilder();&#10;                default:&#10;                    UnityEngine.Debug.LogError($&quot;DeathEffectFactory: Unknown death effect type: {type}&quot;);&#10;                    return null;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/DeathEffects.meta">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/DeathEffects.meta" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/FallingDeathEffect.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/FallingDeathEffect.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/FallingDeathEffectBuilder.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/FallingDeathEffectBuilder.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;                return null;&#10;            }&#10;&#10;            if (_camera == null)&#10;            {&#10;                _camera = Camera.main;&#10;            }&#10;&#10;            // Create new GameObject&#10;            GameObject effectObject = new GameObject(&quot;DeathEffect&quot;);&#10;            effectObject.transform.position = _position;&#10;&#10;            // Add and configure the death effect component&#10;            FallingDeathEffect deathEffect = effectObject.AddComponent&lt;FallingDeathEffect&gt;();&#10;            deathEffect.Initialize(_sprite, _velocity, _rotationSpeed, _gravityScale, _destroyDelay, _camera);&#10;&#10;            return deathEffect;&#10;        }&#10;&#10;        public void Reset()&#10;        {&#10;            _position = Vector3.zero;&#10;            _velocity = new Vector3(2f, 5f, 0f);&#10;            _sprite = null;&#10;            _rotationSpeed = 180f;&#10;            _gravityScale = 1f;&#10;            _destroyDelay = 5f;&#10;            _camera = null;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/IDeathEffect.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/IDeathEffect.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/IDeathEffectBuilder.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/IDeathEffectBuilder.cs" />
              <option name="updatedContent" value="using Enemies.DeathEffects.Data;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/IDeathEffectFactory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/DeathEffects/IDeathEffectFactory.cs" />
              <option name="updatedContent" value="using Enemies.DeathEffects.Builder;&#10;using Enemies.DeathEffects.Interfaces;&#10;&#10;namespace Enemies.DeathEffects.Factory&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Factory interface for creating different types of death effects&#10;    /// &lt;/summary&gt;&#10;    public interface IDeathEffectFactory&#10;    {&#10;        IDeathEffect CreateDeathEffect(DeathEffectType type);&#10;        IDeathEffectBuilder GetBuilder(DeathEffectType type);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Enum defining the types of death effects available&#10;    /// &lt;/summary&gt;&#10;    public enum DeathEffectType&#10;    {&#10;        Falling,&#10;        // Future types can be added here like Exploding, Dissolving, etc.&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IAttackBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IAttackBehavior.cs" />
              <option name="originalContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IAttackBehavior&#10;    {&#10;        void Attack();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IAttackBehavior&#10;    {&#10;        void Attack();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IMovementBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IMovementBehavior.cs" />
              <option name="originalContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IMovementBehavior&#10;    {&#10;        void Move();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IMovementBehavior&#10;    {&#10;        void Move();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/ITriggerBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/ITriggerBehavior.cs" />
              <option name="originalContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface ITrigger&#10;    {&#10;        bool IsTriggered { get; }&#10;    }&#10;&#10;    public interface ITriggerBehavior&#10;    {&#10;        void CheckTrigger();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface ITrigger&#10;    {&#10;        bool IsTriggered { get; }&#10;        void CheckTrigger();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/Behaviors/EnemyBehaviors.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/Behaviors/EnemyBehaviors.cs" />
              <option name="updatedContent" value="namespace Enemy.Behaviors&#10;{&#10;    // Optional movement behavior&#10;    public interface IMovable&#10;    {&#10;        void Move();&#10;    }&#10;&#10;    // Optional player proximity reaction&#10;    public interface IPlayerProximityReactable&#10;    {&#10;        void OnPlayerNearby();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/BirdEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/BirdEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Bird: Moves left, goes up and down&#10;    public class BirdEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private float moveSpeed = 2f;&#10;        [SerializeField] private float verticalAmplitude = 1f;&#10;        [SerializeField] private float verticalFrequency = 1f;&#10;        private Vector3 _startPos;&#10;        private float _time;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _startPos = transform.position;&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            _time += Time.deltaTime;&#10;            float yOffset = Mathf.Sin(_time * verticalFrequency) * verticalAmplitude;&#10;            transform.position = _startPos + new Vector3(-moveSpeed * _time, yOffset, 0);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBase.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public abstract class EnemyBase : MonoBehaviour&#10;    {&#10;        protected Rigidbody2D rb;&#10;        protected Collider2D col;&#10;        protected virtual void Awake()&#10;        {&#10;            rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            col = GetComponent&lt;Collider2D&gt;();&#10;        }&#10;&#10;        public virtual void Move() { }&#10;        public virtual void Attack() { }&#10;        public virtual void OnPlayerNearby() { }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBuilder.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBuilder.cs" />
              <option name="originalContent" value="using Enemy.Behaviors;&#10;using Weapons.Models;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyBuilder&#10;    {&#10;        private readonly EnemyBase _enemy;&#10;&#10;        public EnemyBuilder(EnemyBase enemy)&#10;        {&#10;            _enemy = enemy;&#10;        }&#10;&#10;        public EnemyBuilder WithFireSnakeBehavior()&#10;        {&#10;            // Example: assign FireballWeapon if available&#10;            var fireSnake = _enemy as FireSnakeEnemy;&#10;            if (fireSnake)&#10;            {&#10;                FireballWeapon weapon = fireSnake.GetComponentInChildren&lt;FireballWeapon&gt;();&#10;                if (weapon)&#10;                {&#10;                    weapon.Equip();&#10;                    // Additional setup if needed&#10;                }&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSpiderBehavior()&#10;        {&#10;            // Assign movement or proximity logic as needed&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithBirdBehavior()&#10;        {&#10;            // Assign movement logic as needed&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSnakeBehavior()&#10;        {&#10;            // Assign jump logic as needed&#10;            var snake = _enemy as SnakeEnemy;&#10;            if (snake)&#10;            {&#10;                // Example: assign a jump movement component or set jump parameters&#10;                // (Assume SnakeEnemy implements IMovable and has a Jump method)&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithFrogBehavior()&#10;        {&#10;            // Assign jump and proximity logic as needed&#10;            var frog = _enemy as FrogEnemy;&#10;            if (frog)&#10;            {&#10;                // Example: assign a jump movement component or set jump parameters&#10;                // (Assume FrogEnemy implements IMovable and IPlayerProximityReactable)&#10;            }&#10;            return this;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemy.Behaviors;&#10;using Weapons.Models;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyBuilder&#10;    {&#10;        private readonly EnemyBase _enemy;&#10;&#10;        public EnemyBuilder(EnemyBase enemy)&#10;        {&#10;            _enemy = enemy;&#10;        }&#10;&#10;        public EnemyBuilder WithFireSnakeBehavior()&#10;        {&#10;            // Example: assign FireballWeapon if available&#10;            var fireSnake = _enemy as FireSnakeEnemy;&#10;            if (fireSnake)&#10;            {&#10;                FireballWeapon weapon = fireSnake.GetComponentInChildren&lt;FireballWeapon&gt;();&#10;                if (weapon)&#10;                {&#10;                    weapon.Equip();&#10;                    // Additional setup if needed&#10;                }&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSpiderBehavior()&#10;        {&#10;            // Spider: Can move up/down or stay static in air&#10;            var spider = _enemy as SpiderEnemy;&#10;            if (spider)&#10;            {&#10;                // No extra setup needed; movement handled in SpiderEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithBirdBehavior()&#10;        {&#10;            // Bird: Moves left, goes up and down&#10;            var bird = _enemy as BirdEnemy;&#10;            if (bird)&#10;            {&#10;                // No extra setup needed; movement handled in BirdEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSnakeBehavior()&#10;        {&#10;            // Snake: Jumps forward&#10;            var snake = _enemy as SnakeEnemy;&#10;            if (snake)&#10;            {&#10;                // No extra setup needed; jump logic handled in SnakeEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithFrogBehavior()&#10;        {&#10;            // Frog: Jumps higher/farther, jumps when player is near&#10;            var frog = _enemy as FrogEnemy;&#10;            if (frog)&#10;            {&#10;                // No extra setup needed; jump and proximity handled in FrogEnemy&#10;            }&#10;            return this;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDirector.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDirector.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public static class EnemyDirector&#10;    {&#10;        // Entry point for configuring an enemy in the scene&#10;        public static void ConstructEnemy(EnemyType type, EnemyBase enemy)&#10;        {&#10;            // The director delegates the construction to the factory&#10;            EnemyFactory.ConfigureEnemy(type, enemy);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyFactory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyFactory.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public enum EnemyType&#10;    {&#10;        FireSnake,&#10;        Spider,&#10;        Bird,&#10;        Snake,&#10;        Frog&#10;    }&#10;&#10;    public static class EnemyFactory&#10;    {&#10;        // Configures an existing enemy instance using the builder pattern&#10;        public static void ConfigureEnemy(EnemyType type, EnemyBase enemy)&#10;        {&#10;            if (enemy == null) throw new ArgumentNullException(nameof(enemy));&#10;            var builder = new EnemyBuilder(enemy);&#10;            switch (type)&#10;            {&#10;                case EnemyType.FireSnake:&#10;                    builder.WithFireSnakeBehavior();&#10;                    break;&#10;                case EnemyType.Spider:&#10;                    builder.WithSpiderBehavior();&#10;                    break;&#10;                case EnemyType.Bird:&#10;                    builder.WithBirdBehavior();&#10;                    break;&#10;                case EnemyType.Snake:&#10;                    builder.WithSnakeBehavior();&#10;                    break;&#10;                case EnemyType.Frog:&#10;                    builder.WithFrogBehavior();&#10;                    break;&#10;                default:&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/FireSnakeEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/FireSnakeEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Weapons.Models;&#10;&#10;namespace Enemy&#10;{&#10;    public class FireSnakeEnemy : EnemyBase&#10;    {&#10;        [SerializeField] private FireballWeapon fireballWeapon;&#10;        [SerializeField] private float attackCooldown = 2f;&#10;        private float _nextAttackTime;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            if (fireballWeapon != null)&#10;                fireballWeapon.Equip();&#10;        }&#10;&#10;        public override void Attack()&#10;        {&#10;            if (fireballWeapon == null)&#10;                return;&#10;            if (Time.time &lt; _nextAttackTime)&#10;                return;&#10;            fireballWeapon.Shoot();&#10;            _nextAttackTime = Time.time + attackCooldown;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/FrogEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/FrogEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Frog: Jumps higher and farther, jumps when player is near&#10;    public class FrogEnemy : EnemyBase, IMovable, IPlayerProximityReactable&#10;    {&#10;        [SerializeField] private float jumpForce = 12f;&#10;        [SerializeField] private float jumpDistance = 6f;&#10;        [SerializeField] private float jumpCooldown = 2f;&#10;        private float _nextJumpTime;&#10;        private Rigidbody2D _rb;&#10;        private bool _playerNearby;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (_playerNearby &amp;&amp; Time.time &gt;= _nextJumpTime)&#10;            {&#10;                Vector2 jumpVector = new Vector2(jumpDistance, jumpForce);&#10;                _rb.AddForce(jumpVector, ForceMode2D.Impulse);&#10;                _nextJumpTime = Time.time + jumpCooldown;&#10;                _playerNearby = false; // Only jump once per proximity event&#10;            }&#10;        }&#10;&#10;        public void OnPlayerNearby()&#10;        {&#10;            _playerNearby = true;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/EnemyBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/EnemyBase.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/FireSnake.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/FireSnake.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/SnakeEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/SnakeEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Snake: Jumps forward&#10;    public class SnakeEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private float jumpForce = 7f;&#10;        [SerializeField] private float jumpInterval = 2f;&#10;        private float _nextJumpTime;&#10;        private Rigidbody2D _rb;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (Time.time &gt;= _nextJumpTime)&#10;            {&#10;                _rb.AddForce(Vector2.right * jumpForce, ForceMode2D.Impulse);&#10;                _nextJumpTime = Time.time + jumpInterval;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/SpiderEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/SpiderEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Spider: Can move up/down or stay static in air&#10;    public class SpiderEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private bool canMove = true;&#10;        [SerializeField] private float moveSpeed = 2f;&#10;        [SerializeField] private float moveDistance = 3f;&#10;        private Vector3 _startPos;&#10;        private bool _movingUp = true;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _startPos = transform.position;&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (!canMove) return;&#10;            float delta = moveSpeed * Time.deltaTime * (_movingUp ? 1 : -1);&#10;            transform.position += new Vector3(0, delta, 0);&#10;            if (Mathf.Abs(transform.position.y - _startPos.y) &gt; moveDistance)&#10;                _movingUp = !_movingUp;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Health.Interfaces;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class AlwaysAllowDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        public bool CanBeDamagedBy(GameObject damager) =&gt; true;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All layers by default&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target))&#10;                return;&#10;&#10;            int amount = _dealer?.GetDamageAmount() ?? 1;&#10;            damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using System.Linq;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class BidirectionalDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject other = collision.gameObject;&#10;            GameObject self = gameObject;&#10;&#10;            // 1. This object damages the other&#10;            TryDealDamage(self, other, _dealer, _damageConditions, targetLayers);&#10;&#10;            // 2. The other object damages this&#10;            var otherDealer = other.GetComponent&lt;IDamageDealer&gt;();&#10;            var otherConditions = other.GetComponent&lt;DamageConditionsComponent&gt;();&#10;            TryDealDamage(other, self, otherDealer, otherConditions, targetLayers);&#10;        }&#10;&#10;        private static void TryDealDamage(&#10;            GameObject dealerObj,&#10;            GameObject targetObj,&#10;            IDamageDealer dealer,&#10;            DamageConditionsComponent conditions,&#10;            LayerMask targetLayers)&#10;        {&#10;            if (dealer == null) return;&#10;            if (((1 &lt;&lt; targetObj.layer) &amp; targetLayers) == 0) return;&#10;            var damageable = targetObj.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (conditions &amp;&amp; !conditions.CanBeDamagedBy(targetObj)) return;&#10;            int amount = dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, dealerObj);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;// This script is now deprecated in favor of TakeDamageOnCollision for most use cases.&#10;// Please use TakeDamageOnCollision on all damageable objects instead." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            foreach (IDamageCondition cond in _conditions)&#10;            {&#10;                if (cond != null &amp;&amp; !cond.CanBeDamagedBy(damager))&#10;                    return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            return _conditions.All(cond =&gt; cond == null || cond.CanBeDamagedBy(damager));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs" />
              <option name="originalContent" value="using Health.Damage;&#10;using UnityEditor;&#10;using UnityEngine;&#10;&#10;[CustomPropertyDrawer(typeof(ConditionLeaf))]&#10;public class ConditionLeafPropertyDrawer : ConditionNodePropertyDrawer {}&#10;&#10;[CustomPropertyDrawer(typeof(AndCondition))]&#10;public class AndConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;AND Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(OrCondition))]&#10;public class OrConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;OR Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(NotCondition))]&#10;public class NotConditionPropertyDrawer : ConditionNodePropertyDrawer {}&#10;" />
              <option name="updatedContent" value="// All custom property drawers for node types are now handled by ConditionNodePropertyDrawer.&#10;// This file is no longer needed and can be deleted, or you can leave it empty." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/README.md" />
              <option name="updatedContent" value="// Health/README.md&#10;&#10;# Health System Setup Guide&#10;&#10;## Folder Structure&#10;- `Core/`  Health logic&#10;- `Interfaces/`  All interfaces&#10;- `Shield/`  Shield logic&#10;- `Invincibility/`  Invincibility logic&#10;- `Damage/`  Damage logic and conditions&#10;&#10;## How to Compose Entities in Unity Editor&#10;&#10;### Player (Basic)&#10;- Add `HealthComponent` (Core)&#10;&#10;### Player with Shield&#10;- Add `HealthComponent` (Core)&#10;- Add `ShieldComponent` (Shield)&#10;&#10;### Player with Invincibility&#10;- Add `HealthComponent` (Core)&#10;- Add `InvincibilityComponent` (Invincibility)&#10;- Connect to your `IPowerUp` system to toggle invincibility&#10;&#10;### Enemy&#10;- Add `HealthComponent` (Core)&#10;&#10;### Hazard (Standard)&#10;- Add `HazardComponent` (Damage)&#10;- Add `DamageDealerComponent` (Damage)&#10;- Add a damage condition (e.g., `AlwaysAllowDamage`, `OnlyInvincibleCanDamage`, `OnlyShieldedCanDamage`) as needed&#10;- Assign the condition(s) to the `HazardComponent`'s `damageConditions` array in the Inspector&#10;&#10;### Custom Damage Conditions&#10;- Create a new MonoBehaviour implementing `IDamageCondition`&#10;- Add it to the hazard GameObject&#10;- Assign it in the `HazardComponent`&#10;&#10;## Extending&#10;- To add new damage conditions, create a new script implementing `IDamageCondition` and add it in the Editor. No need to modify existing code.&#10;&#10;## Events&#10;- Use UnityEvents or C# events on components for custom reactions (e.g., OnDeath, OnShieldBroken)&#10;&#10;## Cleanup&#10;- Remove old scripts like `ShieldActiveDisappearHazard`, `OnlyInvincibilityDamageController`, etc. after migration.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/DI/LevelSelectionLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/DI/LevelSelectionLifetimeScope.cs" />
              <option name="originalContent" value="using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace LevelSelection.DI&#10;{&#10;    public class LevelSelectionLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Configuring level selection DI container...&quot;);&#10;&#10;            // Register core services that level selection depends on&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;&#10;            // Register the new service-based architecture&#10;            builder.Register&lt;ILevelDiscoveryService, LevelDiscoveryService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ILevelNavigationService, LevelNavigationService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ILevelDisplayService, LevelDisplayService&gt;(Lifetime.Singleton);&#10;&#10;            // Register the main controller&#10;            builder.RegisterComponentInHierarchy&lt;LevelSelectionController&gt;();&#10;&#10;            // Register supporting components that are still used&#10;            builder.RegisterComponentInHierarchy&lt;ItemSelectScreen&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;NESCrossfade&gt;();&#10;            &#10;            // Register the scene transition manager&#10;            builder.RegisterComponentInHierarchy&lt;SceneTransitionManager&gt;();&#10;&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Level selection DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace LevelSelection.DI&#10;{&#10;    public class LevelSelectionLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Configuring level selection DI container...&quot;);&#10;&#10;            // Register core services that level selection depends on&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;&#10;            // Register the new service-based architecture&#10;            builder.Register&lt;ILevelDiscoveryService, LevelDiscoveryService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ILevelNavigationService, LevelNavigationService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ILevelDisplayService, LevelDisplayService&gt;(Lifetime.Singleton);&#10;&#10;            // Register the main controller&#10;            builder.RegisterComponentInHierarchy&lt;LevelSelectionController&gt;();&#10;&#10;            // Register supporting components that are still used&#10;            builder.RegisterComponentInHierarchy&lt;ItemSelectScreen&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;NESCrossfade&gt;();&#10;            &#10;            // Register the scene transition manager&#10;            builder.RegisterComponentInHierarchy&lt;SceneTransitionManager&gt;();&#10;&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Level selection DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/EndLevelZone.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/EndLevelZone.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using System.Collections.Generic;&#10;using Core.Data;&#10;using Core.Events;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Trigger zone that detects when the player completes a level&#10;    ///     and unlocks the next level in sequence&#10;    /// &lt;/summary&gt;&#10;    [RequireComponent(typeof(Collider2D))]&#10;    public class EndLevelZone : MonoBehaviour&#10;    {&#10;        [Header(&quot;Level Completion Settings&quot;)] [SerializeField]&#10;        private string currentLevelName;&#10;&#10;        [SerializeField] private string nextLevelName;&#10;        [SerializeField] private bool autoReturnToLevelSelect = true;&#10;        [SerializeField] private float completionDelay = 2f;&#10;&#10;        [Header(&quot;Audio Feedback&quot;)] [SerializeField]&#10;        private AudioClip completionSound;&#10;&#10;        [Header(&quot;UI Feedback&quot;)] [SerializeField]&#10;        private GameObject completionUI;&#10;&#10;        [SerializeField] private float uiDisplayDuration = 3f;&#10;        private AudioSource _audioSource;&#10;&#10;        private IEventBus _eventBus;&#10;        private IGameDataService _gameDataService;&#10;        private bool _hasTriggered;&#10;&#10;        private void Awake()&#10;        {&#10;            // Setup audio component&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (_audioSource == null)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;&#10;            // Ensure trigger is set up correctly&#10;            Collider2D col = GetComponent&lt;Collider2D&gt;();&#10;            col.isTrigger = true;&#10;&#10;            // Hide completion UI initially&#10;            if (completionUI != null)&#10;            {&#10;                completionUI.SetActive(false);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter2D(Collider2D other)&#10;        {&#10;            // Check if player entered&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !_hasTriggered)&#10;            {&#10;                StartCoroutine(CompleteLevel());&#10;            }&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, IGameDataService gameDataService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataService = gameDataService;&#10;        }&#10;&#10;        private IEnumerator CompleteLevel()&#10;        {&#10;            _hasTriggered = true;&#10;&#10;            Debug.Log($&quot;[EndLevelZone] Player completed level: {currentLevelName}&quot;);&#10;&#10;            // Play completion sound&#10;            if (completionSound != null &amp;&amp; _audioSource != null)&#10;            {&#10;                _audioSource.PlayOneShot(completionSound);&#10;            }&#10;&#10;            // Show completion UI&#10;            if (completionUI != null)&#10;            {&#10;                completionUI.SetActive(true);&#10;                yield return new WaitForSeconds(uiDisplayDuration);&#10;                completionUI.SetActive(false);&#10;            }&#10;&#10;            // Wait for completion delay&#10;            yield return new WaitForSeconds(completionDelay);&#10;&#10;            // Calculate completion time (should be tracked by GameFlowManager, but we'll use a simple calculation here)&#10;            float completionTime = Time.time; // This should be the actual level completion time&#10;&#10;            // Update game data with completion stats&#10;            UpdateCompletionStats(completionTime);&#10;&#10;            // Unlock next level and save progress&#10;            UnlockNextLevel();&#10;&#10;            // Publish level completion event (for GameFlowManager)&#10;            _eventBus?.Publish(new Core.Events.LevelCompletedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime&#10;            });&#10;&#10;            // Publish level unlocked event (for level selection system)&#10;            if (!string.IsNullOrEmpty(nextLevelName))&#10;            {&#10;                _eventBus?.Publish(new Core.Events.LevelUnlockedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    CompletedLevelName = currentLevelName,&#10;                    UnlockedLevelName = nextLevelName&#10;                });&#10;            }&#10;&#10;            // Return to level select if enabled&#10;            if (autoReturnToLevelSelect)&#10;            {&#10;                // Use SceneTransitionManager if available, otherwise use event system&#10;                if (SceneTransitionManager.Instance != null)&#10;                {&#10;                    SceneTransitionManager.Instance.TransitionToScene(&quot;LevelSelection&quot;);&#10;                }&#10;                else&#10;                {&#10;                    _eventBus?.Publish(new Core.Events.LevelLoadRequestedEvent&#10;                    {&#10;                        Timestamp = Time.time,&#10;                        LevelName = &quot;Level Select&quot;,&#10;                        SceneName = &quot;LevelSelection&quot;&#10;                    });&#10;                }&#10;            }&#10;        }&#10;&#10;        private void UpdateCompletionStats(float completionTime)&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update best time for this level&#10;            gameData.UpdateLevelBestTime(currentLevelName, completionTime);&#10;&#10;            // Update best score for this level (assuming score is tracked elsewhere)&#10;            gameData.UpdateLevelBestScore(currentLevelName, gameData.score);&#10;&#10;            // Update overall max score&#10;            gameData.UpdateMaxScore(gameData.score);&#10;&#10;            Debug.Log(&#10;                $&quot;[EndLevelZone] Updated stats - Time: {completionTime:F2}s, Score: {gameData.score}, Best Time: {gameData.GetLevelBestTime(currentLevelName):F2}s&quot;);&#10;        }&#10;&#10;        private void UnlockNextLevel()&#10;        {&#10;            if (string.IsNullOrEmpty(nextLevelName))&#10;            {&#10;                Debug.Log(&quot;[EndLevelZone] No next level specified to unlock&quot;);&#10;                return;&#10;            }&#10;&#10;            // Get current game data&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData == null)&#10;            {&#10;                Debug.LogWarning(&quot;[EndLevelZone] No game data service available&quot;);&#10;                return;&#10;            }&#10;&#10;            // Initialize unlocked levels list if needed&#10;            if (gameData.unlockedLevels == null)&#10;            {&#10;                gameData.unlockedLevels = new List&lt;string&gt;();&#10;            }&#10;&#10;            // Add next level to unlocked list if not already unlocked&#10;            if (!gameData.unlockedLevels.Contains(nextLevelName))&#10;            {&#10;                gameData.unlockedLevels.Add(nextLevelName);&#10;                Debug.Log($&quot;[EndLevelZone] Unlocked next level: {nextLevelName}&quot;);&#10;            }&#10;&#10;            // Mark current level as completed&#10;            if (gameData.completedLevels == null)&#10;            {&#10;                gameData.completedLevels = new List&lt;string&gt;();&#10;            }&#10;&#10;            if (!gameData.completedLevels.Contains(currentLevelName))&#10;            {&#10;                gameData.completedLevels.Add(currentLevelName);&#10;                Debug.Log($&quot;[EndLevelZone] Marked level as completed: {currentLevelName}&quot;);&#10;            }&#10;&#10;            // Save the data&#10;            _gameDataService?.SaveData();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Manually trigger level completion (for testing or external calls)&#10;        /// &lt;/summary&gt;&#10;        public void TriggerCompletion()&#10;        {&#10;            if (!_hasTriggered)&#10;            {&#10;                StartCoroutine(CompleteLevel());&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Reset the trigger so it can be activated again&#10;        /// &lt;/summary&gt;&#10;        public void ResetTrigger()&#10;        {&#10;            _hasTriggered = false;&#10;        }&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using System.Collections.Generic;&#10;using Core.Data;&#10;using Core.Events;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Trigger zone that detects when the player completes a level&#10;    ///     and unlocks the next level in sequence&#10;    /// &lt;/summary&gt;&#10;    [RequireComponent(typeof(Collider2D))]&#10;    public class EndLevelZone : MonoBehaviour&#10;    {&#10;        [Header(&quot;Level Completion Settings&quot;)] [SerializeField]&#10;        private string currentLevelName;&#10;&#10;        [SerializeField] private string nextLevelName;&#10;        [SerializeField] private bool autoReturnToLevelSelect = true;&#10;        [SerializeField] private float completionDelay = 2f;&#10;&#10;        [Header(&quot;Audio Feedback&quot;)] [SerializeField]&#10;        private AudioClip completionSound;&#10;&#10;        [Header(&quot;UI Feedback&quot;)] [SerializeField]&#10;        private GameObject completionUI;&#10;&#10;        [SerializeField] private float uiDisplayDuration = 3f;&#10;        private AudioSource _audioSource;&#10;&#10;        private IEventBus _eventBus;&#10;        private IGameDataService _gameDataService;&#10;        private bool _hasTriggered;&#10;&#10;        private void Awake()&#10;        {&#10;            // Setup audio component&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (_audioSource == null)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;&#10;            // Ensure trigger is set up correctly&#10;            Collider2D col = GetComponent&lt;Collider2D&gt;();&#10;            col.isTrigger = true;&#10;&#10;            // Hide completion UI initially&#10;            if (completionUI != null)&#10;            {&#10;                completionUI.SetActive(false);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter2D(Collider2D other)&#10;        {&#10;            // Check if player entered&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !_hasTriggered)&#10;            {&#10;                StartCoroutine(CompleteLevel());&#10;            }&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, IGameDataService gameDataService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataService = gameDataService;&#10;        }&#10;&#10;        private IEnumerator CompleteLevel()&#10;        {&#10;            _hasTriggered = true;&#10;&#10;            Debug.Log($&quot;[EndLevelZone] Player completed level: {currentLevelName}&quot;);&#10;&#10;            // Play completion sound&#10;            if (completionSound != null &amp;&amp; _audioSource != null)&#10;            {&#10;                _audioSource.PlayOneShot(completionSound);&#10;            }&#10;&#10;            // Show completion UI&#10;            if (completionUI != null)&#10;            {&#10;                completionUI.SetActive(true);&#10;                yield return new WaitForSeconds(uiDisplayDuration);&#10;                completionUI.SetActive(false);&#10;            }&#10;&#10;            // Wait for completion delay&#10;            yield return new WaitForSeconds(completionDelay);&#10;&#10;            // Calculate completion time (should be tracked by GameFlowManager, but we'll use a simple calculation here)&#10;            float completionTime = Time.time; // This should be the actual level completion time&#10;&#10;            // Update game data with completion stats&#10;            UpdateCompletionStats(completionTime);&#10;&#10;            // Unlock next level and save progress&#10;            UnlockNextLevel();&#10;&#10;            // Publish level completion event (for GameFlowManager)&#10;            _eventBus?.Publish(new Core.Events.LevelCompletedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime&#10;            });&#10;&#10;            // Publish level unlocked event (for level selection system)&#10;            if (!string.IsNullOrEmpty(nextLevelName))&#10;            {&#10;                _eventBus?.Publish(new Core.Events.LevelUnlockedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    CompletedLevelName = currentLevelName,&#10;                    UnlockedLevelName = nextLevelName&#10;                });&#10;            }&#10;&#10;            // Return to level select if enabled&#10;            if (autoReturnToLevelSelect)&#10;            {&#10;                // Use standalone SceneTransitionManager&#10;                SceneTransitionManager.TransitionTo(&quot;LevelSelection&quot;);&#10;            }&#10;        }&#10;&#10;        private void UpdateCompletionStats(float completionTime)&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update best time for this level&#10;            gameData.UpdateLevelBestTime(currentLevelName, completionTime);&#10;&#10;            // Update best score for this level (assuming score is tracked elsewhere)&#10;            gameData.UpdateLevelBestScore(currentLevelName, gameData.score);&#10;&#10;            // Update overall max score&#10;            gameData.UpdateMaxScore(gameData.score);&#10;&#10;            Debug.Log(&#10;                $&quot;[EndLevelZone] Updated stats - Time: {completionTime:F2}s, Score: {gameData.score}, Best Time: {gameData.GetLevelBestTime(currentLevelName):F2}s&quot;);&#10;        }&#10;&#10;        private void UnlockNextLevel()&#10;        {&#10;            if (string.IsNullOrEmpty(nextLevelName))&#10;            {&#10;                Debug.Log(&quot;[EndLevelZone] No next level specified to unlock&quot;);&#10;                return;&#10;            }&#10;&#10;            // Get current game data&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData == null)&#10;            {&#10;                Debug.LogWarning(&quot;[EndLevelZone] No game data service available&quot;);&#10;                return;&#10;            }&#10;&#10;            // Initialize unlocked levels list if needed&#10;            if (gameData.unlockedLevels == null)&#10;            {&#10;                gameData.unlockedLevels = new List&lt;string&gt;();&#10;            }&#10;&#10;            // Add next level to unlocked list if not already unlocked&#10;            if (!gameData.unlockedLevels.Contains(nextLevelName))&#10;            {&#10;                gameData.unlockedLevels.Add(nextLevelName);&#10;                Debug.Log($&quot;[EndLevelZone] Unlocked next level: {nextLevelName}&quot;);&#10;            }&#10;&#10;            // Mark current level as completed&#10;            if (gameData.completedLevels == null)&#10;            {&#10;                gameData.completedLevels = new List&lt;string&gt;();&#10;            }&#10;&#10;            if (!gameData.completedLevels.Contains(currentLevelName))&#10;            {&#10;                gameData.completedLevels.Add(currentLevelName);&#10;                Debug.Log($&quot;[EndLevelZone] Marked level as completed: {currentLevelName}&quot;);&#10;            }&#10;&#10;            // Save the data&#10;            _gameDataService?.SaveData();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Manually trigger level completion (for testing or external calls)&#10;        /// &lt;/summary&gt;&#10;        public void TriggerCompletion()&#10;        {&#10;            if (!_hasTriggered)&#10;            {&#10;                StartCoroutine(CompleteLevel());&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Reset the trigger so it can be activated again&#10;        /// &lt;/summary&gt;&#10;        public void ResetTrigger()&#10;        {&#10;            _hasTriggered = false;&#10;        }&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/ItemSelectScreen.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/ItemSelectScreen.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections;&#10;using Core.Events;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.UI;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class ItemSelectScreen : MonoBehaviour&#10;    {&#10;        [Header(&quot;UI References&quot;)] public Image itemSelectImage;&#10;&#10;        [SerializeField] private Sprite itemSelectSprite;&#10;&#10;        [Header(&quot;Display Settings&quot;)] public float displayDuration = 2f;&#10;&#10;        public bool waitForInput = true;&#10;&#10;        [Header(&quot;Audio&quot;)] public AudioClip confirmSound;&#10;&#10;        [Header(&quot;Input Actions&quot;)] [SerializeField]&#10;        private InputActionReference submitAction;&#10;&#10;        private AudioSource _audioSource;&#10;        private LevelSelectionConfig _config;&#10;        private IEventBus _eventBus;&#10;        private Action _onComplete;&#10;        private string _pendingLevelName;&#10;        private string _pendingSceneName;&#10;&#10;        private bool IsWaitingForInput { get; set; }&#10;&#10;        private void Awake()&#10;        {&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (!_audioSource)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;&#10;            // Setup the item select sprite if available&#10;            if (itemSelectSprite &amp;&amp; itemSelectImage)&#10;            {&#10;                itemSelectImage.sprite = itemSelectSprite;&#10;            }&#10;&#10;            // Ensure the image is disabled at start&#10;            if (itemSelectImage != null)&#10;            {&#10;                itemSelectImage.gameObject.SetActive(false);&#10;            }&#10;&#10;            // Start hidden&#10;            gameObject.SetActive(false);&#10;            &#10;            Debug.Log(&quot;[ItemSelectScreen] Initialized and hidden&quot;);&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (submitAction)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnConfirmInput;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (submitAction)&#10;            {&#10;                submitAction.action.performed -= OnConfirmInput;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        public void SetConfig(LevelSelectionConfig config)&#10;        {&#10;            _config = config;&#10;&#10;            // Update display duration and wait behavior from config&#10;            if (_config != null)&#10;            {&#10;                displayDuration = _config.itemSelectDisplayDuration;&#10;                waitForInput = _config.waitForInputOnItemSelect;&#10;&#10;                // Update audio clip from config if available&#10;                if (_config.selectionSound &amp;&amp; !confirmSound)&#10;                {&#10;                    confirmSound = _config.selectionSound;&#10;                }&#10;            }&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus)&#10;        {&#10;            _eventBus = eventBus;&#10;        }&#10;&#10;        public void ShowItemSelect(string levelName, string sceneName, Action onComplete = null)&#10;        {&#10;            _pendingLevelName = levelName;&#10;            _pendingSceneName = sceneName;&#10;            _onComplete = onComplete;&#10;&#10;            // Enable the main GameObject&#10;            gameObject.SetActive(true);&#10;            &#10;            // Enable the item select image&#10;            if (itemSelectImage != null)&#10;            {&#10;                itemSelectImage.gameObject.SetActive(true);&#10;            }&#10;            &#10;            Debug.Log($&quot;[ItemSelectScreen] Showing item select for level: {levelName}&quot;);&#10;&#10;            if (waitForInput)&#10;            {&#10;                IsWaitingForInput = true;&#10;            }&#10;            else&#10;            {&#10;                StartCoroutine(AutoProgressAfterDelay());&#10;            }&#10;        }&#10;&#10;        private IEnumerator AutoProgressAfterDelay()&#10;        {&#10;            yield return new WaitForSeconds(displayDuration);&#10;            ConfirmAndProceed();&#10;        }&#10;&#10;        private void OnConfirmInput(InputAction.CallbackContext context)&#10;        {&#10;            if (IsWaitingForInput)&#10;            {&#10;                ConfirmAndProceed();&#10;            }&#10;        }&#10;&#10;        private void ConfirmAndProceed()&#10;        {&#10;            // Use config sound first, then fallback to assigned sound&#10;            AudioClip soundToPlay = _config?.selectionSound ?? confirmSound;&#10;&#10;            if (_audioSource &amp;&amp; soundToPlay)&#10;            {&#10;                _audioSource.PlayOneShot(soundToPlay);&#10;            }&#10;&#10;            IsWaitingForInput = false;&#10;            gameObject.SetActive(false);&#10;&#10;            // Publish level load request event&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = _pendingLevelName,&#10;                SceneName = _pendingSceneName&#10;            });&#10;&#10;            _onComplete?.Invoke();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections;&#10;using Core.Events;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.UI;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class ItemSelectScreen : MonoBehaviour&#10;    {&#10;        [Header(&quot;UI References&quot;)] public Image itemSelectImage;&#10;&#10;        [SerializeField] private Sprite itemSelectSprite;&#10;&#10;        [Header(&quot;Display Settings&quot;)] public float displayDuration = 2f;&#10;&#10;        public bool waitForInput = true;&#10;&#10;        [Header(&quot;Audio&quot;)] public AudioClip confirmSound;&#10;&#10;        [Header(&quot;Input Actions&quot;)] [SerializeField]&#10;        private InputActionReference submitAction;&#10;&#10;        private AudioSource _audioSource;&#10;        private LevelSelectionConfig _config;&#10;        private IEventBus _eventBus;&#10;        private Action _onComplete;&#10;        private string _pendingLevelName;&#10;        private string _pendingSceneName;&#10;&#10;        private bool IsWaitingForInput { get; set; }&#10;&#10;        private void Awake()&#10;        {&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (!_audioSource)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;&#10;            // Setup the item select sprite if available&#10;            if (itemSelectSprite &amp;&amp; itemSelectImage)&#10;            {&#10;                itemSelectImage.sprite = itemSelectSprite;&#10;            }&#10;&#10;            // Hide the image component at start&#10;            if (itemSelectImage != null)&#10;            {&#10;                itemSelectImage.enabled = false;&#10;            }&#10;&#10;            // Keep GameObject active but start with hidden image&#10;            gameObject.SetActive(true);&#10;            &#10;            Debug.Log(&quot;[ItemSelectScreen] Initialized with hidden image&quot;);&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (submitAction)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnConfirmInput;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (submitAction)&#10;            {&#10;                submitAction.action.performed -= OnConfirmInput;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        public void SetConfig(LevelSelectionConfig config)&#10;        {&#10;            _config = config;&#10;&#10;            // Update display duration and wait behavior from config&#10;            if (_config != null)&#10;            {&#10;                displayDuration = _config.itemSelectDisplayDuration;&#10;                waitForInput = _config.waitForInputOnItemSelect;&#10;&#10;                // Update audio clip from config if available&#10;                if (_config.selectionSound &amp;&amp; !confirmSound)&#10;                {&#10;                    confirmSound = _config.selectionSound;&#10;                }&#10;            }&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus)&#10;        {&#10;            _eventBus = eventBus;&#10;        }&#10;&#10;        public void ShowItemSelect(string levelName, string sceneName, Action onComplete = null)&#10;        {&#10;            _pendingLevelName = levelName;&#10;            _pendingSceneName = sceneName;&#10;            _onComplete = onComplete;&#10;&#10;            // Show the item select image&#10;            if (itemSelectImage != null)&#10;            {&#10;                itemSelectImage.enabled = true;&#10;            }&#10;            &#10;            Debug.Log($&quot;[ItemSelectScreen] Showing item select for level: {levelName}&quot;);&#10;&#10;            if (waitForInput)&#10;            {&#10;                IsWaitingForInput = true;&#10;            }&#10;            else&#10;            {&#10;                StartCoroutine(AutoProgressAfterDelay());&#10;            }&#10;        }&#10;&#10;        private IEnumerator AutoProgressAfterDelay()&#10;        {&#10;            yield return new WaitForSeconds(displayDuration);&#10;            ConfirmAndProceed();&#10;        }&#10;&#10;        private void OnConfirmInput(InputAction.CallbackContext context)&#10;        {&#10;            if (IsWaitingForInput)&#10;            {&#10;                ConfirmAndProceed();&#10;            }&#10;        }&#10;&#10;        private void ConfirmAndProceed()&#10;        {&#10;            // Use config sound first, then fallback to assigned sound&#10;            AudioClip soundToPlay = _config?.selectionSound ?? confirmSound;&#10;&#10;            if (_audioSource &amp;&amp; soundToPlay)&#10;            {&#10;                _audioSource.PlayOneShot(soundToPlay);&#10;            }&#10;&#10;            IsWaitingForInput = false;&#10;            &#10;            // Hide the image component&#10;            if (itemSelectImage != null)&#10;            {&#10;                itemSelectImage.enabled = false;&#10;            }&#10;&#10;            // Publish level load request event&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = _pendingLevelName,&#10;                SceneName = _pendingSceneName&#10;            });&#10;&#10;            _onComplete?.Invoke();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelData.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelData.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection&#10;{&#10;    [Serializable]&#10;    public class LevelData&#10;    {&#10;        public string levelName;&#10;        public string sceneName;&#10;        public Vector2 mapPosition;&#10;        public bool isUnlocked;&#10;        public bool isCompleted;&#10;        public float bestTime;&#10;        public Sprite levelIcon;&#10;        public string displayName;&#10;        public int levelIndex;&#10;&#10;        public LevelData()&#10;        {&#10;            isUnlocked = false;&#10;            isCompleted = false;&#10;            bestTime = float.MaxValue;&#10;        }&#10;    }&#10;&#10;    public class LevelDataBuilder&#10;    {&#10;        private readonly LevelData _levelData;&#10;&#10;        public LevelDataBuilder()&#10;        {&#10;            _levelData = new LevelData();&#10;        }&#10;&#10;        public LevelDataBuilder WithName(string levelName)&#10;        {&#10;            _levelData.levelName = levelName;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder WithDisplayName(string displayName)&#10;        {&#10;            _levelData.displayName = displayName;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder WithScene(string sceneName)&#10;        {&#10;            _levelData.sceneName = sceneName;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder AtPosition(Vector2 position)&#10;        {&#10;            _levelData.mapPosition = position;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder WithIndex(int index)&#10;        {&#10;            _levelData.levelIndex = index;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder WithIcon(Sprite icon)&#10;        {&#10;            _levelData.levelIcon = icon;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder Unlocked(bool unlocked = true)&#10;        {&#10;            _levelData.isUnlocked = unlocked;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder Completed(bool completed = true)&#10;        {&#10;            _levelData.isCompleted = completed;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder WithBestTime(float time)&#10;        {&#10;            _levelData.bestTime = time;&#10;            return this;&#10;        }&#10;&#10;        public LevelData Build() =&gt; _levelData;&#10;    }&#10;&#10;    public static class LevelDataFactory&#10;    {&#10;        public static LevelData CreateFromGameObject(GameObject levelObject, int index)&#10;        {&#10;            LevelPoint levelPoint = levelObject.GetComponent&lt;LevelPoint&gt;();&#10;            if (levelPoint == null)&#10;            {&#10;                Debug.LogWarning($&quot;GameObject {levelObject.name} doesn't have a LevelPoint component&quot;);&#10;                return null;&#10;            }&#10;&#10;            // Determine unlock status based on inspector settings and game data&#10;            bool isUnlocked = DetermineUnlockStatus(levelPoint, index);&#10;&#10;            return new LevelDataBuilder()&#10;                .WithName(levelPoint.levelName)&#10;                .WithDisplayName(levelPoint.displayName)&#10;                .WithScene(levelPoint.sceneName)&#10;                .AtPosition(levelObject.transform.position)&#10;                .WithIndex(index)&#10;                .WithIcon(levelPoint.levelIcon)&#10;                .Unlocked(isUnlocked)&#10;                .Build();&#10;        }&#10;&#10;        public static LevelData CreateFromGameObjectWithGameData(GameObject levelObject, int index, Core.Data.GameData gameData)&#10;        {&#10;            LevelPoint levelPoint = levelObject.GetComponent&lt;LevelPoint&gt;();&#10;            if (levelPoint == null)&#10;            {&#10;                Debug.LogWarning($&quot;GameObject {levelObject.name} doesn't have a LevelPoint component&quot;);&#10;                return null;&#10;            }&#10;&#10;            // Determine unlock status using game data&#10;            bool isUnlocked = DetermineUnlockStatusWithGameData(levelPoint, index, gameData);&#10;            bool isCompleted = gameData?.completedLevels?.Contains(levelPoint.levelName) ?? false;&#10;&#10;            return new LevelDataBuilder()&#10;                .WithName(levelPoint.levelName)&#10;                .WithDisplayName(levelPoint.displayName)&#10;                .WithScene(levelPoint.sceneName)&#10;                .AtPosition(levelObject.transform.position)&#10;                .WithIndex(index)&#10;                .WithIcon(levelPoint.levelIcon)&#10;                .Unlocked(isUnlocked)&#10;                .Completed(isCompleted)&#10;                .Build();&#10;        }&#10;&#10;        private static bool DetermineUnlockStatus(LevelPoint levelPoint, int index)&#10;        {&#10;            // If level point overrides game data, use inspector setting&#10;            if (levelPoint.OverrideGameData)&#10;            {&#10;                return levelPoint.StartUnlocked;&#10;            }&#10;&#10;            // Default behavior: first level is always unlocked&#10;            return index == 0;&#10;        }&#10;&#10;        private static bool DetermineUnlockStatusWithGameData(LevelPoint levelPoint, int index, Core.Data.GameData gameData)&#10;        {&#10;            // If level point overrides game data, use inspector setting&#10;            if (levelPoint.OverrideGameData)&#10;            {&#10;                return levelPoint.StartUnlocked;&#10;            }&#10;&#10;            // Check if level is in unlocked levels list&#10;            if (gameData?.unlockedLevels != null &amp;&amp; gameData.unlockedLevels.Contains(levelPoint.levelName))&#10;            {&#10;                return true;&#10;            }&#10;&#10;            // Default behavior: first level is always unlocked&#10;            return index == 0;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Creates level data using only the GameObject's transform position and name&#10;        ///     Useful when LevelPoint component is not available&#10;        /// &lt;/summary&gt;&#10;        public static LevelData CreateFromTransform(GameObject levelObject, int index, string sceneName = null) =&gt;&#10;            new LevelDataBuilder()&#10;                .WithName(levelObject.name)&#10;                .WithDisplayName(levelObject.name)&#10;                .WithScene(sceneName ?? levelObject.name) // Use object name as scene if not provided&#10;                .AtPosition(levelObject.transform.position) // Always use the actual transform position&#10;                .WithIndex(index)&#10;                .Unlocked(index == 0)&#10;                .Build();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection&#10;{&#10;    [Serializable]&#10;    public class LevelData&#10;    {&#10;        public string levelName;&#10;        public string sceneName;&#10;        public Vector2 mapPosition;&#10;        public bool isUnlocked;&#10;        public bool isCompleted;&#10;        public float bestTime;&#10;        public string displayName;&#10;        public int levelIndex;&#10;&#10;        public LevelData()&#10;        {&#10;            isUnlocked = false;&#10;            isCompleted = false;&#10;            bestTime = float.MaxValue;&#10;        }&#10;    }&#10;&#10;    public class LevelDataBuilder&#10;    {&#10;        private readonly LevelData _levelData;&#10;&#10;        public LevelDataBuilder()&#10;        {&#10;            _levelData = new LevelData();&#10;        }&#10;&#10;        public LevelDataBuilder WithName(string levelName)&#10;        {&#10;            _levelData.levelName = levelName;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder WithDisplayName(string displayName)&#10;        {&#10;            _levelData.displayName = displayName;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder WithScene(string sceneName)&#10;        {&#10;            _levelData.sceneName = sceneName;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder AtPosition(Vector2 position)&#10;        {&#10;            _levelData.mapPosition = position;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder WithIndex(int index)&#10;        {&#10;            _levelData.levelIndex = index;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder Unlocked(bool unlocked = true)&#10;        {&#10;            _levelData.isUnlocked = unlocked;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder Completed(bool completed = true)&#10;        {&#10;            _levelData.isCompleted = completed;&#10;            return this;&#10;        }&#10;&#10;        public LevelDataBuilder WithBestTime(float time)&#10;        {&#10;            _levelData.bestTime = time;&#10;            return this;&#10;        }&#10;&#10;        public LevelData Build() =&gt; _levelData;&#10;    }&#10;&#10;    public static class LevelDataFactory&#10;    {&#10;        public static LevelData CreateFromGameObject(GameObject levelObject, int index)&#10;        {&#10;            LevelPoint levelPoint = levelObject.GetComponent&lt;LevelPoint&gt;();&#10;            if (levelPoint == null)&#10;            {&#10;                Debug.LogWarning($&quot;GameObject {levelObject.name} doesn't have a LevelPoint component&quot;);&#10;                return null;&#10;            }&#10;&#10;            // Determine unlock status based on inspector settings and game data&#10;            bool isUnlocked = DetermineUnlockStatus(levelPoint, index);&#10;&#10;            return new LevelDataBuilder()&#10;                .WithName(levelPoint.levelName)&#10;                .WithDisplayName(levelPoint.displayName)&#10;                .WithScene(levelPoint.sceneName)&#10;                .AtPosition(levelObject.transform.position)&#10;                .WithIndex(index)&#10;                .Unlocked(isUnlocked)&#10;                .Build();&#10;        }&#10;&#10;        public static LevelData CreateFromGameObjectWithGameData(GameObject levelObject, int index, Core.Data.GameData gameData)&#10;        {&#10;            LevelPoint levelPoint = levelObject.GetComponent&lt;LevelPoint&gt;();&#10;            if (levelPoint == null)&#10;            {&#10;                Debug.LogWarning($&quot;GameObject {levelObject.name} doesn't have a LevelPoint component&quot;);&#10;                return null;&#10;            }&#10;&#10;            // Determine unlock status using game data&#10;            bool isUnlocked = DetermineUnlockStatusWithGameData(levelPoint, index, gameData);&#10;            bool isCompleted = gameData?.completedLevels?.Contains(levelPoint.levelName) ?? false;&#10;&#10;            return new LevelDataBuilder()&#10;                .WithName(levelPoint.levelName)&#10;                .WithDisplayName(levelPoint.displayName)&#10;                .WithScene(levelPoint.sceneName)&#10;                .AtPosition(levelObject.transform.position)&#10;                .WithIndex(index)&#10;                .Unlocked(isUnlocked)&#10;                .Completed(isCompleted)&#10;                .Build();&#10;        }&#10;&#10;        private static bool DetermineUnlockStatus(LevelPoint levelPoint, int index)&#10;        {&#10;            // If level point overrides game data, use inspector setting&#10;            if (levelPoint.OverrideGameData)&#10;            {&#10;                return levelPoint.StartUnlocked;&#10;            }&#10;&#10;            // Default behavior: first level is always unlocked&#10;            return index == 0;&#10;        }&#10;&#10;        private static bool DetermineUnlockStatusWithGameData(LevelPoint levelPoint, int index, Core.Data.GameData gameData)&#10;        {&#10;            // If level point overrides game data, use inspector setting&#10;            if (levelPoint.OverrideGameData)&#10;            {&#10;                return levelPoint.StartUnlocked;&#10;            }&#10;&#10;            // Check if level is in unlocked levels list&#10;            if (gameData?.unlockedLevels != null &amp;&amp; gameData.unlockedLevels.Contains(levelPoint.levelName))&#10;            {&#10;                return true;&#10;            }&#10;&#10;            // Default behavior: first level is always unlocked&#10;            return index == 0;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Creates level data using only the GameObject's transform position and name&#10;        ///     Useful when LevelPoint component is not available&#10;        /// &lt;/summary&gt;&#10;        public static LevelData CreateFromTransform(GameObject levelObject, int index, string sceneName = null) =&gt;&#10;            new LevelDataBuilder()&#10;                .WithName(levelObject.name)&#10;                .WithDisplayName(levelObject.name)&#10;                .WithScene(sceneName ?? levelObject.name) // Use object name as scene if not provided&#10;                .AtPosition(levelObject.transform.position) // Always use the actual transform position&#10;                .WithIndex(index)&#10;                .Unlocked(index == 0)&#10;                .Build();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelPoint.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelPoint.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class LevelPoint : MonoBehaviour&#10;    {&#10;        [Header(&quot;Level Configuration&quot;)] &#10;        public string levelName;&#10;&#10;        public string displayName;&#10;        public string sceneName;&#10;        public Sprite levelIcon;&#10;        &#10;        [Header(&quot;Unlock Configuration&quot;)]&#10;        [SerializeField] private bool startUnlocked = true;&#10;        [SerializeField] private bool overrideGameData = false;&#10;        [Tooltip(&quot;If true, this level ignores saved game data and uses the inspector setting&quot;)]&#10;        &#10;        [Header(&quot;Visual Configuration&quot;)] &#10;        public SpriteRenderer iconRenderer;&#10;&#10;        public SpriteRenderer lockRenderer;&#10;        public Color unlockedColor = Color.white;&#10;        public Color lockedColor = Color.gray;&#10;&#10;        [Header(&quot;Animation&quot;)] &#10;        public float pulseSpeed = 2f;&#10;&#10;        public float pulseScale = 1.1f;&#10;&#10;        private Vector3 _originalScale;&#10;&#10;        public bool IsUnlocked { get; private set; }&#10;&#10;        public bool IsSelected { get; private set; }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Gets the inspector setting for whether this level starts unlocked&#10;        /// &lt;/summary&gt;&#10;        public bool StartUnlocked =&gt; startUnlocked;&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Gets whether this level should override saved game data&#10;        /// &lt;/summary&gt;&#10;        public bool OverrideGameData =&gt; overrideGameData;&#10;&#10;        private void Awake()&#10;        {&#10;            _originalScale = transform.localScale;&#10;&#10;            if (iconRenderer &amp;&amp; levelIcon)&#10;            {&#10;                iconRenderer.sprite = levelIcon;&#10;            }&#10;            &#10;            // Set initial unlock state based on inspector setting&#10;            if (overrideGameData)&#10;            {&#10;                SetUnlocked(startUnlocked);&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (IsSelected &amp;&amp; IsUnlocked)&#10;            {&#10;                // Pulse animation for selected level&#10;                float scale = 1f + Mathf.Sin(Time.time * pulseSpeed) * (pulseScale - 1f) * 0.5f;&#10;                transform.localScale = _originalScale * scale;&#10;            }&#10;            else&#10;            {&#10;                transform.localScale = _originalScale;&#10;            }&#10;        }&#10;&#10;        public void SetUnlocked(bool unlocked)&#10;        {&#10;            IsUnlocked = unlocked;&#10;            UpdateVisuals();&#10;        }&#10;&#10;        public void SetSelected(bool selected)&#10;        {&#10;            IsSelected = selected;&#10;            UpdateVisuals();&#10;        }&#10;&#10;        private void UpdateVisuals()&#10;        {&#10;            if (iconRenderer)&#10;            {&#10;                iconRenderer.color = IsUnlocked ? unlockedColor : lockedColor;&#10;            }&#10;&#10;            if (lockRenderer)&#10;            {&#10;                lockRenderer.gameObject.SetActive(!IsUnlocked);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class LevelPoint : MonoBehaviour&#10;    {&#10;        [Header(&quot;Level Configuration&quot;)] &#10;        public string levelName;&#10;&#10;        public string displayName;&#10;        public string sceneName;&#10;        &#10;        [Header(&quot;Unlock Configuration&quot;)]&#10;        [SerializeField] private bool startUnlocked = true;&#10;        [SerializeField] private bool overrideGameData = false;&#10;        [Tooltip(&quot;If true, this level ignores saved game data and uses the inspector setting&quot;)]&#10;&#10;        public bool IsUnlocked { get; private set; }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Gets the inspector setting for whether this level starts unlocked&#10;        /// &lt;/summary&gt;&#10;        public bool StartUnlocked =&gt; startUnlocked;&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Gets whether this level should override saved game data&#10;        /// &lt;/summary&gt;&#10;        public bool OverrideGameData =&gt; overrideGameData;&#10;&#10;        private void Awake()&#10;        {&#10;            // Set initial unlock state based on inspector setting&#10;            if (overrideGameData)&#10;            {&#10;                SetUnlocked(startUnlocked);&#10;            }&#10;        }&#10;&#10;        public void SetUnlocked(bool unlocked)&#10;        {&#10;            IsUnlocked = unlocked;&#10;        }&#10;&#10;        public void SetSelected(bool selected)&#10;        {&#10;            // No visual feedback needed since levels are invisible points&#10;            // This method exists for interface compatibility&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionConfig.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionConfig.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Configuration class for level selection system settings&#10;    ///     Simple serializable class that appears directly in the inspector&#10;    /// &lt;/summary&gt;&#10;    [Serializable]&#10;    public class LevelSelectionConfig&#10;    {&#10;        [Header(&quot;Navigation Settings&quot;)] public int gridWidth = 4;&#10;&#10;        public float selectorMoveSpeed = 5f;&#10;        public float snapThreshold = 0.1f;&#10;&#10;        [Header(&quot;Visual Settings&quot;)] public Color unlockedColor = Color.white;&#10;        [Header(&quot;Audio Settings&quot;)] public AudioClip navigationSound;&#10;&#10;        public AudioClip selectionSound;&#10;        public AudioClip lockedSound;&#10;&#10;        [Header(&quot;Selector Discovery&quot;)]&#10;        public string[] selectorNames = { &quot;Selector&quot;, &quot;Level Selector&quot;, &quot;LevelSelector&quot; };&#10;&#10;        public string selectorTag = &quot;LevelSelector&quot;;&#10;&#10;        [Header(&quot;Item Select Screen&quot;)] public float itemSelectDisplayDuration = 2f;&#10;&#10;        public bool waitForInputOnItemSelect = true;&#10;&#10;        [Header(&quot;Transition&quot;)] public float transitionDuration = 1f;&#10;&#10;        public Color[] nesTransitionColors = { Color.black, new(0.2f, 0.2f, 0.3f), new(0.1f, 0.1f, 0.2f) };&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Configuration class for level selection system settings&#10;    ///     Simple serializable class that appears directly in the inspector&#10;    /// &lt;/summary&gt;&#10;    [Serializable]&#10;    public class LevelSelectionConfig&#10;    {&#10;        [Header(&quot;Navigation Settings&quot;)] public int gridWidth = 4;&#10;&#10;        public float selectorMoveSpeed = 5f;&#10;        public float snapThreshold = 0.1f;&#10;&#10;        [Header(&quot;Audio Settings&quot;)] public AudioClip navigationSound;&#10;&#10;        public AudioClip selectionSound;&#10;        public AudioClip lockedSound;&#10;&#10;        [Header(&quot;Item Select Screen&quot;)] public float itemSelectDisplayDuration = 2f;&#10;&#10;        public bool waitForInputOnItemSelect = true;&#10;&#10;        [Header(&quot;Transition&quot;)] public float transitionDuration = 1f;&#10;&#10;        public Color[] nesTransitionColors = { Color.black, new(0.2f, 0.2f, 0.3f), new(0.1f, 0.1f, 0.2f) };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionController.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using Core.Events;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Centralized controller that manages all level selection functionality&#10;    ///     Uses inspector assignments and input module instead of complex auto-discovery&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionController : MonoBehaviour&#10;    {&#10;        private const float InputCooldownTime = 0.2f; // Prevent input spam&#10;        private const float InputDeadzone = 0.5f; // Input threshold&#10;&#10;        [Header(&quot;Auto Configuration&quot;)] [SerializeField]&#10;        private bool autoActivateOnStart = true;&#10;&#10;        [SerializeField] private LevelSelectionConfig config;&#10;&#10;        [Header(&quot;UI Components&quot;)] [SerializeField]&#10;        private GameObject selectorObject;&#10;&#10;        [SerializeField] private ItemSelectScreen itemSelectScreen;&#10;        [SerializeField] private NESCrossfade crossfade;&#10;&#10;        [Header(&quot;Input Actions&quot;)] [SerializeField]&#10;        private InputActionReference navigateAction;&#10;&#10;        [SerializeField] private InputActionReference submitAction;&#10;&#10;        // Audio support&#10;        private AudioSource _audioSource;&#10;&#10;        private ILevelDiscoveryService _discoveryService;&#10;        private ILevelDisplayService _displayService;&#10;        private IEventBus _eventBus;&#10;&#10;        // Selector movement&#10;        private bool _isMovingSelector;&#10;&#10;        // Input filtering&#10;        private Vector2 _lastInputDirection;&#10;        private float _lastInputTime;&#10;        private ILevelNavigationService _navigationService;&#10;        private Vector3 _selectorTargetPosition;&#10;        private List&lt;LevelPoint&gt; _sortedLevelPoints; // Cache sorted level points&#10;&#10;        public bool IsActive { get; private set; }&#10;        public LevelSelectionConfig Config =&gt; config;&#10;&#10;        private async void Start()&#10;        {&#10;            await InitializeAsync();&#10;&#10;            if (autoActivateOnStart)&#10;            {&#10;                Activate();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            UpdateSelectorMovement();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.Enable();&#10;                navigateAction.action.performed += OnNavigate;&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnSubmit;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.performed -= OnNavigate;&#10;                navigateAction.action.Disable();&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.performed -= OnSubmit;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;&#10;            // Properly dispose of display service&#10;            _displayService?.Dispose();&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            ILevelDiscoveryService discoveryService,&#10;            ILevelNavigationService navigationService,&#10;            ILevelDisplayService displayService,&#10;            IEventBus eventBus)&#10;        {&#10;            _discoveryService = discoveryService;&#10;            _navigationService = navigationService;&#10;            _displayService = displayService;&#10;            _eventBus = eventBus;&#10;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private async Task InitializeAsync()&#10;        {&#10;            // Setup audio source for config sounds&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (_audioSource == null)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;&#10;            var levelData = await _discoveryService.DiscoverLevelsAsync();&#10;            await _navigationService.InitializeAsync(levelData);&#10;            await _displayService.InitializeAsync(levelData);&#10;&#10;            // Get sorted level points from the discovery service - NO DUPLICATION!&#10;            _sortedLevelPoints = _discoveryService.GetSortedLevelPoints();&#10;&#10;            // Pass the sorted level points to the display service using DI pattern&#10;            _displayService.SetLevelPoints(_sortedLevelPoints);&#10;&#10;            // Pass config to services that need it&#10;            if (config != null)&#10;            {&#10;                _displayService.SetConfig(config);&#10;&#10;                // Set grid width for navigation using the interface method&#10;                _navigationService.SetGridWidth(config.gridWidth);&#10;&#10;                // Pass config to ItemSelectScreen if available&#10;                if (itemSelectScreen)&#10;                {&#10;                    itemSelectScreen.SetConfig(config);&#10;                }&#10;&#10;                // Pass config to crossfade if available&#10;                if (crossfade)&#10;                {&#10;                    crossfade.SetConfig(config);&#10;                }&#10;            }&#10;&#10;            Debug.Log(&#10;                $&quot;[LevelSelectionController] Initialized with {levelData.Count} levels using discovery service sorted data&quot;);&#10;        }&#10;&#10;        private void UpdateSelectorMovement()&#10;        {&#10;            if (!_isMovingSelector || selectorObject == null) return;&#10;&#10;            float moveSpeed = config?.selectorMoveSpeed ?? 5f;&#10;            float snapThreshold = config?.snapThreshold ?? 0.1f;&#10;&#10;            selectorObject.transform.position = Vector3.MoveTowards(&#10;                selectorObject.transform.position,&#10;                _selectorTargetPosition,&#10;                moveSpeed * Time.deltaTime&#10;            );&#10;&#10;            if (Vector3.Distance(selectorObject.transform.position, _selectorTargetPosition) &lt; snapThreshold)&#10;            {&#10;                selectorObject.transform.position = _selectorTargetPosition;&#10;                _isMovingSelector = false;&#10;            }&#10;        }&#10;&#10;        private void OnNavigate(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive) return;&#10;&#10;            Vector2 direction = context.ReadValue&lt;Vector2&gt;();&#10;&#10;            // Apply deadzone filtering&#10;            if (direction.magnitude &lt; InputDeadzone) return;&#10;&#10;            // Apply input cooldown to prevent spam&#10;            if (Time.time - _lastInputTime &lt; InputCooldownTime) return;&#10;&#10;            // Normalize direction for consistent behavior&#10;            direction = direction.normalized;&#10;&#10;            // Check if this is the same direction as last input (prevent repeats)&#10;            if (Vector2.Dot(direction, _lastInputDirection) &gt; 0.8f &amp;&amp;&#10;                Time.time - _lastInputTime &lt; InputCooldownTime * 2f) return;&#10;&#10;            _lastInputDirection = direction;&#10;            _lastInputTime = Time.time;&#10;&#10;            Debug.Log($&quot;[LevelSelectionController] Processing navigation input: {direction}&quot;);&#10;            _navigationService.NavigateInDirection(direction);&#10;        }&#10;&#10;        private void OnSubmit(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive) return;&#10;&#10;            _navigationService.SelectCurrentLevel();&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            // Play navigation sound from config&#10;            if (config?.navigationSound &amp;&amp; _audioSource)&#10;            {&#10;                _audioSource.PlayOneShot(config.navigationSound);&#10;            }&#10;&#10;            // Only move selector if the index actually changed&#10;            MoveSelectorToCurrentLevel();&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent selectionEvent)&#10;        {&#10;            Debug.Log($&quot;[LevelSelectionController] Level selected: {selectionEvent.LevelName}&quot;);&#10;&#10;            // Check if level is unlocked for sound feedback&#10;            LevelData levelData = _navigationService.CurrentLevel;&#10;            if (levelData != null &amp;&amp; !levelData.isUnlocked)&#10;            {&#10;                // Play locked sound from config&#10;                if (config?.lockedSound != null &amp;&amp; _audioSource != null)&#10;                {&#10;                    _audioSource.PlayOneShot(config.lockedSound);&#10;                }&#10;&#10;                Debug.Log($&quot;[LevelSelectionController] Level {selectionEvent.LevelName} is locked&quot;);&#10;                return;&#10;            }&#10;&#10;            // Play selection sound from config&#10;            if (config?.selectionSound != null &amp;&amp; _audioSource != null)&#10;            {&#10;                _audioSource.PlayOneShot(config.selectionSound);&#10;            }&#10;&#10;            // Get the scene name from the level data directly&#10;            string sceneName = GetSceneNameForLevel(levelData);&#10;            Debug.Log($&quot;[LevelSelectionController] Loading level: {selectionEvent.LevelName} -&gt; Scene: {sceneName}&quot;);&#10;&#10;            // Show ItemSelectScreen if available, otherwise load directly&#10;            if (itemSelectScreen != null)&#10;            {&#10;                itemSelectScreen.ShowItemSelect(selectionEvent.LevelName, sceneName);&#10;            }&#10;            else&#10;            {&#10;                // Load level directly if no ItemSelectScreen&#10;                LoadLevel(sceneName);&#10;            }&#10;        }&#10;&#10;        private string GetSceneNameForLevel(LevelData levelData)&#10;        {&#10;            // Use the scene name from level data if available&#10;            if (!string.IsNullOrEmpty(levelData?.sceneName))&#10;            {&#10;                return levelData.sceneName;&#10;            }&#10;&#10;            // Fallback to level name conversion&#10;            return levelData?.levelName?.Replace(&quot; &quot;, &quot;&quot;).Replace(&quot;_&quot;, &quot;&quot;) ?? &quot;DefaultLevel&quot;;&#10;        }&#10;&#10;        private void LoadLevel(string sceneName)&#10;        {&#10;            Debug.Log($&quot;[LevelSelectionController] Loading scene: {sceneName}&quot;);&#10;&#10;            // Use SceneTransitionManager if available, otherwise fallback to crossfade&#10;            if (SceneTransitionManager.Instance != null)&#10;            {&#10;                SceneTransitionManager.Instance.TransitionToScene(sceneName);&#10;            }&#10;            else if (crossfade != null)&#10;            {&#10;                crossfade.FadeOutAndIn(&#10;                    () =&gt; SceneManager.LoadScene(sceneName),&#10;                    () =&gt; Debug.Log($&quot;Loaded scene: {sceneName}&quot;)&#10;                );&#10;            }&#10;            else&#10;            {&#10;                SceneManager.LoadScene(sceneName);&#10;            }&#10;        }&#10;&#10;        private void OnLevelLoadRequested(LevelLoadRequestedEvent loadEvent)&#10;        {&#10;            Debug.Log(&#10;                $&quot;[LevelSelectionController] Level load requested: {loadEvent.LevelName} -&gt; {loadEvent.SceneName}&quot;);&#10;&#10;            LoadLevel(loadEvent.SceneName);&#10;        }&#10;&#10;        private void MoveSelectorToCurrentLevel()&#10;        {&#10;            if (selectorObject == null || _sortedLevelPoints == null) return;&#10;&#10;            // Don't move if already moving to avoid redundant calls&#10;            if (_isMovingSelector) return;&#10;&#10;            // Use the sorted level points from the discovery service&#10;            if (_navigationService.CurrentIndex &gt;= 0 &amp;&amp; _navigationService.CurrentIndex &lt; _sortedLevelPoints.Count)&#10;            {&#10;                Vector3 targetPosition = _sortedLevelPoints[_navigationService.CurrentIndex].transform.position;&#10;&#10;                // Only start moving if we're not already at the target position&#10;                if (Vector3.Distance(selectorObject.transform.position, targetPosition) &gt; 0.01f)&#10;                {&#10;                    _selectorTargetPosition = targetPosition;&#10;                    _isMovingSelector = true;&#10;&#10;                    Debug.Log(&#10;                        $&quot;[LevelSelectionController] Moving selector to level {_navigationService.CurrentIndex} at position {_selectorTargetPosition}&quot;);&#10;                }&#10;                else&#10;                {&#10;                    Debug.Log(&#10;                        $&quot;[LevelSelectionController] Selector already at level {_navigationService.CurrentIndex} position&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&#10;                    $&quot;[LevelSelectionController] Invalid level index: {_navigationService.CurrentIndex} (max: {_sortedLevelPoints.Count - 1})&quot;);&#10;            }&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            Debug.Log(&#10;                $&quot;[LevelSelectionController] Activating - Current navigation index: {_navigationService?.CurrentIndex}&quot;);&#10;&#10;            IsActive = true;&#10;            _navigationService?.Activate();&#10;            _displayService?.Activate();&#10;&#10;            // Move selector to current position when activating&#10;            MoveSelectorToCurrentLevel();&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            IsActive = false;&#10;            _navigationService?.Deactivate();&#10;            _displayService?.Deactivate();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Public method to refresh all visuals - useful for external calls&#10;        /// &lt;/summary&gt;&#10;        public void RefreshVisuals()&#10;        {&#10;            _displayService?.RefreshVisuals();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Public method to set level selection programmatically&#10;        /// &lt;/summary&gt;&#10;        public void SetCurrentLevel(int levelIndex)&#10;        {&#10;            Debug.Log($&quot;[LevelSelectionController] SetCurrentLevel called with index: {levelIndex}&quot;);&#10;            _navigationService?.SetCurrentIndex(levelIndex);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using Core.Events;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Centralized controller that manages all level selection functionality&#10;    ///     Uses inspector assignments and input module instead of complex auto-discovery&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionController : MonoBehaviour&#10;    {&#10;        private const float InputCooldownTime = 0.2f; // Prevent input spam&#10;        private const float InputDeadzone = 0.5f; // Input threshold&#10;&#10;        [Header(&quot;Auto Configuration&quot;)] [SerializeField]&#10;        private bool autoActivateOnStart = true;&#10;&#10;        [SerializeField] private LevelSelectionConfig config;&#10;&#10;        [Header(&quot;UI Components&quot;)] [SerializeField]&#10;        private GameObject selectorObject;&#10;&#10;        [SerializeField] private ItemSelectScreen itemSelectScreen;&#10;        [SerializeField] private NESCrossfade crossfade;&#10;&#10;        [Header(&quot;Input Actions&quot;)] [SerializeField]&#10;        private InputActionReference navigateAction;&#10;&#10;        [SerializeField] private InputActionReference submitAction;&#10;&#10;        // Audio support&#10;        private AudioSource _audioSource;&#10;&#10;        private ILevelDiscoveryService _discoveryService;&#10;        private ILevelDisplayService _displayService;&#10;        private IEventBus _eventBus;&#10;&#10;        // Selector movement&#10;        private bool _isMovingSelector;&#10;&#10;        // Input filtering&#10;        private Vector2 _lastInputDirection;&#10;        private float _lastInputTime;&#10;        private ILevelNavigationService _navigationService;&#10;        private Vector3 _selectorTargetPosition;&#10;        private List&lt;LevelPoint&gt; _sortedLevelPoints; // Cache sorted level points&#10;&#10;        public bool IsActive { get; private set; }&#10;        public LevelSelectionConfig Config =&gt; config;&#10;&#10;        private async void Start()&#10;        {&#10;            await InitializeAsync();&#10;&#10;            if (autoActivateOnStart)&#10;            {&#10;                Activate();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            UpdateSelectorMovement();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.Enable();&#10;                navigateAction.action.performed += OnNavigate;&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnSubmit;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.performed -= OnNavigate;&#10;                navigateAction.action.Disable();&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.performed -= OnSubmit;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;&#10;            // Properly dispose of display service&#10;            _displayService?.Dispose();&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            ILevelDiscoveryService discoveryService,&#10;            ILevelNavigationService navigationService,&#10;            ILevelDisplayService displayService,&#10;            IEventBus eventBus)&#10;        {&#10;            _discoveryService = discoveryService;&#10;            _navigationService = navigationService;&#10;            _displayService = displayService;&#10;            _eventBus = eventBus;&#10;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private async Task InitializeAsync()&#10;        {&#10;            // Setup audio source for config sounds&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (_audioSource == null)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;&#10;            var levelData = await _discoveryService.DiscoverLevelsAsync();&#10;            await _navigationService.InitializeAsync(levelData);&#10;            await _displayService.InitializeAsync(levelData);&#10;&#10;            // Get sorted level points from the discovery service - NO DUPLICATION!&#10;            _sortedLevelPoints = _discoveryService.GetSortedLevelPoints();&#10;&#10;            // Pass the sorted level points to the display service using DI pattern&#10;            _displayService.SetLevelPoints(_sortedLevelPoints);&#10;&#10;            // Pass config to services that need it&#10;            if (config != null)&#10;            {&#10;                _displayService.SetConfig(config);&#10;&#10;                // Set grid width for navigation using the interface method&#10;                _navigationService.SetGridWidth(config.gridWidth);&#10;&#10;                // Pass config to ItemSelectScreen if available&#10;                if (itemSelectScreen)&#10;                {&#10;                    itemSelectScreen.SetConfig(config);&#10;                }&#10;&#10;                // Pass config to crossfade if available&#10;                if (crossfade)&#10;                {&#10;                    crossfade.SetConfig(config);&#10;                }&#10;            }&#10;&#10;            Debug.Log(&#10;                $&quot;[LevelSelectionController] Initialized with {levelData.Count} levels using discovery service sorted data&quot;);&#10;        }&#10;&#10;        private void UpdateSelectorMovement()&#10;        {&#10;            if (!_isMovingSelector || selectorObject == null) return;&#10;&#10;            float moveSpeed = config?.selectorMoveSpeed ?? 5f;&#10;            float snapThreshold = config?.snapThreshold ?? 0.1f;&#10;&#10;            selectorObject.transform.position = Vector3.MoveTowards(&#10;                selectorObject.transform.position,&#10;                _selectorTargetPosition,&#10;                moveSpeed * Time.deltaTime&#10;            );&#10;&#10;            if (Vector3.Distance(selectorObject.transform.position, _selectorTargetPosition) &lt; snapThreshold)&#10;            {&#10;                selectorObject.transform.position = _selectorTargetPosition;&#10;                _isMovingSelector = false;&#10;            }&#10;        }&#10;&#10;        private void OnNavigate(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive) return;&#10;&#10;            Vector2 direction = context.ReadValue&lt;Vector2&gt;();&#10;&#10;            // Apply deadzone filtering&#10;            if (direction.magnitude &lt; InputDeadzone) return;&#10;&#10;            // Apply input cooldown to prevent spam&#10;            if (Time.time - _lastInputTime &lt; InputCooldownTime) return;&#10;&#10;            // Normalize direction for consistent behavior&#10;            direction = direction.normalized;&#10;&#10;            // Check if this is the same direction as last input (prevent repeats)&#10;            if (Vector2.Dot(direction, _lastInputDirection) &gt; 0.8f &amp;&amp;&#10;                Time.time - _lastInputTime &lt; InputCooldownTime * 2f) return;&#10;&#10;            _lastInputDirection = direction;&#10;            _lastInputTime = Time.time;&#10;&#10;            Debug.Log($&quot;[LevelSelectionController] Processing navigation input: {direction}&quot;);&#10;            _navigationService.NavigateInDirection(direction);&#10;        }&#10;&#10;        private void OnSubmit(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive) return;&#10;&#10;            _navigationService.SelectCurrentLevel();&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            // Play navigation sound from config&#10;            if (config?.navigationSound &amp;&amp; _audioSource)&#10;            {&#10;                _audioSource.PlayOneShot(config.navigationSound);&#10;            }&#10;&#10;            // Only move selector if the index actually changed&#10;            MoveSelectorToCurrentLevel();&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent selectionEvent)&#10;        {&#10;            Debug.Log($&quot;[LevelSelectionController] Level selected: {selectionEvent.LevelName}&quot;);&#10;&#10;            // Check if level is unlocked for sound feedback&#10;            LevelData levelData = _navigationService.CurrentLevel;&#10;            if (levelData != null &amp;&amp; !levelData.isUnlocked)&#10;            {&#10;                // Play locked sound from config&#10;                if (config?.lockedSound != null &amp;&amp; _audioSource != null)&#10;                {&#10;                    _audioSource.PlayOneShot(config.lockedSound);&#10;                }&#10;&#10;                Debug.Log($&quot;[LevelSelectionController] Level {selectionEvent.LevelName} is locked&quot;);&#10;                return;&#10;            }&#10;&#10;            // Play selection sound from config&#10;            if (config?.selectionSound != null &amp;&amp; _audioSource != null)&#10;            {&#10;                _audioSource.PlayOneShot(config.selectionSound);&#10;            }&#10;&#10;            // Get the scene name from the level data directly&#10;            string sceneName = GetSceneNameForLevel(levelData);&#10;            Debug.Log($&quot;[LevelSelectionController] Loading level: {selectionEvent.LevelName} -&gt; Scene: {sceneName}&quot;);&#10;&#10;            // Show ItemSelectScreen if available, otherwise load directly&#10;            if (itemSelectScreen != null)&#10;            {&#10;                itemSelectScreen.ShowItemSelect(selectionEvent.LevelName, sceneName);&#10;            }&#10;            else&#10;            {&#10;                // Load level directly if no ItemSelectScreen&#10;                LoadLevel(sceneName);&#10;            }&#10;        }&#10;&#10;        private string GetSceneNameForLevel(LevelData levelData)&#10;        {&#10;            // Use the scene name from level data if available&#10;            if (!string.IsNullOrEmpty(levelData?.sceneName))&#10;            {&#10;                return levelData.sceneName;&#10;            }&#10;&#10;            // Fallback to level name conversion&#10;            return levelData?.levelName?.Replace(&quot; &quot;, &quot;&quot;).Replace(&quot;_&quot;, &quot;&quot;) ?? &quot;DefaultLevel&quot;;&#10;        }&#10;&#10;        private void LoadLevel(string sceneName)&#10;        {&#10;            Debug.Log($&quot;[LevelSelectionController] Loading scene: {sceneName}&quot;);&#10;&#10;            // Use standalone SceneTransitionManager first&#10;            SceneTransitionManager.TransitionTo(sceneName);&#10;        }&#10;&#10;        private void OnLevelLoadRequested(LevelLoadRequestedEvent loadEvent)&#10;        {&#10;            Debug.Log(&#10;                $&quot;[LevelSelectionController] Level load requested: {loadEvent.LevelName} -&gt; {loadEvent.SceneName}&quot;);&#10;&#10;            LoadLevel(loadEvent.SceneName);&#10;        }&#10;&#10;        private void MoveSelectorToCurrentLevel()&#10;        {&#10;            if (selectorObject == null || _sortedLevelPoints == null) return;&#10;&#10;            // Don't move if already moving to avoid redundant calls&#10;            if (_isMovingSelector) return;&#10;&#10;            // Use the sorted level points from the discovery service&#10;            if (_navigationService.CurrentIndex &gt;= 0 &amp;&amp; _navigationService.CurrentIndex &lt; _sortedLevelPoints.Count)&#10;            {&#10;                Vector3 targetPosition = _sortedLevelPoints[_navigationService.CurrentIndex].transform.position;&#10;&#10;                // Only start moving if we're not already at the target position&#10;                if (Vector3.Distance(selectorObject.transform.position, targetPosition) &gt; 0.01f)&#10;                {&#10;                    _selectorTargetPosition = targetPosition;&#10;                    _isMovingSelector = true;&#10;&#10;                    Debug.Log(&#10;                        $&quot;[LevelSelectionController] Moving selector to level {_navigationService.CurrentIndex} at position {_selectorTargetPosition}&quot;);&#10;                }&#10;                else&#10;                {&#10;                    Debug.Log(&#10;                        $&quot;[LevelSelectionController] Selector already at level {_navigationService.CurrentIndex} position&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&#10;                    $&quot;[LevelSelectionController] Invalid level index: {_navigationService.CurrentIndex} (max: {_sortedLevelPoints.Count - 1})&quot;);&#10;            }&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            Debug.Log(&#10;                $&quot;[LevelSelectionController] Activating - Current navigation index: {_navigationService?.CurrentIndex}&quot;);&#10;&#10;            IsActive = true;&#10;            _navigationService?.Activate();&#10;            _displayService?.Activate();&#10;&#10;            // Move selector to current position when activating&#10;            MoveSelectorToCurrentLevel();&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            IsActive = false;&#10;            _navigationService?.Deactivate();&#10;            _displayService?.Deactivate();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Public method to refresh all visuals - useful for external calls&#10;        /// &lt;/summary&gt;&#10;        public void RefreshVisuals()&#10;        {&#10;            _displayService?.RefreshVisuals();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Public method to set level selection programmatically&#10;        /// &lt;/summary&gt;&#10;        public void SetCurrentLevel(int levelIndex)&#10;        {&#10;            Debug.Log($&quot;[LevelSelectionController] SetCurrentLevel called with index: {levelIndex}&quot;);&#10;            _navigationService?.SetCurrentIndex(levelIndex);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionDirector.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionDirector.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Director pattern implementation for building level data structures&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionDirector&#10;    {&#10;        public List&lt;LevelData&gt; BuildLevelData(List&lt;GameObject&gt; levelGameObjects)&#10;        {&#10;            var levelDataList = new List&lt;LevelData&gt;();&#10;            &#10;            for (int i = 0; i &lt; levelGameObjects.Count; i++)&#10;            {&#10;                var levelObject = levelGameObjects[i];&#10;                if (levelObject == null) continue;&#10;&#10;                var levelData = LevelDataFactory.CreateFromGameObject(levelObject, i);&#10;                if (levelData != null)&#10;                {&#10;                    levelDataList.Add(levelData);&#10;                }&#10;                else&#10;                {&#10;                    // Fallback - create basic level data from GameObject name&#10;                    var fallbackData = LevelDataFactory.CreateDefault(&#10;                        levelObject.name,&#10;                        levelObject.name,&#10;                        levelObject.transform.position,&#10;                        i&#10;                    );&#10;                    levelDataList.Add(fallbackData);&#10;                }&#10;            }&#10;            &#10;            return levelDataList;&#10;        }&#10;&#10;        public LevelData BuildSingleLevel(GameObject levelObject, int index)&#10;        {&#10;            if (levelObject == null) return null;&#10;            &#10;            return LevelDataFactory.CreateFromGameObject(levelObject, index) ??&#10;                   LevelDataFactory.CreateDefault(levelObject.name, levelObject.name, levelObject.transform.position, index);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Director pattern implementation for building level data structures&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionDirector&#10;    {&#10;        public List&lt;LevelData&gt; BuildLevelData(List&lt;GameObject&gt; levelGameObjects)&#10;        {&#10;            var levelDataList = new List&lt;LevelData&gt;();&#10;            &#10;            for (int i = 0; i &lt; levelGameObjects.Count; i++)&#10;            {&#10;                var levelObject = levelGameObjects[i];&#10;                if (levelObject == null) continue;&#10;&#10;                // Try to create from LevelPoint component first&#10;                var levelData = LevelDataFactory.CreateFromGameObject(levelObject, i);&#10;                &#10;                if (levelData == null)&#10;                {&#10;                    // Fallback - create from transform position and object name&#10;                    Debug.Log($&quot;Creating level data from transform for {levelObject.name} at position {levelObject.transform.position}&quot;);&#10;                    levelData = LevelDataFactory.CreateFromTransform(levelObject, i);&#10;                }&#10;                &#10;                if (levelData != null)&#10;                {&#10;                    Debug.Log($&quot;Level {i}: {levelData.levelName} at position {levelData.mapPosition}&quot;);&#10;                    levelDataList.Add(levelData);&#10;                }&#10;            }&#10;            &#10;            return levelDataList;&#10;        }&#10;&#10;        public LevelData BuildSingleLevel(GameObject levelObject, int index)&#10;        {&#10;            if (levelObject == null) return null;&#10;            &#10;            // Try LevelPoint component first, fallback to transform-based creation&#10;            return LevelDataFactory.CreateFromGameObject(levelObject, index) ??&#10;                   LevelDataFactory.CreateFromTransform(levelObject, index);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionManager.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using System.Linq;&#10;using Core.Data;&#10;using Core.Events;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class LevelSelectionManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Level Configuration&quot;)]&#10;        [SerializeField] private bool autoDiscoverLevels = true;&#10;        [SerializeField] private bool autoActivateOnStart = true; &#10;        [SerializeField] private string levelTagFilter = &quot;&quot;; &#10;        public List&lt;GameObject&gt; levelGameObjects = new();&#10;        public Transform levelContainer;&#10;&#10;        [Header(&quot;Components&quot;)] public LevelSelector levelSelector;&#10;&#10;        public ItemSelectScreen itemSelectScreen;&#10;        public NESCrossfade crossfade;&#10;&#10;        [Header(&quot;Input Actions&quot;)]&#10;        [SerializeField] private InputActionReference navigateAction;&#10;        [SerializeField] private InputActionReference submitAction;&#10;&#10;        private List&lt;LevelData&gt; _levelData;&#10;        private List&lt;LevelPoint&gt; _levelPoints;&#10;        private IEventBus _eventBus;&#10;        private IGameDataService _gameDataService;&#10;        private bool _isActive = false;&#10;        private LevelSelectionDirector _director;&#10;&#10;        public bool IsActive&#10;        {&#10;            get =&gt; _isActive;&#10;            private set =&gt; _isActive = value;&#10;        }&#10;&#10;        private void Awake()&#10;        {&#10;            _director = new LevelSelectionDirector();&#10;            InitializeLevelSelection();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.Enable();&#10;                navigateAction.action.performed += OnNavigate;&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnConfirm;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.performed -= OnNavigate;&#10;                navigateAction.action.Disable();&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.performed -= OnConfirm;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, IGameDataService gameDataService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataService = gameDataService;&#10;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;        }&#10;&#10;        private void InitializeLevelSelection()&#10;        {&#10;            // Auto-discover level objects&#10;            if (autoDiscoverLevels)&#10;            {&#10;                AutoDiscoverLevelObjects();&#10;            }&#10;            // Manual discovery from container (fallback)&#10;            else if (levelContainer != null &amp;&amp; levelGameObjects.Count == 0)&#10;            {&#10;                for (int i = 0; i &lt; levelContainer.childCount; i++)&#10;                {&#10;                    Transform child = levelContainer.GetChild(i);&#10;                    if (child.GetComponent&lt;LevelPoint&gt;() != null)&#10;                    {&#10;                        levelGameObjects.Add(child.gameObject);&#10;                    }&#10;                }&#10;            }&#10;&#10;            Debug.Log($&quot;[LevelSelectionManager] Found {levelGameObjects.Count} level objects&quot;);&#10;&#10;            // Use director pattern to build level data&#10;            _levelData = _director.BuildLevelData(levelGameObjects);&#10;            _levelPoints = levelGameObjects.Select(go =&gt; go.GetComponent&lt;LevelPoint&gt;()).ToList();&#10;&#10;            LoadLevelProgressFromGameData();&#10;&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            int selectedIndex = gameData?.selectedLevelIndex ?? 0;&#10;&#10;            levelSelector?.Initialize(_levelData, _levelPoints, selectedIndex);&#10;&#10;            // Auto-activate level selection on start if enabled&#10;            if (autoActivateOnStart)&#10;            {&#10;                ActivateLevelSelection();&#10;            }&#10;        }&#10;&#10;        private void AutoDiscoverLevelObjects()&#10;        {&#10;            levelGameObjects.Clear();&#10;&#10;            // Find all GameObjects with LevelPoint components in the scene&#10;            LevelPoint[] allLevelPoints = FindObjectsByType&lt;LevelPoint&gt;(FindObjectsSortMode.None);&#10;&#10;            Debug.Log($&quot;[LevelSelectionManager] Auto-discovered {allLevelPoints.Length} LevelPoint components&quot;);&#10;&#10;            foreach (LevelPoint levelPoint in allLevelPoints)&#10;            {&#10;                // Optional tag filtering&#10;                if (!string.IsNullOrEmpty(levelTagFilter) &amp;&amp; !levelPoint.CompareTag(levelTagFilter))&#10;                {&#10;                    continue;&#10;                }&#10;&#10;                levelGameObjects.Add(levelPoint.gameObject);&#10;            }&#10;&#10;            // Sort by name or position for consistent ordering&#10;            levelGameObjects.Sort((a, b) =&gt; string.Compare(a.name, b.name, System.StringComparison.Ordinal));&#10;&#10;            Debug.Log($&quot;[LevelSelectionManager] After filtering and sorting: {levelGameObjects.Count} level objects&quot;);&#10;        }&#10;&#10;        private void LoadLevelProgressFromGameData()&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update unlock status based on game data&#10;            for (int i = 0; i &lt; _levelData.Count; i++)&#10;            {&#10;                LevelData level = _levelData[i];&#10;                level.isUnlocked = gameData.unlockedLevels.Contains(level.levelName);&#10;&#10;                if (gameData.levelCompleted.TryGetValue(level.levelName, out bool completed))&#10;                {&#10;                    level.isCompleted = completed;&#10;                }&#10;&#10;                if (gameData.levelBestTimes.TryGetValue(level.levelName, out float bestTime))&#10;                {&#10;                    level.bestTime = bestTime;&#10;                }&#10;            }&#10;        }&#10;&#10;        private void OnNavigate(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || levelSelector == null)&#10;            {&#10;                Debug.Log($&quot;[LevelSelectionManager] Navigate blocked - IsActive: {IsActive}, levelSelector: {levelSelector != null}&quot;);&#10;                return;&#10;            }&#10;&#10;            Vector2 direction = context.ReadValue&lt;Vector2&gt;();&#10;            Debug.Log($&quot;[LevelSelectionManager] Navigate input received: {direction}&quot;);&#10;&#10;            levelSelector.Navigate(direction);&#10;            SaveSelectedLevel();&#10;        }&#10;&#10;        private void OnConfirm(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || levelSelector == null) return;&#10;&#10;            levelSelector.SelectCurrentLevel();&#10;        }&#10;&#10;        private void SaveSelectedLevel()&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = levelSelector.CurrentIndex;&#10;                _gameDataService?.SaveData();&#10;            }&#10;        }&#10;&#10;        public void ActivateLevelSelection()&#10;        {&#10;            IsActive = true;&#10;            gameObject.SetActive(true);&#10;            Debug.Log($&quot;[LevelSelectionManager] Level selection activated. Level count: {_levelData?.Count ?? 0}&quot;);&#10;        }&#10;&#10;        public void DeactivateLevelSelection()&#10;        {&#10;            IsActive = false;&#10;            gameObject.SetActive(false);&#10;        }&#10;&#10;        // Debug method to check system status&#10;        [ContextMenu(&quot;Debug Level Selection Status&quot;)]&#10;        public void DebugStatus()&#10;        {&#10;            Debug.Log($&quot;=== Level Selection Debug Status ===&quot;);&#10;            Debug.Log($&quot;IsActive: {IsActive}&quot;);&#10;            Debug.Log($&quot;Navigate Action Assigned: {navigateAction != null}&quot;);&#10;            Debug.Log($&quot;Submit Action Assigned: {submitAction != null}&quot;);&#10;            Debug.Log($&quot;Level Selector Assigned: {levelSelector != null}&quot;);&#10;            Debug.Log($&quot;Level Data Count: {_levelData?.Count ?? 0}&quot;);&#10;            Debug.Log($&quot;Level GameObjects Count: {levelGameObjects.Count}&quot;);&#10;&#10;            if (levelSelector != null)&#10;            {&#10;                Debug.Log($&quot;Selector Object Assigned: {levelSelector.selectorObject != null}&quot;);&#10;                Debug.Log($&quot;Current Index: {levelSelector.CurrentIndex}&quot;);&#10;                Debug.Log($&quot;Is Moving: {levelSelector.IsMoving}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent levelEvent)&#10;        {&#10;            LevelData selectedLevel = _levelData.FirstOrDefault(l =&gt; l.levelName == levelEvent.LevelName);&#10;            if (selectedLevel == null) return;&#10;&#10;            // Update current level in game data&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.currentLevel = selectedLevel.levelName;&#10;                gameData.selectedLevelIndex = levelEvent.LevelIndex;&#10;                _gameDataService?.SaveData();&#10;            }&#10;&#10;            // Show item select screen&#10;            _eventBus?.Publish(new ItemSelectScreenRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = selectedLevel.levelName&#10;            });&#10;&#10;            itemSelectScreen?.ShowItemSelect(selectedLevel.levelName, selectedLevel.sceneName);&#10;        }&#10;&#10;        private void OnLevelLoadRequested(LevelLoadRequestedEvent loadEvent)&#10;        {&#10;            // Start crossfade and load scene&#10;            crossfade?.FadeOutAndIn(&#10;                () =&gt;&#10;                {&#10;                    // Load the scene&#10;                    SceneManager.LoadScene(loadEvent.SceneName);&#10;                },&#10;                () =&gt;&#10;                {&#10;                    // Publish level started event&#10;                    _eventBus?.Publish(new LevelStartedEvent&#10;                    {&#10;                        Timestamp = Time.time,&#10;                        LevelName = loadEvent.LevelName&#10;                    });&#10;                }&#10;            );&#10;        }&#10;&#10;        private void OnLevelCompleted(LevelCompletedEvent completedEvent)&#10;        {&#10;            // Update level completion status and unlock next level&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Mark level as completed&#10;            gameData.levelCompleted[completedEvent.LevelName] = true;&#10;&#10;            // Update best time&#10;            if (!gameData.levelBestTimes.ContainsKey(completedEvent.LevelName) ||&#10;                completedEvent.CompletionTime &lt; gameData.levelBestTimes[completedEvent.LevelName])&#10;            {&#10;                gameData.levelBestTimes[completedEvent.LevelName] = completedEvent.CompletionTime;&#10;            }&#10;&#10;            // Unlock next level&#10;            int completedIndex = _levelData.FindIndex(l =&gt; l.levelName == completedEvent.LevelName);&#10;            if (completedIndex &gt;= 0 &amp;&amp; completedIndex + 1 &lt; _levelData.Count)&#10;            {&#10;                string nextLevelName = _levelData[completedIndex + 1].levelName;&#10;                if (!gameData.unlockedLevels.Contains(nextLevelName))&#10;                {&#10;                    gameData.unlockedLevels.Add(nextLevelName);&#10;                }&#10;            }&#10;&#10;            _gameDataService?.SaveData();&#10;&#10;            // Refresh level data if we're still in level selection&#10;            if (IsActive)&#10;            {&#10;                LoadLevelProgressFromGameData();&#10;                levelSelector?.Initialize(_levelData, _levelPoints, levelSelector.CurrentIndex);&#10;            }&#10;        }&#10;&#10;        public List&lt;LevelData&gt; GetLevelData() =&gt; _levelData;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using System.Linq;&#10;using Core.Data;&#10;using Core.Events;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class LevelSelectionManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Level Configuration&quot;)]&#10;        [SerializeField] private bool autoActivateOnStart = true;&#10;        &#10;        [Header(&quot;Components - Auto-discovered if not assigned&quot;)]&#10;        public LevelSelector levelSelector;&#10;        public ItemSelectScreen itemSelectScreen;&#10;        public NESCrossfade crossfade;&#10;&#10;        [Header(&quot;Input Actions - Auto-assigned from UI action map&quot;)]&#10;        [SerializeField] private InputActionReference navigateAction;&#10;        [SerializeField] private InputActionReference submitAction;&#10;&#10;        // All private - no manual setup required&#10;        private List&lt;GameObject&gt; _levelGameObjects = new();&#10;        private List&lt;LevelData&gt; _levelData;&#10;        private List&lt;LevelPoint&gt; _levelPoints;&#10;        private IEventBus _eventBus;&#10;        private IGameDataService _gameDataService;&#10;        private bool _isActive = false;&#10;        private LevelSelectionDirector _director;&#10;&#10;        public bool IsActive&#10;        {&#10;            get =&gt; _isActive;&#10;            private set =&gt; _isActive = value;&#10;        }&#10;&#10;        private void Awake()&#10;        {&#10;            _director = new LevelSelectionDirector();&#10;            AutoDiscoverComponents();&#10;            InitializeLevelSelection();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.Enable();&#10;                navigateAction.action.performed += OnNavigate;&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnConfirm;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.performed -= OnNavigate;&#10;                navigateAction.action.Disable();&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.performed -= OnConfirm;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, IGameDataService gameDataService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataService = gameDataService;&#10;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;        }&#10;&#10;        private void InitializeLevelSelection()&#10;        {&#10;            // Auto-discover level objects&#10;            AutoDiscoverLevelObjects();&#10;&#10;            Debug.Log($&quot;[LevelSelectionManager] Found {_levelGameObjects.Count} level objects&quot;);&#10;&#10;            // Use director pattern to build level data&#10;            _levelData = _director.BuildLevelData(_levelGameObjects);&#10;            _levelPoints = _levelGameObjects.Select(go =&gt; go.GetComponent&lt;LevelPoint&gt;()).ToList();&#10;&#10;            LoadLevelProgressFromGameData();&#10;&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            int selectedIndex = gameData?.selectedLevelIndex ?? 0;&#10;&#10;            levelSelector?.Initialize(_levelData, _levelPoints, selectedIndex);&#10;&#10;            // Auto-activate level selection on start if enabled&#10;            if (autoActivateOnStart)&#10;            {&#10;                ActivateLevelSelection();&#10;            }&#10;        }&#10;&#10;        private void AutoDiscoverComponents()&#10;        {&#10;            // Automatically discover and assign components in the scene&#10;            if (levelSelector == null)&#10;            {&#10;                levelSelector = FindObjectOfType&lt;LevelSelector&gt;();&#10;            }&#10;&#10;            if (itemSelectScreen == null)&#10;            {&#10;                itemSelectScreen = FindObjectOfType&lt;ItemSelectScreen&gt;();&#10;            }&#10;&#10;            if (crossfade == null)&#10;            {&#10;                crossfade = FindObjectOfType&lt;NESCrossfade&gt;();&#10;            }&#10;&#10;            // Log any missing components&#10;            if (levelSelector == null)&#10;            {&#10;                Debug.LogError(&quot;[LevelSelectionManager] LevelSelector not found in the scene.&quot;);&#10;            }&#10;&#10;            if (itemSelectScreen == null)&#10;            {&#10;                Debug.LogError(&quot;[LevelSelectionManager] ItemSelectScreen not found in the scene.&quot;);&#10;            }&#10;&#10;            if (crossfade == null)&#10;            {&#10;                Debug.LogError(&quot;[LevelSelectionManager] NESCrossfade not found in the scene.&quot;);&#10;            }&#10;        }&#10;&#10;        private void AutoDiscoverLevelObjects()&#10;        {&#10;            _levelGameObjects.Clear();&#10;&#10;            // Find all GameObjects with LevelPoint components in the scene&#10;            LevelPoint[] allLevelPoints = FindObjectsByType&lt;LevelPoint&gt;(FindObjectsSortMode.None);&#10;&#10;            Debug.Log($&quot;[LevelSelectionManager] Auto-discovered {allLevelPoints.Length} LevelPoint components&quot;);&#10;&#10;            foreach (LevelPoint levelPoint in allLevelPoints)&#10;            {&#10;                _levelGameObjects.Add(levelPoint.gameObject);&#10;            }&#10;&#10;            // Sort by name or position for consistent ordering&#10;            _levelGameObjects.Sort((a, b) =&gt; string.Compare(a.name, b.name, System.StringComparison.Ordinal));&#10;&#10;            Debug.Log($&quot;[LevelSelectionManager] After sorting: {_levelGameObjects.Count} level objects&quot;);&#10;        }&#10;&#10;        private void LoadLevelProgressFromGameData()&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update unlock status based on game data&#10;            for (int i = 0; i &lt; _levelData.Count; i++)&#10;            {&#10;                LevelData level = _levelData[i];&#10;                level.isUnlocked = gameData.unlockedLevels.Contains(level.levelName);&#10;&#10;                if (gameData.levelCompleted.TryGetValue(level.levelName, out bool completed))&#10;                {&#10;                    level.isCompleted = completed;&#10;                }&#10;&#10;                if (gameData.levelBestTimes.TryGetValue(level.levelName, out float bestTime))&#10;                {&#10;                    level.bestTime = bestTime;&#10;                }&#10;            }&#10;        }&#10;&#10;        private void OnNavigate(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || levelSelector == null)&#10;            {&#10;                Debug.Log($&quot;[LevelSelectionManager] Navigate blocked - IsActive: {IsActive}, levelSelector: {levelSelector != null}&quot;);&#10;                return;&#10;            }&#10;&#10;            Vector2 direction = context.ReadValue&lt;Vector2&gt;();&#10;            Debug.Log($&quot;[LevelSelectionManager] Navigate input received: {direction}&quot;);&#10;&#10;            levelSelector.Navigate(direction);&#10;            SaveSelectedLevel();&#10;        }&#10;&#10;        private void OnConfirm(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || levelSelector == null) return;&#10;&#10;            levelSelector.SelectCurrentLevel();&#10;        }&#10;&#10;        private void SaveSelectedLevel()&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = levelSelector.CurrentIndex;&#10;                _gameDataService?.SaveData();&#10;            }&#10;        }&#10;&#10;        public void ActivateLevelSelection()&#10;        {&#10;            IsActive = true;&#10;            gameObject.SetActive(true);&#10;            Debug.Log($&quot;[LevelSelectionManager] Level selection activated. Level count: {_levelData?.Count ?? 0}&quot;);&#10;        }&#10;&#10;        public void DeactivateLevelSelection()&#10;        {&#10;            IsActive = false;&#10;            gameObject.SetActive(false);&#10;        }&#10;&#10;        // Debug method to check system status&#10;        [ContextMenu(&quot;Debug Level Selection Status&quot;)]&#10;        public void DebugStatus()&#10;        {&#10;            Debug.Log($&quot;=== Level Selection Debug Status ===&quot;);&#10;            Debug.Log($&quot;IsActive: {IsActive}&quot;);&#10;            Debug.Log($&quot;Navigate Action Assigned: {navigateAction != null}&quot;);&#10;            Debug.Log($&quot;Submit Action Assigned: {submitAction != null}&quot;);&#10;            Debug.Log($&quot;Level Selector Assigned: {levelSelector != null}&quot;);&#10;            Debug.Log($&quot;Level Data Count: {_levelData?.Count ?? 0}&quot;);&#10;            Debug.Log($&quot;Level GameObjects Count: {_levelGameObjects.Count}&quot;);&#10;&#10;            if (levelSelector != null)&#10;            {&#10;                Debug.Log($&quot;Selector Object Assigned: {levelSelector.selectorObject != null}&quot;);&#10;                Debug.Log($&quot;Current Index: {levelSelector.CurrentIndex}&quot;);&#10;                Debug.Log($&quot;Is Moving: {levelSelector.IsMoving}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent levelEvent)&#10;        {&#10;            LevelData selectedLevel = _levelData.FirstOrDefault(l =&gt; l.levelName == levelEvent.LevelName);&#10;            if (selectedLevel == null) return;&#10;&#10;            // Update current level in game data&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.currentLevel = selectedLevel.levelName;&#10;                gameData.selectedLevelIndex = levelEvent.LevelIndex;&#10;                _gameDataService?.SaveData();&#10;            }&#10;&#10;            // Show item select screen&#10;            _eventBus?.Publish(new ItemSelectScreenRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = selectedLevel.levelName&#10;            });&#10;&#10;            itemSelectScreen?.ShowItemSelect(selectedLevel.levelName, selectedLevel.sceneName);&#10;        }&#10;&#10;        private void OnLevelLoadRequested(LevelLoadRequestedEvent loadEvent)&#10;        {&#10;            // Start crossfade and load scene&#10;            crossfade?.FadeOutAndIn(&#10;                () =&gt;&#10;                {&#10;                    // Load the scene&#10;                    SceneManager.LoadScene(loadEvent.SceneName);&#10;                },&#10;                () =&gt;&#10;                {&#10;                    // Publish level started event&#10;                    _eventBus?.Publish(new LevelStartedEvent&#10;                    {&#10;                        Timestamp = Time.time,&#10;                        LevelName = loadEvent.LevelName&#10;                    });&#10;                }&#10;            );&#10;        }&#10;&#10;        private void OnLevelCompleted(LevelCompletedEvent completedEvent)&#10;        {&#10;            // Update level completion status and unlock next level&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Mark level as completed&#10;            gameData.levelCompleted[completedEvent.LevelName] = true;&#10;&#10;            // Update best time&#10;            if (!gameData.levelBestTimes.ContainsKey(completedEvent.LevelName) ||&#10;                completedEvent.CompletionTime &lt; gameData.levelBestTimes[completedEvent.LevelName])&#10;            {&#10;                gameData.levelBestTimes[completedEvent.LevelName] = completedEvent.CompletionTime;&#10;            }&#10;&#10;            // Unlock next level&#10;            int completedIndex = _levelData.FindIndex(l =&gt; l.levelName == completedEvent.LevelName);&#10;            if (completedIndex &gt;= 0 &amp;&amp; completedIndex + 1 &lt; _levelData.Count)&#10;            {&#10;                string nextLevelName = _levelData[completedIndex + 1].levelName;&#10;                if (!gameData.unlockedLevels.Contains(nextLevelName))&#10;                {&#10;                    gameData.unlockedLevels.Add(nextLevelName);&#10;                }&#10;            }&#10;&#10;            _gameDataService?.SaveData();&#10;&#10;            // Refresh level data if we're still in level selection&#10;            if (IsActive)&#10;            {&#10;                LoadLevelProgressFromGameData();&#10;                levelSelector?.Initialize(_levelData, _levelPoints, levelSelector.CurrentIndex);&#10;            }&#10;        }&#10;&#10;        public List&lt;LevelData&gt; GetLevelData() =&gt; _levelData;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelector.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelector.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using Core.Events;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class LevelSelector : MonoBehaviour&#10;    {&#10;        [Header(&quot;Selector Configuration&quot;)] public GameObject selectorObject;&#10;&#10;        public float moveSpeed = 5f;&#10;        public AudioClip navigationSound;&#10;        public AudioClip selectionSound;&#10;        public AudioClip lockedSound;&#10;&#10;        [Header(&quot;Grid Navigation&quot;)] public int gridWidth = 4;&#10;&#10;        public float snapThreshold = 0.1f;&#10;        private AudioSource _audioSource;&#10;&#10;        private List&lt;LevelData&gt; _availableLevels;&#10;        private IEventBus _eventBus;&#10;        private List&lt;LevelPoint&gt; _levelPoints;&#10;        private Vector3 _targetPosition;&#10;&#10;        public int CurrentIndex { get; private set; }&#10;&#10;        public LevelData CurrentLevel =&gt; _availableLevels?[CurrentIndex];&#10;        public bool IsMoving { get; private set; }&#10;&#10;        private void Awake()&#10;        {&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (_audioSource == null)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (IsMoving &amp;&amp; selectorObject != null)&#10;            {&#10;                selectorObject.transform.position = Vector3.MoveTowards(&#10;                    selectorObject.transform.position,&#10;                    _targetPosition,&#10;                    moveSpeed * Time.deltaTime&#10;                );&#10;&#10;                if (Vector3.Distance(selectorObject.transform.position, _targetPosition) &lt; snapThreshold)&#10;                {&#10;                    selectorObject.transform.position = _targetPosition;&#10;                    IsMoving = false;&#10;                }&#10;            }&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus)&#10;        {&#10;            _eventBus = eventBus;&#10;        }&#10;&#10;        public void Initialize(List&lt;LevelData&gt; levels, List&lt;LevelPoint&gt; levelPoints, int selectedIndex = 0)&#10;        {&#10;            _availableLevels = levels;&#10;            _levelPoints = levelPoints;&#10;            CurrentIndex = Mathf.Clamp(selectedIndex, 0, levels.Count - 1);&#10;&#10;            UpdateLevelStates();&#10;            MoveToCurrentLevel(true); // Instant move on initialization&#10;        }&#10;&#10;        public void Navigate(Vector2 direction)&#10;        {&#10;            if (IsMoving || _availableLevels == null || _availableLevels.Count == 0)&#10;                return;&#10;&#10;            int newIndex = CalculateNewIndex(direction);&#10;&#10;            if (newIndex != CurrentIndex &amp;&amp; newIndex &gt;= 0 &amp;&amp; newIndex &lt; _availableLevels.Count)&#10;            {&#10;                int previousIndex = CurrentIndex;&#10;                CurrentIndex = newIndex;&#10;&#10;                PlaySound(navigationSound);&#10;                UpdateSelection();&#10;                MoveToCurrentLevel();&#10;&#10;                _eventBus?.Publish(new LevelNavigationEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    PreviousIndex = previousIndex,&#10;                    NewIndex = CurrentIndex,&#10;                    Direction = direction&#10;                });&#10;            }&#10;        }&#10;&#10;        private int CalculateNewIndex(Vector2 direction)&#10;        {&#10;            // Adventure Island III style navigation - mostly horizontal with some vertical&#10;            int currentRow = CurrentIndex / gridWidth;&#10;            int currentCol = CurrentIndex % gridWidth;&#10;&#10;            if (Mathf.Abs(direction.x) &gt; Mathf.Abs(direction.y))&#10;            {&#10;                // Horizontal movement&#10;                if (direction.x &gt; 0) // Right&#10;                {&#10;                    return Mathf.Min(CurrentIndex + 1, _availableLevels.Count - 1);&#10;                }&#10;&#10;                // Left&#10;                return Mathf.Max(CurrentIndex - 1, 0);&#10;            }&#10;&#10;            // Vertical movement&#10;            if (direction.y &gt; 0) // Up&#10;            {&#10;                int newIndex = CurrentIndex - gridWidth;&#10;                return newIndex &gt;= 0 ? newIndex : CurrentIndex;&#10;            }&#10;            else // Down&#10;            {&#10;                int newIndex = CurrentIndex + gridWidth;&#10;                return newIndex &lt; _availableLevels.Count ? newIndex : CurrentIndex;&#10;            }&#10;        }&#10;&#10;        public void SelectCurrentLevel()&#10;        {&#10;            if (_availableLevels == null || CurrentIndex &gt;= _availableLevels.Count)&#10;                return;&#10;&#10;            LevelData selectedLevel = _availableLevels[CurrentIndex];&#10;&#10;            if (!selectedLevel.isUnlocked)&#10;            {&#10;                PlaySound(lockedSound);&#10;                return;&#10;            }&#10;&#10;            PlaySound(selectionSound);&#10;&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = selectedLevel.levelName,&#10;                LevelIndex = CurrentIndex&#10;            });&#10;        }&#10;&#10;        private void UpdateSelection()&#10;        {&#10;            for (int i = 0; i &lt; _levelPoints.Count; i++)&#10;            {&#10;                if (_levelPoints[i] != null)&#10;                {&#10;                    _levelPoints[i].SetSelected(i == CurrentIndex);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void UpdateLevelStates()&#10;        {&#10;            for (int i = 0; i &lt; _levelPoints.Count &amp;&amp; i &lt; _availableLevels.Count; i++)&#10;            {&#10;                if (_levelPoints[i] != null)&#10;                {&#10;                    _levelPoints[i].SetUnlocked(_availableLevels[i].isUnlocked);&#10;                    _levelPoints[i].SetSelected(i == CurrentIndex);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void MoveToCurrentLevel(bool instant = false)&#10;        {&#10;            if (CurrentIndex &gt;= _levelPoints.Count || _levelPoints[CurrentIndex] == null)&#10;                return;&#10;&#10;            _targetPosition = _levelPoints[CurrentIndex].transform.position;&#10;&#10;            if (instant)&#10;            {&#10;                selectorObject.transform.position = _targetPosition;&#10;                IsMoving = false;&#10;            }&#10;            else&#10;            {&#10;                IsMoving = true;&#10;            }&#10;        }&#10;&#10;        private void PlaySound(AudioClip clip)&#10;        {&#10;            if (_audioSource &amp;&amp; clip)&#10;            {&#10;                _audioSource.PlayOneShot(clip);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using Core.Events;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class LevelSelector : MonoBehaviour&#10;    {&#10;        [Header(&quot;Selector Configuration&quot;)] public GameObject selectorObject;&#10;&#10;        public float moveSpeed = 5f;&#10;        public AudioClip navigationSound;&#10;        public AudioClip selectionSound;&#10;        public AudioClip lockedSound;&#10;&#10;        [Header(&quot;Grid Navigation&quot;)] public int gridWidth = 4;&#10;&#10;        public float snapThreshold = 0.1f;&#10;        private AudioSource _audioSource;&#10;&#10;        private List&lt;LevelData&gt; _availableLevels;&#10;        private IEventBus _eventBus;&#10;        private List&lt;LevelPoint&gt; _levelPoints;&#10;        private Vector3 _targetPosition;&#10;&#10;        public int CurrentIndex { get; private set; }&#10;&#10;        public LevelData CurrentLevel =&gt; _availableLevels?[CurrentIndex];&#10;        public bool IsMoving { get; private set; }&#10;&#10;        private void Awake()&#10;        {&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (_audioSource == null)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (IsMoving &amp;&amp; selectorObject != null)&#10;            {&#10;                selectorObject.transform.position = Vector3.MoveTowards(&#10;                    selectorObject.transform.position,&#10;                    _targetPosition,&#10;                    moveSpeed * Time.deltaTime&#10;                );&#10;&#10;                if (Vector3.Distance(selectorObject.transform.position, _targetPosition) &lt; snapThreshold)&#10;                {&#10;                    selectorObject.transform.position = _targetPosition;&#10;                    IsMoving = false;&#10;                }&#10;            }&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus)&#10;        {&#10;            _eventBus = eventBus;&#10;        }&#10;&#10;        public void Initialize(List&lt;LevelData&gt; levels, List&lt;LevelPoint&gt; levelPoints, int selectedIndex = 0)&#10;        {&#10;            _availableLevels = levels;&#10;            _levelPoints = levelPoints;&#10;            CurrentIndex = Mathf.Clamp(selectedIndex, 0, levels.Count - 1);&#10;&#10;            UpdateLevelStates();&#10;            MoveToCurrentLevel(true); // Instant move on initialization&#10;        }&#10;&#10;        public void Navigate(Vector2 direction)&#10;        {&#10;            Debug.Log($&quot;[LevelSelector] Navigate called with direction: {direction}&quot;);&#10;            Debug.Log($&quot;[LevelSelector] IsMoving: {IsMoving}, AvailableLevels count: {_availableLevels?.Count ?? 0}&quot;);&#10;            &#10;            if (IsMoving || _availableLevels == null || _availableLevels.Count == 0)&#10;            {&#10;                Debug.Log(&quot;[LevelSelector] Navigate blocked - IsMoving or no levels available&quot;);&#10;                return;&#10;            }&#10;&#10;            int newIndex = CalculateNewIndex(direction);&#10;            Debug.Log($&quot;[LevelSelector] Current index: {CurrentIndex}, New index: {newIndex}&quot;);&#10;&#10;            if (newIndex != CurrentIndex &amp;&amp; newIndex &gt;= 0 &amp;&amp; newIndex &lt; _availableLevels.Count)&#10;            {&#10;                int previousIndex = CurrentIndex;&#10;                CurrentIndex = newIndex;&#10;&#10;                Debug.Log($&quot;[LevelSelector] Moving from index {previousIndex} to {CurrentIndex}&quot;);&#10;                &#10;                PlaySound(navigationSound);&#10;                UpdateSelection();&#10;                MoveToCurrentLevel();&#10;&#10;                _eventBus?.Publish(new LevelNavigationEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    PreviousIndex = previousIndex,&#10;                    NewIndex = CurrentIndex,&#10;                    Direction = direction&#10;                });&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[LevelSelector] Navigation blocked - same index or out of bounds&quot;);&#10;            }&#10;        }&#10;&#10;        private int CalculateNewIndex(Vector2 direction)&#10;        {&#10;            // Adventure Island III style navigation - mostly horizontal with some vertical&#10;            int currentRow = CurrentIndex / gridWidth;&#10;            int currentCol = CurrentIndex % gridWidth;&#10;&#10;            if (Mathf.Abs(direction.x) &gt; Mathf.Abs(direction.y))&#10;            {&#10;                // Horizontal movement&#10;                if (direction.x &gt; 0) // Right&#10;                {&#10;                    return Mathf.Min(CurrentIndex + 1, _availableLevels.Count - 1);&#10;                }&#10;&#10;                // Left&#10;                return Mathf.Max(CurrentIndex - 1, 0);&#10;            }&#10;&#10;            // Vertical movement&#10;            if (direction.y &gt; 0) // Up&#10;            {&#10;                int newIndex = CurrentIndex - gridWidth;&#10;                return newIndex &gt;= 0 ? newIndex : CurrentIndex;&#10;            }&#10;            else // Down&#10;            {&#10;                int newIndex = CurrentIndex + gridWidth;&#10;                return newIndex &lt; _availableLevels.Count ? newIndex : CurrentIndex;&#10;            }&#10;        }&#10;&#10;        public void SelectCurrentLevel()&#10;        {&#10;            if (_availableLevels == null || CurrentIndex &gt;= _availableLevels.Count)&#10;                return;&#10;&#10;            LevelData selectedLevel = _availableLevels[CurrentIndex];&#10;&#10;            if (!selectedLevel.isUnlocked)&#10;            {&#10;                PlaySound(lockedSound);&#10;                return;&#10;            }&#10;&#10;            PlaySound(selectionSound);&#10;&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = selectedLevel.levelName,&#10;                LevelIndex = CurrentIndex&#10;            });&#10;        }&#10;&#10;        private void UpdateSelection()&#10;        {&#10;            for (int i = 0; i &lt; _levelPoints.Count; i++)&#10;            {&#10;                if (_levelPoints[i] != null)&#10;                {&#10;                    _levelPoints[i].SetSelected(i == CurrentIndex);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void UpdateLevelStates()&#10;        {&#10;            for (int i = 0; i &lt; _levelPoints.Count &amp;&amp; i &lt; _availableLevels.Count; i++)&#10;            {&#10;                if (_levelPoints[i] != null)&#10;                {&#10;                    _levelPoints[i].SetUnlocked(_availableLevels[i].isUnlocked);&#10;                    _levelPoints[i].SetSelected(i == CurrentIndex);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void MoveToCurrentLevel(bool instant = false)&#10;        {&#10;            if (CurrentIndex &gt;= _levelPoints.Count || _levelPoints[CurrentIndex] == null)&#10;                return;&#10;&#10;            _targetPosition = _levelPoints[CurrentIndex].transform.position;&#10;&#10;            if (instant)&#10;            {&#10;                selectorObject.transform.position = _targetPosition;&#10;                IsMoving = false;&#10;            }&#10;            else&#10;            {&#10;                IsMoving = true;&#10;            }&#10;        }&#10;&#10;        private void PlaySound(AudioClip clip)&#10;        {&#10;            if (_audioSource &amp;&amp; clip)&#10;            {&#10;                _audioSource.PlayOneShot(clip);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/NESCrossfade.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/NESCrossfade.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class NESCrossfade : MonoBehaviour&#10;    {&#10;        [Header(&quot;Crossfade Configuration&quot;)] &#10;        public Image fadeImage;&#10;        public float fadeDuration = 1f;&#10;        public Color fadeColor = Color.black;&#10;        public AnimationCurve fadeCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);&#10;&#10;        [Header(&quot;NES Style Effect&quot;)] &#10;        public bool useNESEffect = true;&#10;        public Color[] nesColors = { Color.black, new(0.2f, 0.2f, 0.3f), new(0.1f, 0.1f, 0.2f) };&#10;        public float colorFlickerSpeed = 10f;&#10;        &#10;        private LevelSelectionConfig _config;&#10;        private bool _isFading;&#10;        private Action _onFadeComplete;&#10;&#10;        private void Awake()&#10;        {&#10;            SetupFadeImage();&#10;            // Start completely transparent (hidden)&#10;            SetAlpha(0f);&#10;            &#10;            Debug.Log(&quot;[NESCrossfade] Initialized and hidden&quot;);&#10;        }&#10;&#10;        private void SetupFadeImage()&#10;        {&#10;            if (fadeImage == null)&#10;            {&#10;                // Create fade image if not assigned&#10;                GameObject fadeGO = new(&quot;FadeImage&quot;);&#10;                fadeGO.transform.SetParent(transform, false);&#10;&#10;                // Ensure we have a Canvas component&#10;                Canvas canvas = GetComponentInParent&lt;Canvas&gt;();&#10;                if (canvas == null)&#10;                {&#10;                    canvas = gameObject.AddComponent&lt;Canvas&gt;();&#10;                    canvas.sortingOrder = 1000;&#10;                    canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;                    &#10;                    // Add CanvasScaler for proper scaling&#10;                    CanvasScaler scaler = gameObject.AddComponent&lt;CanvasScaler&gt;();&#10;                    scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;&#10;                    scaler.referenceResolution = new Vector2(1920, 1080);&#10;                    &#10;                    // Add GraphicRaycaster&#10;                    gameObject.AddComponent&lt;GraphicRaycaster&gt;();&#10;                }&#10;&#10;                fadeImage = fadeGO.AddComponent&lt;Image&gt;();&#10;                RectTransform rect = fadeImage.rectTransform;&#10;                rect.anchorMin = Vector2.zero;&#10;                rect.anchorMax = Vector2.one;&#10;                rect.sizeDelta = Vector2.zero;&#10;                rect.anchoredPosition = Vector2.zero;&#10;                &#10;                // Set initial color&#10;                fadeImage.color = new Color(fadeColor.r, fadeColor.g, fadeColor.b, 0f);&#10;            }&#10;            &#10;            // Ensure the image covers the full screen&#10;            if (fadeImage != null)&#10;            {&#10;                RectTransform rect = fadeImage.rectTransform;&#10;                rect.anchorMin = Vector2.zero;&#10;                rect.anchorMax = Vector2.one;&#10;                rect.sizeDelta = Vector2.zero;&#10;                rect.anchoredPosition = Vector2.zero;&#10;            }&#10;        }&#10;&#10;        public void SetConfig(LevelSelectionConfig config)&#10;        {&#10;            _config = config;&#10;&#10;            // Update fade settings from config&#10;            if (_config != null)&#10;            {&#10;                fadeDuration = _config.transitionDuration;&#10;                nesColors = _config.nesTransitionColors;&#10;            }&#10;        }&#10;&#10;        public void FadeOut(Action onComplete = null)&#10;        {&#10;            if (_isFading) return;&#10;&#10;            _onFadeComplete = onComplete;&#10;            StartCoroutine(FadeCoroutine(0f, 1f));&#10;        }&#10;&#10;        public void FadeIn(Action onComplete = null)&#10;        {&#10;            if (_isFading) return;&#10;&#10;            _onFadeComplete = onComplete;&#10;            StartCoroutine(FadeCoroutine(1f, 0f));&#10;        }&#10;&#10;        public void FadeOutAndIn(Action onMiddle = null, Action onComplete = null)&#10;        {&#10;            if (_isFading) return;&#10;&#10;            StartCoroutine(FadeOutAndInCoroutine(onMiddle, onComplete));&#10;        }&#10;&#10;        private IEnumerator FadeCoroutine(float from, float to)&#10;        {&#10;            _isFading = true;&#10;            float elapsed = 0f;&#10;&#10;            while (elapsed &lt; fadeDuration)&#10;            {&#10;                elapsed += Time.deltaTime;&#10;                float progress = elapsed / fadeDuration;&#10;                float curveValue = fadeCurve.Evaluate(progress);&#10;                float alpha = Mathf.Lerp(from, to, curveValue);&#10;&#10;                if (useNESEffect)&#10;                {&#10;                    SetNESStyleAlpha(alpha);&#10;                }&#10;                else&#10;                {&#10;                    SetAlpha(alpha);&#10;                }&#10;&#10;                yield return null;&#10;            }&#10;&#10;            if (useNESEffect)&#10;            {&#10;                SetNESStyleAlpha(to);&#10;            }&#10;            else&#10;            {&#10;                SetAlpha(to);&#10;            }&#10;&#10;            _isFading = false;&#10;            _onFadeComplete?.Invoke();&#10;            _onFadeComplete = null;&#10;        }&#10;&#10;        private IEnumerator FadeOutAndInCoroutine(Action onMiddle, Action onComplete)&#10;        {&#10;            // Fade out&#10;            yield return StartCoroutine(FadeCoroutine(0f, 1f));&#10;&#10;            // Middle action (like loading scene)&#10;            onMiddle?.Invoke();&#10;&#10;            // Small delay to ensure scene is loaded&#10;            yield return new WaitForSeconds(0.1f);&#10;&#10;            // Fade in&#10;            yield return StartCoroutine(FadeCoroutine(1f, 0f));&#10;&#10;            onComplete?.Invoke();&#10;        }&#10;&#10;        private void SetAlpha(float alpha)&#10;        {&#10;            if (fadeImage != null)&#10;            {&#10;                Color color = fadeColor;&#10;                color.a = alpha;&#10;                fadeImage.color = color;&#10;            }&#10;        }&#10;&#10;        private void SetNESStyleAlpha(float alpha)&#10;        {&#10;            if (fadeImage == null || nesColors == null || nesColors.Length == 0) return;&#10;&#10;            // Create NES-style flickering effect&#10;            int colorIndex = Mathf.FloorToInt(Time.time * colorFlickerSpeed) % nesColors.Length;&#10;            Color nesColor = nesColors[colorIndex];&#10;            nesColor.a = alpha;&#10;            fadeImage.color = nesColor;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Set fade color programmatically&#10;        /// &lt;/summary&gt;&#10;        public void SetFadeColor(Color color)&#10;        {&#10;            fadeColor = color;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Get current fade progress (0 = transparent, 1 = opaque)&#10;        /// &lt;/summary&gt;&#10;        public float GetFadeProgress() =&gt; fadeImage ? fadeImage.color.a : 0f;&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Instantly set fade to specific alpha without animation&#10;        /// &lt;/summary&gt;&#10;        public void SetInstantFade(float alpha)&#10;        {&#10;            if (useNESEffect)&#10;            {&#10;                SetNESStyleAlpha(alpha);&#10;            }&#10;            else&#10;            {&#10;                SetAlpha(alpha);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Check if currently fading&#10;        /// &lt;/summary&gt;&#10;        public bool IsFading =&gt; _isFading;&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Show the crossfade immediately (useful for scene start)&#10;        /// &lt;/summary&gt;&#10;        public void Show()&#10;        {&#10;            SetAlpha(1f);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Hide the crossfade immediately&#10;        /// &lt;/summary&gt;&#10;        public void Hide()&#10;        {&#10;            SetAlpha(0f);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class NESCrossfade : MonoBehaviour&#10;    {&#10;        [Header(&quot;Crossfade Configuration&quot;)] &#10;        public Image fadeImage;&#10;        public float fadeDuration = 1f;&#10;        public Color fadeColor = Color.black;&#10;        public AnimationCurve fadeCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);&#10;&#10;        [Header(&quot;NES Style Effect&quot;)] &#10;        public bool useNESEffect = true;&#10;        public Color[] nesColors = { Color.black, new(0.2f, 0.2f, 0.3f), new(0.1f, 0.1f, 0.2f) };&#10;        public float colorFlickerSpeed = 10f;&#10;        &#10;        private LevelSelectionConfig _config;&#10;        private bool _isFading;&#10;        private Action _onFadeComplete;&#10;&#10;        private void Awake()&#10;        {&#10;            SetupFadeImage();&#10;            // Start with image disabled (hidden)&#10;            if (fadeImage != null)&#10;            {&#10;                fadeImage.enabled = false;&#10;            }&#10;            &#10;            Debug.Log(&quot;[NESCrossfade] Initialized with hidden image&quot;);&#10;        }&#10;&#10;        private void SetupFadeImage()&#10;        {&#10;            if (fadeImage == null)&#10;            {&#10;                // Create fade image if not assigned&#10;                GameObject fadeGO = new(&quot;FadeImage&quot;);&#10;                fadeGO.transform.SetParent(transform, false);&#10;&#10;                // Ensure we have a Canvas component&#10;                Canvas canvas = GetComponentInParent&lt;Canvas&gt;();&#10;                if (canvas == null)&#10;                {&#10;                    canvas = gameObject.AddComponent&lt;Canvas&gt;();&#10;                    canvas.sortingOrder = 1000;&#10;                    canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;                    &#10;                    // Add CanvasScaler for proper scaling&#10;                    CanvasScaler scaler = gameObject.AddComponent&lt;CanvasScaler&gt;();&#10;                    scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;&#10;                    scaler.referenceResolution = new Vector2(1920, 1080);&#10;                    &#10;                    // Add GraphicRaycaster&#10;                    gameObject.AddComponent&lt;GraphicRaycaster&gt;();&#10;                }&#10;&#10;                fadeImage = fadeGO.AddComponent&lt;Image&gt;();&#10;                RectTransform rect = fadeImage.rectTransform;&#10;                rect.anchorMin = Vector2.zero;&#10;                rect.anchorMax = Vector2.one;&#10;                rect.sizeDelta = Vector2.zero;&#10;                rect.anchoredPosition = Vector2.zero;&#10;                &#10;                // Set initial color with full alpha (but start disabled)&#10;                fadeImage.color = new Color(fadeColor.r, fadeColor.g, fadeColor.b, 1f);&#10;                fadeImage.enabled = false;&#10;            }&#10;            &#10;            // Ensure the image covers the full screen&#10;            if (fadeImage != null)&#10;            {&#10;                RectTransform rect = fadeImage.rectTransform;&#10;                rect.anchorMin = Vector2.zero;&#10;                rect.anchorMax = Vector2.one;&#10;                rect.sizeDelta = Vector2.zero;&#10;                rect.anchoredPosition = Vector2.zero;&#10;            }&#10;        }&#10;&#10;        public void SetConfig(LevelSelectionConfig config)&#10;        {&#10;            _config = config;&#10;&#10;            // Update fade settings from config&#10;            if (_config != null)&#10;            {&#10;                fadeDuration = _config.transitionDuration;&#10;                nesColors = _config.nesTransitionColors;&#10;            }&#10;        }&#10;&#10;        public void FadeOut(Action onComplete = null)&#10;        {&#10;            if (_isFading) return;&#10;&#10;            _onFadeComplete = onComplete;&#10;            StartCoroutine(FadeCoroutine(0f, 1f));&#10;        }&#10;&#10;        public void FadeIn(Action onComplete = null)&#10;        {&#10;            if (_isFading) return;&#10;&#10;            _onFadeComplete = onComplete;&#10;            StartCoroutine(FadeCoroutine(1f, 0f));&#10;        }&#10;&#10;        public void FadeOutAndIn(Action onMiddle = null, Action onComplete = null)&#10;        {&#10;            if (_isFading) return;&#10;&#10;            StartCoroutine(FadeOutAndInCoroutine(onMiddle, onComplete));&#10;        }&#10;&#10;        private IEnumerator FadeCoroutine(float from, float to)&#10;        {&#10;            _isFading = true;&#10;            &#10;            // Enable image when starting fade&#10;            if (fadeImage != null)&#10;            {&#10;                fadeImage.enabled = true;&#10;            }&#10;            &#10;            float elapsed = 0f;&#10;&#10;            while (elapsed &lt; fadeDuration)&#10;            {&#10;                elapsed += Time.deltaTime;&#10;                float progress = elapsed / fadeDuration;&#10;                float curveValue = fadeCurve.Evaluate(progress);&#10;                float alpha = Mathf.Lerp(from, to, curveValue);&#10;&#10;                if (useNESEffect)&#10;                {&#10;                    SetNESStyleAlpha(alpha);&#10;                }&#10;                else&#10;                {&#10;                    SetAlpha(alpha);&#10;                }&#10;&#10;                yield return null;&#10;            }&#10;&#10;            if (useNESEffect)&#10;            {&#10;                SetNESStyleAlpha(to);&#10;            }&#10;            else&#10;            {&#10;                SetAlpha(to);&#10;            }&#10;&#10;            // Hide image if fade is complete (alpha = 0)&#10;            if (to &lt;= 0f &amp;&amp; fadeImage != null)&#10;            {&#10;                fadeImage.enabled = false;&#10;            }&#10;&#10;            _isFading = false;&#10;            _onFadeComplete?.Invoke();&#10;            _onFadeComplete = null;&#10;        }&#10;&#10;        private IEnumerator FadeOutAndInCoroutine(Action onMiddle, Action onComplete)&#10;        {&#10;            // Fade out&#10;            yield return StartCoroutine(FadeCoroutine(0f, 1f));&#10;&#10;            // Middle action (like loading scene)&#10;            onMiddle?.Invoke();&#10;&#10;            // Small delay to ensure scene is loaded&#10;            yield return new WaitForSeconds(0.1f);&#10;&#10;            // Fade in&#10;            yield return StartCoroutine(FadeCoroutine(1f, 0f));&#10;&#10;            onComplete?.Invoke();&#10;        }&#10;&#10;        private void SetAlpha(float alpha)&#10;        {&#10;            if (fadeImage != null)&#10;            {&#10;                Color color = fadeColor;&#10;                color.a = alpha;&#10;                fadeImage.color = color;&#10;            }&#10;        }&#10;&#10;        private void SetNESStyleAlpha(float alpha)&#10;        {&#10;            if (fadeImage == null || nesColors == null || nesColors.Length == 0) return;&#10;&#10;            // Create NES-style flickering effect&#10;            int colorIndex = Mathf.FloorToInt(Time.time * colorFlickerSpeed) % nesColors.Length;&#10;            Color nesColor = nesColors[colorIndex];&#10;            nesColor.a = alpha;&#10;            fadeImage.color = nesColor;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Set fade color programmatically&#10;        /// &lt;/summary&gt;&#10;        public void SetFadeColor(Color color)&#10;        {&#10;            fadeColor = color;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Show the crossfade immediately (useful for scene start)&#10;        /// &lt;/summary&gt;&#10;        public void Show()&#10;        {&#10;            if (fadeImage != null)&#10;            {&#10;                fadeImage.enabled = true;&#10;                SetAlpha(1f);&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        ///     Hide the crossfade immediately&#10;        /// &lt;/summary&gt;&#10;        public void Hide()&#10;        {&#10;            if (fadeImage != null)&#10;            {&#10;                fadeImage.enabled = false;&#10;                SetAlpha(0f);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Get current fade progress (0 = hidden, 1 = fully visible)&#10;        /// &lt;/summary&gt;&#10;        public float GetFadeProgress() =&gt; fadeImage &amp;&amp; fadeImage.enabled ? fadeImage.color.a : 0f;&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Instantly set fade to specific alpha without animation&#10;        /// &lt;/summary&gt;&#10;        public void SetInstantFade(float alpha)&#10;        {&#10;            if (useNESEffect)&#10;            {&#10;                SetNESStyleAlpha(alpha);&#10;            }&#10;            else&#10;            {&#10;                SetAlpha(alpha);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Check if currently fading&#10;        /// &lt;/summary&gt;&#10;        public bool IsFading =&gt; _isFading;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/README.md" />
              <option name="originalContent" value="# Level Selection System Setup Guide&#10;&#10;## Overview&#10;This level selection system integrates with your existing GameFlowManager, GameDataCoordinator, and event system to provide a complete level selection experience with NES-style navigation and transitions.&#10;&#10;## Components Created&#10;&#10;### Core Components:&#10;1. **LevelData.cs** - Data structures and builder/factory patterns for level information&#10;2. **LevelPoint.cs** - Component for level GameObjects with visual feedback&#10;3. **LevelSelector.cs** - Handles navigation between levels and selector movement&#10;4. **LevelSelectionManager.cs** - Main coordinator that manages the entire system&#10;5. **LevelSelectionDirector.cs** - Director pattern for building level data&#10;6. **ItemSelectScreen.cs** - Shows the &quot;item select screen&quot; before level starts&#10;7. **NESCrossfade.cs** - NES-style crossfade transitions between scenes&#10;&#10;## Setup Instructions&#10; for &#10;### 1. Scene Setup&#10;Create a level selection scene with the following hierarchy:&#10;&#10;```&#10;LevelSelectionScene&#10; LevelSelectionManager (with LevelSelectionManager script)&#10; LevelContainer (empty GameObject to hold level points)&#10;    Level_01 (with LevelPoint script)&#10;    Level_02 (with LevelPoint script)&#10;    Level_03 (with LevelPoint script)&#10;    ... (more levels)&#10; Selector (GameObject that moves between levels)&#10; UI Canvas&#10;    ItemSelectScreen (with ItemSelectScreen script)&#10;    CrossfadeOverlay (with NESCrossfade script)&#10; LevelSelector (with LevelSelector script)&#10;```&#10;&#10;### 2. Level Point Configuration&#10;For each level GameObject:&#10;1. Add the **LevelPoint** component&#10;2. Configure:&#10;   - Level Name (e.g., &quot;Level_01&quot;)&#10;   - Display Name (e.g., &quot;Forest Stage&quot;)&#10;   - Scene Name (the actual scene file name)&#10;   - Level Icon (sprite for the level)&#10;   - Icon Renderer (SpriteRenderer for the icon)&#10;   - Lock Renderer (SpriteRenderer for lock overlay)&#10;&#10;### 3. Level Selection Manager Configuration&#10;1. Assign all level GameObjects to the levelGameObjects list&#10;2. Set the levelContainer reference&#10;3. Assign the LevelSelector, ItemSelectScreen, and NESCrossfade components&#10;4. Configure input keys (defaults to arrow keys + Enter)&#10;&#10;### 4. Selector Configuration&#10;1. Assign the selector GameObject (this moves between levels)&#10;2. Set move speed and grid width for navigation&#10;3. Add audio clips for navigation, selection, and locked sounds&#10;&#10;### 5. Item Select Screen Setup&#10;1. Create a UI Image for the item select screen&#10;2. Place your &quot;item select screen.png&quot; sprite in Resources folder&#10;3. Configure display duration and input settings&#10;&#10;### 6. Crossfade Setup&#10;1. Create a UI Image that covers the full screen&#10;2. Configure fade colors and NES-style effect settings&#10;&#10;## Integration with Existing Systems&#10;&#10;### GameData Integration&#10;The system automatically:&#10;- Saves/loads unlocked levels&#10;- Tracks level completion status&#10;- Stores best completion times&#10;- Remembers selected level index&#10;&#10;### Event System Integration&#10;Publishes these events:&#10;- `LevelSelectedEvent` - When a level is chosen&#10;- `LevelNavigationEvent` - When navigating between levels&#10;- `ItemSelectScreenRequestedEvent` - When showing item select&#10;- `LevelLoadRequestedEvent` - When loading a level&#10;- `LevelStartedEvent` - When level begins&#10;- `LevelCompletedEvent` - When level is completed&#10;&#10;### GameFlowManager Integration&#10;- Added `LevelSelection` state to GameState enum&#10;- Handles scene transitions through crossfade system&#10;- Manages game state changes during level selection&#10;&#10;## Usage Example&#10;&#10;```csharp&#10;// From main menu, transition to level selection&#10;gameFlowManager.ChangeState(GameState.LevelSelection);&#10;&#10;// The system will automatically:&#10;// 1. Load unlocked levels from GameData&#10;// 2. Position selector on last selected level&#10;// 3. Handle input for navigation&#10;// 4. Show item select screen on confirmation&#10;// 5. Load the selected level scene with crossfade&#10;```&#10;&#10;## Navigation Controls&#10;- **Arrow Keys**: Navigate between levels (Adventure Island III style)&#10;- **Enter**: Confirm level selection&#10;- **Locked levels**: Play sound and prevent selection&#10;&#10;## Customization Points&#10;- Modify navigation grid layout in LevelSelector&#10;- Customize NES crossfade colors and timing&#10;- Add more visual feedback to level points&#10;- Extend level data with additional properties&#10;- Customize item select screen behavior&#10;&#10;## Factory and Builder Pattern Usage&#10;- **LevelDataFactory**: Creates LevelData from GameObjects&#10;- **LevelDataBuilder**: Fluent builder for LevelData construction&#10;- **LevelSelectionDirector**: Orchestrates level data building&#10;&#10;The system is fully integrated with your existing architecture and ready to use!&#10;" />
              <option name="updatedContent" value="# Level Selection System Setup Guide&#10;&#10;## Overview&#10;This level selection system integrates with your existing GameFlowManager, GameDataCoordinator, and event system to provide a complete level selection experience with NES-style navigation and transitions.&#10;&#10;## Components Created&#10;&#10;### Core Components:&#10;1. **LevelData.cs** - Data structures and builder/factory patterns for level information&#10;2. **LevelPoint.cs** - Component for level GameObjects with visual feedback&#10;3. **LevelSelector.cs** - Handles navigation between levels and selector movement&#10;4. **LevelSelectionManager.cs** - Main coordinator that manages the entire system&#10;5. **LevelSelectionDirector.cs** - Director pattern for building level data&#10;6. **ItemSelectScreen.cs** - Shows the &quot;item select screen&quot; before level starts&#10;7. **NESCrossfade.cs** - NES-style crossfade transitions between scenes&#10;&#10;## Setup Instructions&#10;&#10;### 1. Scene Setup&#10;Create a level selection scene with the following hierarchy:&#10;&#10;**Option A: Child Scope (Recommended)**&#10;```&#10;LevelSelectionScene&#10; GameManager (with GameLifetimeScope)&#10;    LevelSelectionManager (with LevelSelectionLifetimeScope)&#10; LevelContainer (empty GameObject to hold level points)&#10;    Level_01 (with LevelPoint script)&#10;    Level_02 (with LevelPoint script)&#10;    Level_03 (with LevelPoint script)&#10;    ... (more levels)&#10; Selector (GameObject that moves between levels)&#10; UI Canvas&#10;    ItemSelectScreen (with ItemSelectScreen script)&#10;    CrossfadeOverlay (with NESCrossfade script)&#10; LevelSelector (with LevelSelector script)&#10;```&#10;&#10;**Option B: Separate Scopes**&#10;If you need separate scopes, make sure both GameLifetimeScope and LevelSelectionLifetimeScope are at the root level, and the level selection scope will inherit from the game scope.&#10;&#10;### 2. VContainer Setup&#10;- Ensure your main scene has a `GameLifetimeScope` that registers core services&#10;- The `LevelSelectionLifetimeScope` should be either a child of the GameLifetimeScope GameObject or set up to inherit from it&#10;- This allows the level selection components to access `IEventBus`, `IGameDataService`, etc.&#10;&#10;### 3. Level Point Configuration&#10;For each level GameObject:&#10;1. Add the **LevelPoint** component&#10;2. Configure:&#10;   - Level Name (e.g., &quot;Level_01&quot;)&#10;   - Display Name (e.g., &quot;Forest Stage&quot;)&#10;   - Scene Name (the actual scene file name)&#10;   - Level Icon (sprite for the level)&#10;   - Icon Renderer (SpriteRenderer for the icon)&#10;   - Lock Renderer (SpriteRenderer for lock overlay)&#10;&#10;### 4. Level Selection Manager Configuration&#10;1. Assign all level GameObjects to the levelGameObjects list&#10;2. Set the levelContainer reference&#10;3. Assign the LevelSelector, ItemSelectScreen, and NESCrossfade components&#10;4. Configure input keys (defaults to arrow keys + Enter)&#10;&#10;### 5. Selector Configuration&#10;1. Assign the selector GameObject (this moves between levels)&#10;2. Set move speed and grid width for navigation&#10;3. Add audio clips for navigation, selection, and locked sounds&#10;&#10;### 6. Item Select Screen Setup&#10;1. Create a UI Image for the item select screen&#10;2. Place your &quot;item select screen.png&quot; sprite in Resources folder&#10;3. Configure display duration and input settings&#10;&#10;### 7. Crossfade Setup&#10;1. Create a UI Image that covers the full screen&#10;2. Configure fade colors and NES-style effect settings&#10;&#10;## Integration with Existing Systems&#10;&#10;### GameData Integration&#10;The system automatically:&#10;- Saves/loads unlocked levels&#10;- Tracks level completion status&#10;- Stores best completion times&#10;- Remembers selected level index&#10;&#10;### Event System Integration&#10;Publishes these events:&#10;- `LevelSelectedEvent` - When a level is chosen&#10;- `LevelNavigationEvent` - When navigating between levels&#10;- `ItemSelectScreenRequestedEvent` - When showing item select&#10;- `LevelLoadRequestedEvent` - When loading a level&#10;- `LevelStartedEvent` - When level begins&#10;- `LevelCompletedEvent` - When level is completed&#10;&#10;### GameFlowManager Integration&#10;- Added `LevelSelection` state to GameState enum&#10;- Handles scene transitions through crossfade system&#10;- Manages game state changes during level selection&#10;&#10;## Usage Example&#10;&#10;```csharp&#10;// From main menu, transition to level selection&#10;gameFlowManager.ChangeState(GameState.LevelSelection);&#10;&#10;// The system will automatically:&#10;// 1. Load unlocked levels from GameData&#10;// 2. Position selector on last selected level&#10;// 3. Handle input for navigation&#10;// 4. Show item select screen on confirmation&#10;// 5. Load the selected level scene with crossfade&#10;```&#10;&#10;## Navigation Controls&#10;- **Arrow Keys**: Navigate between levels (Adventure Island III style)&#10;- **Enter**: Confirm level selection&#10;- **Locked levels**: Play sound and prevent selection&#10;&#10;## Customization Points&#10;- Modify navigation grid layout in LevelSelector&#10;- Customize NES crossfade colors and timing&#10;- Add more visual feedback to level points&#10;- Extend level data with additional properties&#10;- Customize item select screen behavior&#10;&#10;## Factory and Builder Pattern Usage&#10;- **LevelDataFactory**: Creates LevelData from GameObjects&#10;- **LevelDataBuilder**: Fluent builder for LevelData construction&#10;- **LevelSelectionDirector**: Orchestrates level data building&#10;&#10;The system is fully integrated with your existing architecture and ready to use!" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/SceneTransitionManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/SceneTransitionManager.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;using Core.Events;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Manages scene transitions with NES-style crossfade effects&#10;    /// Persists across scenes using DontDestroyOnLoad&#10;    /// &lt;/summary&gt;&#10;    public class SceneTransitionManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Transition Settings&quot;)]&#10;        [SerializeField] private NESCrossfade crossfadeTemplate;&#10;        [SerializeField] private bool fadeInOnSceneStart = true;&#10;        [SerializeField] private float fadeInDelay = 0.1f;&#10;        &#10;        private static SceneTransitionManager _instance;&#10;        private NESCrossfade _activeCrossfade;&#10;        private IEventBus _eventBus;&#10;        private bool _isTransitioning;&#10;        &#10;        public static SceneTransitionManager Instance =&gt; _instance;&#10;        public bool IsTransitioning =&gt; _isTransitioning;&#10;        &#10;        [Inject]&#10;        public void Construct(IEventBus eventBus)&#10;        {&#10;            _eventBus = eventBus;&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            // Implement singleton pattern&#10;            if (_instance == null)&#10;            {&#10;                _instance = this;&#10;                DontDestroyOnLoad(gameObject);&#10;                SetupCrossfade();&#10;                SubscribeToEvents();&#10;                Debug.Log(&quot;[SceneTransitionManager] Initialized as singleton&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.Log(&quot;[SceneTransitionManager] Duplicate instance destroyed&quot;);&#10;                Destroy(gameObject);&#10;                return;&#10;            }&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            // Fade in when scene starts (if enabled)&#10;            if (fadeInOnSceneStart)&#10;            {&#10;                StartCoroutine(FadeInAfterDelay());&#10;            }&#10;        }&#10;        &#10;        private void OnDestroy()&#10;        {&#10;            if (_instance == this)&#10;            {&#10;                _eventBus?.Unsubscribe&lt;Core.Events.LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;                _instance = null;&#10;            }&#10;        }&#10;&#10;        private void SetupCrossfade()&#10;        {&#10;            if (crossfadeTemplate != null)&#10;            {&#10;                // Create a dedicated crossfade instance&#10;                GameObject crossfadeGO = Instantiate(crossfadeTemplate.gameObject, transform);&#10;                _activeCrossfade = crossfadeGO.GetComponent&lt;NESCrossfade&gt;();&#10;                &#10;                // Ensure it stays on top&#10;                Canvas canvas = _activeCrossfade.GetComponent&lt;Canvas&gt;();&#10;                if (canvas == null)&#10;                {&#10;                    // Add canvas if crossfade doesn't have one&#10;                    canvas = _activeCrossfade.gameObject.AddComponent&lt;Canvas&gt;();&#10;                    canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;                    _activeCrossfade.gameObject.AddComponent&lt;UnityEngine.UI.GraphicRaycaster&gt;();&#10;                }&#10;                &#10;                canvas.sortingOrder = 9999; // Highest priority&#10;                &#10;                Debug.Log(&quot;[SceneTransitionManager] Crossfade setup complete&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;[SceneTransitionManager] No crossfade template assigned!&quot;);&#10;            }&#10;        }&#10;        &#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;Core.Events.LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;        &#10;        private void OnLevelLoadRequested(Core.Events.LevelLoadRequestedEvent loadEvent)&#10;        {&#10;            if (!_isTransitioning)&#10;            {&#10;                StartCoroutine(TransitionToSceneCoroutine(loadEvent.SceneName));&#10;            }&#10;        }&#10;        &#10;        private IEnumerator FadeInAfterDelay()&#10;        {&#10;            if (_activeCrossfade == null) yield break;&#10;            &#10;            yield return new WaitForSeconds(fadeInDelay);&#10;            &#10;            if (_activeCrossfade.GetFadeProgress() &gt; 0f)&#10;            {&#10;                Debug.Log(&quot;[SceneTransitionManager] Fading in on scene start&quot;);&#10;                _activeCrossfade.FadeIn(() =&gt; Debug.Log(&quot;[SceneTransitionManager] Scene fade-in complete&quot;));&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Transition to a new scene with crossfade effect&#10;        /// &lt;/summary&gt;&#10;        public void TransitionToScene(string sceneName)&#10;        {&#10;            if (!_isTransitioning)&#10;            {&#10;                StartCoroutine(TransitionToSceneCoroutine(sceneName));&#10;            }&#10;        }&#10;        &#10;        private IEnumerator TransitionToSceneCoroutine(string sceneName)&#10;        {&#10;            if (_activeCrossfade == null)&#10;            {&#10;                Debug.LogError(&quot;[SceneTransitionManager] No crossfade available! Loading scene directly.&quot;);&#10;                SceneManager.LoadScene(sceneName);&#10;                yield break;&#10;            }&#10;            &#10;            _isTransitioning = true;&#10;            &#10;            Debug.Log($&quot;[SceneTransitionManager] Starting transition to: {sceneName}&quot;);&#10;            &#10;            // Fade out&#10;            bool fadeOutComplete = false;&#10;            _activeCrossfade.FadeOut(() =&gt; fadeOutComplete = true);&#10;            &#10;            // Wait for fade out to complete&#10;            yield return new WaitUntil(() =&gt; fadeOutComplete);&#10;            &#10;            // Load the new scene&#10;            Debug.Log($&quot;[SceneTransitionManager] Loading scene: {sceneName}&quot;);&#10;            SceneManager.LoadScene(sceneName);&#10;            &#10;            // Small delay to ensure scene is loaded&#10;            yield return new WaitForSeconds(0.1f);&#10;            &#10;            // Fade in will be handled by the new scene's Start() method&#10;            _isTransitioning = false;&#10;            &#10;            Debug.Log($&quot;[SceneTransitionManager] Transition to {sceneName} complete&quot;);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Manually trigger fade out (useful for immediate transitions)&#10;        /// &lt;/summary&gt;&#10;        public void FadeOut(Action onComplete = null)&#10;        {&#10;            _activeCrossfade?.FadeOut(onComplete);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Manually trigger fade in (useful for scene start)&#10;        /// &lt;/summary&gt;&#10;        public void FadeIn(Action onComplete = null)&#10;        {&#10;            _activeCrossfade?.FadeIn(onComplete);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Check if crossfade is currently visible&#10;        /// &lt;/summary&gt;&#10;        public bool IsCrossfadeVisible()&#10;        {&#10;            return _activeCrossfade != null &amp;&amp; _activeCrossfade.GetFadeProgress() &gt; 0f;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Set crossfade configuration&#10;        /// &lt;/summary&gt;&#10;        public void SetConfig(LevelSelectionConfig config)&#10;        {&#10;            _activeCrossfade?.SetConfig(config);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using Core.Events;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Standalone scene transition manager that works in any scene&#10;    /// Automatically creates crossfade and handles all scene transitions&#10;    /// &lt;/summary&gt;&#10;    public class SceneTransitionManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Transition Settings&quot;)]&#10;        [SerializeField] private bool useNESEffect = true;&#10;        [SerializeField] private bool fadeInOnSceneStart = true;&#10;        [SerializeField] private float fadeInDelay = 0.1f;&#10;        [SerializeField] private float fadeDuration = 1f;&#10;        [SerializeField] private Color fadeColor = Color.black;&#10;        [SerializeField] private Color[] nesColors = { Color.black, new(0.2f, 0.2f, 0.3f), new(0.1f, 0.1f, 0.2f) };&#10;        &#10;        private static SceneTransitionManager _instance;&#10;        private NESCrossfade _activeCrossfade;&#10;        private bool _isTransitioning;&#10;        &#10;        public static SceneTransitionManager Instance =&gt; _instance;&#10;        public bool IsTransitioning =&gt; _isTransitioning;&#10;        &#10;        private void Awake()&#10;        {&#10;            // Implement singleton pattern that works across scenes&#10;            if (_instance == null)&#10;            {&#10;                _instance = this;&#10;                DontDestroyOnLoad(gameObject);&#10;                CreateStandaloneCrossfade();&#10;                SubscribeToSceneEvents();&#10;                Debug.Log(&quot;[SceneTransitionManager] Initialized as standalone singleton&quot;);&#10;            }&#10;            else if (_instance != this)&#10;            {&#10;                Debug.Log(&quot;[SceneTransitionManager] Duplicate instance destroyed&quot;);&#10;                Destroy(gameObject);&#10;                return;&#10;            }&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            // Fade in when scene starts (if enabled and crossfade is visible)&#10;            if (fadeInOnSceneStart &amp;&amp; _activeCrossfade != null)&#10;            {&#10;                StartCoroutine(FadeInAfterDelay());&#10;            }&#10;        }&#10;        &#10;        private void OnDestroy()&#10;        {&#10;            if (_instance == this)&#10;            {&#10;                UnsubscribeFromSceneEvents();&#10;                _instance = null;&#10;            }&#10;        }&#10;&#10;        private void CreateStandaloneCrossfade()&#10;        {&#10;            // Create a completely standalone crossfade system&#10;            GameObject crossfadeGO = new GameObject(&quot;SceneTransitionCrossfade&quot;);&#10;            crossfadeGO.transform.SetParent(transform);&#10;            &#10;            // Add Canvas for overlay rendering&#10;            Canvas canvas = crossfadeGO.AddComponent&lt;Canvas&gt;();&#10;            canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;            canvas.sortingOrder = 9999; // Highest priority&#10;            &#10;            // Add CanvasScaler for proper scaling&#10;            UnityEngine.UI.CanvasScaler scaler = crossfadeGO.AddComponent&lt;UnityEngine.UI.CanvasScaler&gt;();&#10;            scaler.uiScaleMode = UnityEngine.UI.CanvasScaler.ScaleMode.ScaleWithScreenSize;&#10;            scaler.referenceResolution = new Vector2(1920, 1080);&#10;            &#10;            // Add GraphicRaycaster&#10;            crossfadeGO.AddComponent&lt;UnityEngine.UI.GraphicRaycaster&gt;();&#10;            &#10;            // Create fade image&#10;            GameObject imageGO = new GameObject(&quot;FadeImage&quot;);&#10;            imageGO.transform.SetParent(crossfadeGO.transform, false);&#10;            &#10;            UnityEngine.UI.Image fadeImage = imageGO.AddComponent&lt;UnityEngine.UI.Image&gt;();&#10;            RectTransform rect = fadeImage.rectTransform;&#10;            rect.anchorMin = Vector2.zero;&#10;            rect.anchorMax = Vector2.one;&#10;            rect.sizeDelta = Vector2.zero;&#10;            rect.anchoredPosition = Vector2.zero;&#10;            &#10;            // Set initial color and disable&#10;            fadeImage.color = new Color(fadeColor.r, fadeColor.g, fadeColor.b, 1f);&#10;            fadeImage.enabled = false;&#10;            &#10;            // Add and configure NESCrossfade component&#10;            _activeCrossfade = crossfadeGO.AddComponent&lt;NESCrossfade&gt;();&#10;            _activeCrossfade.fadeImage = fadeImage;&#10;            _activeCrossfade.fadeDuration = fadeDuration;&#10;            _activeCrossfade.fadeColor = fadeColor;&#10;            _activeCrossfade.useNESEffect = useNESEffect;&#10;            _activeCrossfade.nesColors = nesColors;&#10;            &#10;            Debug.Log(&quot;[SceneTransitionManager] Standalone crossfade created&quot;);&#10;        }&#10;&#10;        private void SubscribeToSceneEvents()&#10;        {&#10;            // Listen for scene load events to handle automatic transitions&#10;            SceneManager.sceneLoaded += OnSceneLoaded;&#10;        }&#10;        &#10;        private void UnsubscribeFromSceneEvents()&#10;        {&#10;            SceneManager.sceneLoaded -= OnSceneLoaded;&#10;        }&#10;        &#10;        private void OnSceneLoaded(Scene scene, LoadSceneMode mode)&#10;        {&#10;            Debug.Log($&quot;[SceneTransitionManager] Scene loaded: {scene.name}&quot;);&#10;            &#10;            // Auto fade in after scene load&#10;            if (fadeInOnSceneStart &amp;&amp; _activeCrossfade != null)&#10;            {&#10;                StartCoroutine(FadeInAfterDelay());&#10;            }&#10;        }&#10;        &#10;        private IEnumerator FadeInAfterDelay()&#10;        {&#10;            if (_activeCrossfade == null) yield break;&#10;            &#10;            yield return new WaitForSeconds(fadeInDelay);&#10;            &#10;            // Only fade in if crossfade is currently visible&#10;            if (_activeCrossfade.GetFadeProgress() &gt; 0f)&#10;            {&#10;                Debug.Log(&quot;[SceneTransitionManager] Auto fading in on scene start&quot;);&#10;                _activeCrossfade.FadeIn(() =&gt; Debug.Log(&quot;[SceneTransitionManager] Scene fade-in complete&quot;));&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Transition to a new scene with crossfade effect&#10;        /// &lt;/summary&gt;&#10;        public void TransitionToScene(string sceneName)&#10;        {&#10;            if (!_isTransitioning)&#10;            {&#10;                StartCoroutine(TransitionToSceneCoroutine(sceneName));&#10;            }&#10;        }&#10;        &#10;        private IEnumerator TransitionToSceneCoroutine(string sceneName)&#10;        {&#10;            if (_activeCrossfade == null)&#10;            {&#10;                Debug.LogError(&quot;[SceneTransitionManager] No crossfade available! Loading scene directly.&quot;);&#10;                SceneManager.LoadScene(sceneName);&#10;                yield break;&#10;            }&#10;            &#10;            _isTransitioning = true;&#10;            &#10;            Debug.Log($&quot;[SceneTransitionManager] Starting transition to: {sceneName}&quot;);&#10;            &#10;            // Fade out&#10;            bool fadeOutComplete = false;&#10;            _activeCrossfade.FadeOut(() =&gt; fadeOutComplete = true);&#10;            &#10;            // Wait for fade out to complete&#10;            yield return new WaitUntil(() =&gt; fadeOutComplete);&#10;            &#10;            // Load the new scene&#10;            Debug.Log($&quot;[SceneTransitionManager] Loading scene: {sceneName}&quot;);&#10;            SceneManager.LoadScene(sceneName);&#10;            &#10;            // Reset transitioning flag after scene loads&#10;            _isTransitioning = false;&#10;            &#10;            Debug.Log($&quot;[SceneTransitionManager] Transition to {sceneName} complete&quot;);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Manually trigger fade out&#10;        /// &lt;/summary&gt;&#10;        public void FadeOut(Action onComplete = null)&#10;        {&#10;            _activeCrossfade?.FadeOut(onComplete);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Manually trigger fade in&#10;        /// &lt;/summary&gt;&#10;        public void FadeIn(Action onComplete = null)&#10;        {&#10;            _activeCrossfade?.FadeIn(onComplete);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Check if crossfade is currently visible&#10;        /// &lt;/summary&gt;&#10;        public bool IsCrossfadeVisible()&#10;        {&#10;            return _activeCrossfade != null &amp;&amp; _activeCrossfade.GetFadeProgress() &gt; 0f;&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Create a standalone SceneTransitionManager if one doesn't exist&#10;        /// &lt;/summary&gt;&#10;        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]&#10;        public static void EnsureInstance()&#10;        {&#10;            if (_instance == null)&#10;            {&#10;                GameObject go = new GameObject(&quot;SceneTransitionManager&quot;);&#10;                go.AddComponent&lt;SceneTransitionManager&gt;();&#10;                Debug.Log(&quot;[SceneTransitionManager] Auto-created standalone instance&quot;);&#10;            }&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Static method to transition scenes from anywhere&#10;        /// &lt;/summary&gt;&#10;        public static void TransitionTo(string sceneName)&#10;        {&#10;            if (_instance != null)&#10;            {&#10;                _instance.TransitionToScene(sceneName);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;[SceneTransitionManager] No instance available, loading scene directly&quot;);&#10;                SceneManager.LoadScene(sceneName);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/ILevelSelectionServices.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/ILevelSelectionServices.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for discovering level components in the scene&#10;    ///     Decoupled from specific GameObject hierarchy&#10;    /// &lt;/summary&gt;&#10;    public interface ILevelDiscoveryService&#10;    {&#10;        Task&lt;List&lt;LevelData&gt;&gt; DiscoverLevelsAsync();&#10;        List&lt;LevelPoint&gt; GetSortedLevelPoints();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for handling level navigation&#10;    ///     Independent of input system implementation&#10;    /// &lt;/summary&gt;&#10;    public interface ILevelNavigationService&#10;    {&#10;        int CurrentIndex { get; }&#10;        LevelData CurrentLevel { get; }&#10;        Task InitializeAsync(List&lt;LevelData&gt; levelData);&#10;        void Activate();&#10;        void Deactivate();&#10;        void NavigateInDirection(Vector2 direction);&#10;        void SelectCurrentLevel();&#10;        void SetGridWidth(int gridWidth);&#10;        void SetCurrentIndex(int index);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for visual display and feedback&#10;    ///     Can work with any visual components in the scene&#10;    /// &lt;/summary&gt;&#10;    public interface ILevelDisplayService&#10;    {&#10;        Task InitializeAsync(List&lt;LevelData&gt; levelData);&#10;        void Activate();&#10;        void Deactivate();&#10;        void UpdateSelection(int newIndex);&#10;        void SetConfig(LevelSelectionConfig config);&#10;        void RefreshVisuals();&#10;        void Dispose();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for discovering level components in the scene&#10;    ///     Decoupled from specific GameObject hierarchy&#10;    /// &lt;/summary&gt;&#10;    public interface ILevelDiscoveryService&#10;    {&#10;        Task&lt;List&lt;LevelData&gt;&gt; DiscoverLevelsAsync();&#10;        List&lt;LevelPoint&gt; GetSortedLevelPoints();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for handling level navigation&#10;    ///     Independent of input system implementation&#10;    /// &lt;/summary&gt;&#10;    public interface ILevelNavigationService&#10;    {&#10;        int CurrentIndex { get; }&#10;        LevelData CurrentLevel { get; }&#10;        Task InitializeAsync(List&lt;LevelData&gt; levelData);&#10;        void Activate();&#10;        void Deactivate();&#10;        void NavigateInDirection(Vector2 direction);&#10;        void SelectCurrentLevel();&#10;        void SetGridWidth(int gridWidth);&#10;        void SetCurrentIndex(int index);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for visual display and feedback&#10;    ///     Can work with any visual components in the scene&#10;    /// &lt;/summary&gt;&#10;    public interface ILevelDisplayService&#10;    {&#10;        Task InitializeAsync(List&lt;LevelData&gt; levelData);&#10;        void Activate();&#10;        void Deactivate();&#10;        void UpdateSelection(int newIndex);&#10;        void SetConfig(LevelSelectionConfig config);&#10;        void SetLevelPoints(List&lt;LevelPoint&gt; sortedLevelPoints);&#10;        void RefreshVisuals();&#10;        void Dispose();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/LevelDiscoveryService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/LevelDiscoveryService.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using UnityEngine;&#10;using Object = UnityEngine.Object;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Efficient level discovery service that caches results&#10;    /// &lt;/summary&gt;&#10;    public class LevelDiscoveryService : ILevelDiscoveryService&#10;    {&#10;        private readonly LevelSelectionDirector _director = new();&#10;        private readonly Core.Data.IGameDataService _gameDataService;&#10;        private List&lt;LevelData&gt; _cachedLevelData;&#10;        private List&lt;LevelPoint&gt; _sortedLevelPoints;&#10;&#10;        public LevelDiscoveryService(Core.Data.IGameDataService gameDataService)&#10;        {&#10;            _gameDataService = gameDataService;&#10;        }&#10;&#10;        public async Task&lt;List&lt;LevelData&gt;&gt; DiscoverLevelsAsync()&#10;        {&#10;            if (_cachedLevelData != null)&#10;            {&#10;                return _cachedLevelData;&#10;            }&#10;&#10;            await Task.Yield();&#10;&#10;            // Use a more efficient discovery method&#10;            var levelPoints = Object.FindObjectsByType&lt;LevelPoint&gt;(&#10;                FindObjectsInactive.Include,&#10;                FindObjectsSortMode.InstanceID&#10;            );&#10;&#10;            var levelObjects = levelPoints.Select(lp =&gt; lp.gameObject).ToList();&#10;&#10;            // Sort by multiple criteria for consistent ordering&#10;            levelObjects.Sort((a, b) =&gt;&#10;            {&#10;                // First by name (Level_01, Level_02, etc.)&#10;                int nameComparison = string.Compare(a.name, b.name, StringComparison.OrdinalIgnoreCase);&#10;                if (nameComparison != 0) return nameComparison;&#10;&#10;                // Then by position (left to right, top to bottom)&#10;                Vector3 posA = a.transform.position;&#10;                Vector3 posB = b.transform.position;&#10;&#10;                if (Mathf.Abs(posA.y - posB.y) &gt; 0.1f)&#10;                    return posB.y.CompareTo(posA.y); // Higher Y first&#10;&#10;                return posA.x.CompareTo(posB.x); // Left to right&#10;            });&#10;&#10;            // Cache sorted level points for external use&#10;            _sortedLevelPoints = levelObjects.Select(obj =&gt; obj.GetComponent&lt;LevelPoint&gt;()).ToList();&#10;&#10;            // Build level data with game data integration&#10;            _cachedLevelData = BuildLevelDataWithGameData(levelObjects);&#10;&#10;            Debug.Log($&quot;[LevelDiscoveryService] Discovered {_cachedLevelData.Count} levels and cached {_sortedLevelPoints.Count} sorted level points&quot;);&#10;            return _cachedLevelData;&#10;        }&#10;&#10;        private List&lt;LevelData&gt; BuildLevelDataWithGameData(List&lt;GameObject&gt; levelObjects)&#10;        {&#10;            var levelDataList = new List&lt;LevelData&gt;();&#10;&#10;            // Use injected game data service instead of FindFirstObjectByType&#10;            Core.Data.GameData gameData = _gameDataService?.CurrentData;&#10;&#10;            for (int i = 0; i &lt; levelObjects.Count; i++)&#10;            {&#10;                GameObject levelObject = levelObjects[i];&#10;                if (levelObject == null) continue;&#10;&#10;                LevelData levelData;&#10;                &#10;                if (gameData != null)&#10;                {&#10;                    // Use enhanced factory method with game data&#10;                    levelData = LevelDataFactory.CreateFromGameObjectWithGameData(levelObject, i, gameData);&#10;                }&#10;                else&#10;                {&#10;                    // Fallback to basic creation&#10;                    levelData = LevelDataFactory.CreateFromGameObject(levelObject, i);&#10;                }&#10;&#10;                if (levelData == null)&#10;                {&#10;                    // Final fallback - create from transform position and object name&#10;                    levelData = LevelDataFactory.CreateFromTransform(levelObject, i);&#10;                }&#10;&#10;                if (levelData != null)&#10;                {&#10;                    Debug.Log($&quot;Level {i}: {levelData.levelName} at position {levelData.mapPosition} (Unlocked: {levelData.isUnlocked}, Completed: {levelData.isCompleted})&quot;);&#10;                    levelDataList.Add(levelData);&#10;                }&#10;            }&#10;&#10;            return levelDataList;&#10;        }&#10;&#10;        public List&lt;LevelPoint&gt; GetSortedLevelPoints()&#10;        {&#10;            return _sortedLevelPoints;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using UnityEngine;&#10;using Object = UnityEngine.Object;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Efficient level discovery service that caches results&#10;    /// &lt;/summary&gt;&#10;    public class LevelDiscoveryService : ILevelDiscoveryService&#10;    {&#10;        private readonly Core.Data.IGameDataService _gameDataService;&#10;        private List&lt;LevelData&gt; _cachedLevelData;&#10;        private List&lt;LevelPoint&gt; _sortedLevelPoints;&#10;&#10;        public LevelDiscoveryService(Core.Data.IGameDataService gameDataService)&#10;        {&#10;            _gameDataService = gameDataService;&#10;        }&#10;&#10;        public async Task&lt;List&lt;LevelData&gt;&gt; DiscoverLevelsAsync()&#10;        {&#10;            if (_cachedLevelData != null)&#10;            {&#10;                return _cachedLevelData;&#10;            }&#10;&#10;            await Task.Yield();&#10;&#10;            // Use a more efficient discovery method&#10;            var levelPoints = Object.FindObjectsByType&lt;LevelPoint&gt;(&#10;                FindObjectsInactive.Include,&#10;                FindObjectsSortMode.InstanceID&#10;            );&#10;&#10;            var levelObjects = levelPoints.Select(lp =&gt; lp.gameObject).ToList();&#10;&#10;            // Sort by multiple criteria for consistent ordering&#10;            levelObjects.Sort((a, b) =&gt;&#10;            {&#10;                // First by name (Level_01, Level_02, etc.)&#10;                int nameComparison = string.Compare(a.name, b.name, StringComparison.OrdinalIgnoreCase);&#10;                if (nameComparison != 0) return nameComparison;&#10;&#10;                // Then by position (left to right, top to bottom)&#10;                Vector3 posA = a.transform.position;&#10;                Vector3 posB = b.transform.position;&#10;&#10;                if (Mathf.Abs(posA.y - posB.y) &gt; 0.1f)&#10;                    return posB.y.CompareTo(posA.y); // Higher Y first&#10;&#10;                return posA.x.CompareTo(posB.x); // Left to right&#10;            });&#10;&#10;            // Cache sorted level points for external use&#10;            _sortedLevelPoints = levelObjects.Select(obj =&gt; obj.GetComponent&lt;LevelPoint&gt;()).ToList();&#10;&#10;            // Build level data directly without director pattern&#10;            _cachedLevelData = BuildLevelDataWithGameData(levelObjects);&#10;&#10;            Debug.Log($&quot;[LevelDiscoveryService] Discovered {_cachedLevelData.Count} levels and cached {_sortedLevelPoints.Count} sorted level points&quot;);&#10;            return _cachedLevelData;&#10;        }&#10;&#10;        private List&lt;LevelData&gt; BuildLevelDataWithGameData(List&lt;GameObject&gt; levelObjects)&#10;        {&#10;            var levelDataList = new List&lt;LevelData&gt;();&#10;&#10;            // Use injected game data service instead of FindFirstObjectByType&#10;            Core.Data.GameData gameData = _gameDataService?.CurrentData;&#10;&#10;            for (int i = 0; i &lt; levelObjects.Count; i++)&#10;            {&#10;                GameObject levelObject = levelObjects[i];&#10;                if (levelObject == null) continue;&#10;&#10;                LevelData levelData;&#10;                &#10;                if (gameData != null)&#10;                {&#10;                    // Use enhanced factory method with game data&#10;                    levelData = LevelDataFactory.CreateFromGameObjectWithGameData(levelObject, i, gameData);&#10;                }&#10;                else&#10;                {&#10;                    // Fallback to basic creation&#10;                    levelData = LevelDataFactory.CreateFromGameObject(levelObject, i);&#10;                }&#10;&#10;                if (levelData == null)&#10;                {&#10;                    // Final fallback - create from transform position and object name&#10;                    levelData = LevelDataFactory.CreateFromTransform(levelObject, i);&#10;                }&#10;&#10;                if (levelData != null)&#10;                {&#10;                    Debug.Log($&quot;Level {i}: {levelData.levelName} at position {levelData.mapPosition} (Unlocked: {levelData.isUnlocked}, Completed: {levelData.isCompleted})&quot;);&#10;                    levelDataList.Add(levelData);&#10;                }&#10;            }&#10;&#10;            return levelDataList;&#10;        }&#10;&#10;        public List&lt;LevelPoint&gt; GetSortedLevelPoints()&#10;        {&#10;            return _sortedLevelPoints;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/LevelDisplayService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/LevelDisplayService.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using Core.Events;&#10;using UnityEngine;&#10;using Object = UnityEngine.Object;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Display service that manages visual components&#10;    ///     Components are assigned via inspector instead of auto-discovery&#10;    /// &lt;/summary&gt;&#10;    public class LevelDisplayService : ILevelDisplayService&#10;    {&#10;        private readonly IEventBus _eventBus;&#10;        private LevelSelectionConfig _config;&#10;        private int _currentSelection;&#10;        private bool _isActive;&#10;        private List&lt;LevelData&gt; _levelData;&#10;        private List&lt;LevelPoint&gt; _levelPoints;&#10;&#10;        public LevelDisplayService(IEventBus eventBus)&#10;        {&#10;            _eventBus = eventBus;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        public async Task InitializeAsync(List&lt;LevelData&gt; levelData)&#10;        {&#10;            _levelData = levelData;&#10;            &#10;            // Level points will be provided by the controller/discovery service&#10;            // No more FindObjectsByType calls - use DI instead!&#10;            &#10;            Debug.Log($&quot;[LevelDisplayService] Initialized with {_levelData.Count} level data entries&quot;);&#10;            await Task.CompletedTask;&#10;        }&#10;&#10;        public void SetLevelPoints(List&lt;LevelPoint&gt; sortedLevelPoints)&#10;        {&#10;            _levelPoints = sortedLevelPoints;&#10;            Debug.Log($&quot;[LevelDisplayService] Received {_levelPoints?.Count ?? 0} sorted level points&quot;);&#10;            UpdateAllVisuals();&#10;        }&#10;&#10;        public void SetConfig(LevelSelectionConfig config)&#10;        {&#10;            _config = config;&#10;            UpdateAllVisuals(); // Refresh visuals with new config&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            _isActive = true;&#10;            UpdateAllVisuals();&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            _isActive = false;&#10;        }&#10;&#10;        public void UpdateSelection(int newIndex)&#10;        {&#10;            if (!_isActive || newIndex == _currentSelection) return;&#10;&#10;            _currentSelection = newIndex;&#10;            UpdateAllVisuals();&#10;        }&#10;&#10;        private void UpdateAllVisuals()&#10;        {&#10;            // Update all level point visuals using config colors&#10;            for (int i = 0; i &lt; _levelPoints.Count &amp;&amp; i &lt; _levelData.Count; i++)&#10;            {&#10;                if (_levelPoints[i] != null)&#10;                {&#10;                    _levelPoints[i].SetUnlocked(_levelData[i].isUnlocked);&#10;                    _levelPoints[i].SetSelected(i == _currentSelection);&#10;&#10;                    // Apply config colors if available&#10;                    if (_config != null &amp;&amp; _levelPoints[i].iconRenderer != null)&#10;                    {&#10;                        if (i == _currentSelection)&#10;                        {&#10;                            _levelPoints[i].iconRenderer.color = _config.selectedColor;&#10;                        }&#10;                        else if (_levelData[i].isUnlocked)&#10;                        {&#10;                            _levelPoints[i].iconRenderer.color = _config.unlockedColor;&#10;                        }&#10;                        else&#10;                        {&#10;                            _levelPoints[i].iconRenderer.color = _config.lockedColor;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            UpdateSelection(navigationEvent.NewIndex);&#10;        }&#10;&#10;        public void RefreshVisuals()&#10;        {&#10;            UpdateAllVisuals();&#10;        }&#10;&#10;        public void Dispose()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using Core.Events;&#10;using UnityEngine;&#10;using Object = UnityEngine.Object;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Display service that manages level state without visuals&#10;    ///     Since levels are invisible points, this focuses on data management&#10;    /// &lt;/summary&gt;&#10;    public class LevelDisplayService : ILevelDisplayService&#10;    {&#10;        private readonly IEventBus _eventBus;&#10;        private LevelSelectionConfig _config;&#10;        private int _currentSelection;&#10;        private bool _isActive;&#10;        private List&lt;LevelData&gt; _levelData;&#10;        private List&lt;LevelPoint&gt; _levelPoints;&#10;&#10;        public LevelDisplayService(IEventBus eventBus)&#10;        {&#10;            _eventBus = eventBus;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        public async Task InitializeAsync(List&lt;LevelData&gt; levelData)&#10;        {&#10;            _levelData = levelData;&#10;            Debug.Log($&quot;[LevelDisplayService] Initialized with {_levelData.Count} level data entries&quot;);&#10;            await Task.CompletedTask;&#10;        }&#10;&#10;        public void SetLevelPoints(List&lt;LevelPoint&gt; sortedLevelPoints)&#10;        {&#10;            _levelPoints = sortedLevelPoints;&#10;            Debug.Log($&quot;[LevelDisplayService] Received {_levelPoints?.Count ?? 0} sorted level points&quot;);&#10;            UpdateLevelStates();&#10;        }&#10;&#10;        public void SetConfig(LevelSelectionConfig config)&#10;        {&#10;            _config = config;&#10;            // Config stored but no visual updates needed for invisible points&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            _isActive = true;&#10;            UpdateLevelStates();&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            _isActive = false;&#10;        }&#10;&#10;        public void UpdateSelection(int newIndex)&#10;        {&#10;            if (!_isActive || newIndex == _currentSelection) return;&#10;&#10;            _currentSelection = newIndex;&#10;            UpdateLevelStates();&#10;        }&#10;&#10;        private void UpdateLevelStates()&#10;        {&#10;            // Update level point states without visual changes&#10;            if (_levelPoints == null || _levelData == null) return;&#10;&#10;            for (int i = 0; i &lt; _levelPoints.Count &amp;&amp; i &lt; _levelData.Count; i++)&#10;            {&#10;                if (_levelPoints[i] != null)&#10;                {&#10;                    _levelPoints[i].SetUnlocked(_levelData[i].isUnlocked);&#10;                    _levelPoints[i].SetSelected(i == _currentSelection);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            UpdateSelection(navigationEvent.NewIndex);&#10;        }&#10;&#10;        public void RefreshVisuals()&#10;        {&#10;            // Renamed to RefreshStates since no visuals&#10;            UpdateLevelStates();&#10;        }&#10;&#10;        public void Dispose()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/LevelNavigationService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/LevelNavigationService.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Navigation service that works independently of GameObject structure&#10;    ///     Handles all navigation logic and input processing&#10;    /// &lt;/summary&gt;&#10;    public class LevelNavigationService : ILevelNavigationService&#10;    {&#10;&#10;        private readonly IEventBus _eventBus;&#10;        private readonly IGameDataService _gameDataService;&#10;        private int _gridWidth = 4; // Default value, will be updated from config&#10;        private bool _isActive;&#10;        private List&lt;LevelData&gt; _levelData;&#10;&#10;        public LevelNavigationService(IEventBus eventBus, IGameDataService gameDataService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataService = gameDataService;&#10;        }&#10;&#10;        public int CurrentIndex { get; private set; }&#10;&#10;        public LevelData CurrentLevel =&gt; _levelData?[CurrentIndex];&#10;&#10;        public async Task InitializeAsync(List&lt;LevelData&gt; levelData)&#10;        {&#10;            _levelData = levelData;&#10;&#10;            // Load saved selection from game data&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            int savedIndex = gameData?.selectedLevelIndex ?? 0;&#10;            CurrentIndex = Mathf.Clamp(savedIndex, 0, levelData.Count - 1);&#10;&#10;            Debug.Log(&#10;                $&quot;[LevelNavigationService] Initialized with CurrentIndex: {CurrentIndex} (saved: {savedIndex}, total levels: {levelData.Count})&quot;);&#10;&#10;            await Task.CompletedTask;&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            _isActive = true;&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            _isActive = false;&#10;        }&#10;&#10;        public void NavigateInDirection(Vector2 direction)&#10;        {&#10;            if (!_isActive || _levelData == null || _levelData.Count == 0) return;&#10;&#10;            int newIndex = CalculateNewIndex(direction);&#10;            UpdateSelection(newIndex);&#10;        }&#10;&#10;        public void SelectCurrentLevel()&#10;        {&#10;            if (!_isActive || _levelData == null || CurrentIndex &gt;= _levelData.Count) return;&#10;&#10;            LevelData selectedLevel = _levelData[CurrentIndex];&#10;&#10;            if (!selectedLevel.isUnlocked)&#10;            {&#10;                Debug.Log($&quot;Level {selectedLevel.levelName} is locked&quot;);&#10;                return;&#10;            }&#10;&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = selectedLevel.levelName,&#10;                LevelIndex = CurrentIndex&#10;            });&#10;        }&#10;&#10;        public void SetGridWidth(int gridWidth)&#10;        {&#10;            _gridWidth = gridWidth;&#10;            Debug.Log($&quot;[LevelNavigationService] Grid width set to {_gridWidth}&quot;);&#10;        }&#10;&#10;        public void SetCurrentIndex(int index)&#10;        {&#10;            if (_levelData == null || index &lt; 0 || index &gt;= _levelData.Count) return;&#10;&#10;            UpdateSelection(index);&#10;        }&#10;&#10;        private int CalculateNewIndex(Vector2 direction)&#10;        {&#10;            if (Mathf.Abs(direction.x) &gt; Mathf.Abs(direction.y))&#10;            {&#10;                // Horizontal movement&#10;                return direction.x &gt; 0&#10;                    ? Mathf.Min(CurrentIndex + 1, _levelData.Count - 1)&#10;                    : Mathf.Max(CurrentIndex - 1, 0);&#10;            }&#10;&#10;            // Vertical movement - now uses the actual grid width from config&#10;            int newIndex = direction.y &gt; 0&#10;                ? CurrentIndex - _gridWidth&#10;                : CurrentIndex + _gridWidth;&#10;&#10;            return Mathf.Clamp(newIndex, 0, _levelData.Count - 1);&#10;        }&#10;&#10;        private void UpdateSelection(int newIndex)&#10;        {&#10;            Debug.Log($&quot;[LevelNavigationService] UpdateSelection called: {CurrentIndex} -&gt; {newIndex}&quot;);&#10;&#10;            if (newIndex == CurrentIndex)&#10;            {&#10;                Debug.Log($&quot;[LevelNavigationService] No change needed, staying at index {CurrentIndex}&quot;);&#10;                return;&#10;            }&#10;&#10;            int previousIndex = CurrentIndex;&#10;            CurrentIndex = newIndex;&#10;&#10;            // Save selection immediately&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = CurrentIndex;&#10;                _gameDataService?.SaveData();&#10;            }&#10;&#10;            Debug.Log($&quot;[LevelNavigationService] Publishing navigation event: {previousIndex} -&gt; {CurrentIndex}&quot;);&#10;&#10;            // Publish navigation event&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = CurrentIndex,&#10;                Direction = Vector2.zero&#10;            });&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Navigation service that works independently of GameObject structure&#10;    ///     Handles all navigation logic and input processing&#10;    /// &lt;/summary&gt;&#10;    public class LevelNavigationService : ILevelNavigationService&#10;    {&#10;&#10;        private readonly IEventBus _eventBus;&#10;        private readonly IGameDataService _gameDataService;&#10;        private int _gridWidth = 4; // Default value, will be updated from config&#10;        private bool _isActive;&#10;        private List&lt;LevelData&gt; _levelData;&#10;&#10;        public LevelNavigationService(IEventBus eventBus, IGameDataService gameDataService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataService = gameDataService;&#10;        }&#10;&#10;        public int CurrentIndex { get; private set; }&#10;&#10;        public LevelData CurrentLevel =&gt; _levelData?[CurrentIndex];&#10;&#10;        public async Task InitializeAsync(List&lt;LevelData&gt; levelData)&#10;        {&#10;            _levelData = levelData;&#10;&#10;            // Load saved selection from game data&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            int savedIndex = gameData?.selectedLevelIndex ?? 0;&#10;            CurrentIndex = Mathf.Clamp(savedIndex, 0, levelData.Count - 1);&#10;&#10;            Debug.Log(&#10;                $&quot;[LevelNavigationService] Initialized with CurrentIndex: {CurrentIndex} (saved: {savedIndex}, total levels: {levelData.Count})&quot;);&#10;&#10;            await Task.CompletedTask;&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            _isActive = true;&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            _isActive = false;&#10;        }&#10;&#10;        public void NavigateInDirection(Vector2 direction)&#10;        {&#10;            if (!_isActive || _levelData == null || _levelData.Count == 0) return;&#10;&#10;            int newIndex = CalculateNewIndex(direction);&#10;            UpdateSelection(newIndex);&#10;        }&#10;&#10;        public void SelectCurrentLevel()&#10;        {&#10;            if (!_isActive || _levelData == null || CurrentIndex &gt;= _levelData.Count) return;&#10;&#10;            LevelData selectedLevel = _levelData[CurrentIndex];&#10;&#10;            Debug.Log($&quot;[LevelNavigationService] Attempting to select level: {selectedLevel.levelName} (Unlocked: {selectedLevel.isUnlocked})&quot;);&#10;&#10;            if (!selectedLevel.isUnlocked)&#10;            {&#10;                Debug.Log($&quot;[LevelNavigationService] Level {selectedLevel.levelName} is locked&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[LevelNavigationService] Publishing LevelSelectedEvent for: {selectedLevel.levelName}&quot;);&#10;            _eventBus?.Publish(new Core.Events.LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = selectedLevel.levelName,&#10;                LevelIndex = CurrentIndex&#10;            });&#10;        }&#10;&#10;        public void SetGridWidth(int gridWidth)&#10;        {&#10;            _gridWidth = gridWidth;&#10;            Debug.Log($&quot;[LevelNavigationService] Grid width set to {_gridWidth}&quot;);&#10;        }&#10;&#10;        public void SetCurrentIndex(int index)&#10;        {&#10;            if (_levelData == null || index &lt; 0 || index &gt;= _levelData.Count) return;&#10;&#10;            UpdateSelection(index);&#10;        }&#10;&#10;        private int CalculateNewIndex(Vector2 direction)&#10;        {&#10;            if (Mathf.Abs(direction.x) &gt; Mathf.Abs(direction.y))&#10;            {&#10;                // Horizontal movement&#10;                return direction.x &gt; 0&#10;                    ? Mathf.Min(CurrentIndex + 1, _levelData.Count - 1)&#10;                    : Mathf.Max(CurrentIndex - 1, 0);&#10;            }&#10;&#10;            // Vertical movement - now uses the actual grid width from config&#10;            int newIndex = direction.y &gt; 0&#10;                ? CurrentIndex - _gridWidth&#10;                : CurrentIndex + _gridWidth;&#10;&#10;            return Mathf.Clamp(newIndex, 0, _levelData.Count - 1);&#10;        }&#10;&#10;        private void UpdateSelection(int newIndex)&#10;        {&#10;            Debug.Log($&quot;[LevelNavigationService] UpdateSelection called: {CurrentIndex} -&gt; {newIndex}&quot;);&#10;&#10;            if (newIndex == CurrentIndex)&#10;            {&#10;                Debug.Log($&quot;[LevelNavigationService] No change needed, staying at index {CurrentIndex}&quot;);&#10;                return;&#10;            }&#10;&#10;            int previousIndex = CurrentIndex;&#10;            CurrentIndex = newIndex;&#10;&#10;            // Save selection immediately&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = CurrentIndex;&#10;                _gameDataService?.SaveData();&#10;            }&#10;&#10;            Debug.Log($&quot;[LevelNavigationService] Publishing navigation event: {previousIndex} -&gt; {CurrentIndex}&quot;);&#10;&#10;            // Publish navigation event&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = CurrentIndex,&#10;                Direction = Vector2.zero&#10;            });&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// When enabled, instantly kills any damageable object the player collides with.&#10;    /// Should be enabled only when the player is invincible.&#10;    /// &lt;/summary&gt;&#10;    [DisallowMultipleComponent]&#10;    public class PlayerInvincibleDamageDealer : MonoBehaviour, IDamageDealer&#10;    {&#10;        [SerializeField] private int damageAmount = 9999; // &quot;Kill&quot; value&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All by default&#10;&#10;        public int GetDamageAmount() =&gt; damageAmount;&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if (((1 &lt;&lt; collision.gameObject.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            var damageable = collision.gameObject.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable != null)&#10;            {&#10;                damageable.Damage(damageAmount, gameObject);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Pooling/PooledObject.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Pooling/PooledObject.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Pooling&#10;{&#10;    public class PooledObject : MonoBehaviour&#10;    {&#10;        public GameObject prefab;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>