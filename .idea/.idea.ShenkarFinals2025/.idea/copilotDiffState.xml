<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Editor/PrefabAuditorWindow.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Editor/PrefabAuditorWindow.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using System.Linq;&#10;using Enemies.Behaviors;&#10;using PowerUps.Container;&#10;using UnityEditor;&#10;using UnityEngine;&#10;using Utilities;&#10;&#10;namespace Editor&#10;{&#10;    public class PrefabAuditorWindow : EditorWindow&#10;    {&#10;        private readonly List&lt;GameObject&gt; _prefabs = new();&#10;        private readonly List&lt;GameObject&gt; _filteredPrefabs = new();&#10;        private Vector2 _scrollPosition;&#10;        private string _searchFilter = &quot;&quot;;&#10;        private FilterType _filterType = FilterType.All;&#10;        private bool _autoRefresh = true;&#10;        &#10;        // Quick settings&#10;        private float _ppu = 16f;&#10;        private GameObject _defaultDropPrefab;&#10;        private bool _showAdvancedSettings = false;&#10;        private bool _placementMode = false;&#10;        private GameObject _selectedPrefabForPlacement;&#10;        &#10;        // Radial Menu System&#10;        private bool _showRadialMenu = false;&#10;        private Vector2 _radialMenuPosition;&#10;        private readonly Dictionary&lt;GameObject, int&gt; _prefabUsageCount = new();&#10;        private List&lt;GameObject&gt; _frequentPrefabs = new();&#10;        private const int MAX_FREQUENT_PREFABS = 8;&#10;        &#10;        // Batch operations&#10;        private readonly List&lt;int&gt; _selectedPrefabs = new();&#10;        private bool _batchMode = false;&#10;        &#10;        // UI Colors and Styles&#10;        private static GUIStyle _headerStyle;&#10;        private static GUIStyle _cardStyle;&#10;        private static GUIStyle _buttonStyle;&#10;        private static GUIStyle _selectedButtonStyle;&#10;        &#10;        // Preview icon cache&#10;        private readonly Dictionary&lt;GameObject, Texture2D&gt; _previewCache = new();&#10;        &#10;        private enum FilterType&#10;        {&#10;            All,&#10;            Enemies,&#10;            Containers,&#10;            Others&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            LoadPrefabs();&#10;            LoadUsageData();&#10;            UpdateFrequentPrefabs();&#10;            SceneView.duringSceneGui += OnSceneGUI;&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            SaveUsageData();&#10;            SceneView.duringSceneGui -= OnSceneGUI;&#10;        }&#10;&#10;        private void InitializeStyles()&#10;        {&#10;            if (_headerStyle != null) return; // Already initialized&#10;            &#10;            _headerStyle = new GUIStyle(EditorStyles.boldLabel)&#10;            {&#10;                fontSize = 14,&#10;                normal = { textColor = EditorGUIUtility.isProSkin ? Color.white : Color.black }&#10;            };&#10;            &#10;            _cardStyle = new GUIStyle(GUI.skin.box)&#10;            {&#10;                padding = new RectOffset(10, 10, 10, 10),&#10;                margin = new RectOffset(5, 5, 2, 2)&#10;            };&#10;            &#10;            _buttonStyle = new GUIStyle(GUI.skin.button)&#10;            {&#10;                padding = new RectOffset(10, 10, 5, 5)&#10;            };&#10;            &#10;            _selectedButtonStyle = new GUIStyle(_buttonStyle)&#10;            {&#10;                normal = { background = EditorGUIUtility.isProSkin ? &#10;                    MakeTex(1, 1, new Color(0.3f, 0.5f, 0.8f, 1f)) : &#10;                    MakeTex(1, 1, new Color(0.6f, 0.8f, 1f, 1f)) }&#10;            };&#10;        }&#10;&#10;        private Texture2D MakeTex(int width, int height, Color color)&#10;        {&#10;            Color[] pix = new Color[width * height];&#10;            for (int i = 0; i &lt; pix.Length; i++)&#10;                pix[i] = color;&#10;            &#10;            Texture2D result = new Texture2D(width, height);&#10;            result.SetPixels(pix);&#10;            result.Apply();&#10;            return result;&#10;        }&#10;&#10;        private void OnGUI()&#10;        {&#10;            InitializeStyles();&#10;            &#10;            DrawHeader();&#10;            DrawFrequentPrefabs();&#10;            DrawFiltersAndSearch();&#10;            DrawQuickSettings();&#10;            DrawPrefabsList();&#10;            DrawBatchOperations();&#10;            &#10;            if (_autoRefresh &amp;&amp; GUI.changed)&#10;                ApplyFilters();&#10;            &#10;            HandlePlacementMode();&#10;            &#10;            if (_showRadialMenu)&#10;                Repaint();&#10;        }&#10;&#10;        private void DrawHeader()&#10;        {&#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.LabelField(&quot; Level Auditor &amp; Prefab Manager&quot;, _headerStyle ?? EditorStyles.boldLabel);&#10;            EditorGUILayout.LabelField($&quot;Found {_prefabs.Count} prefabs | Showing {_filteredPrefabs.Count}&quot;, EditorStyles.miniLabel);&#10;            &#10;            if (_placementMode)&#10;            {&#10;                string prefabName = _selectedPrefabForPlacement ? _selectedPrefabForPlacement.name : &quot;None&quot;;&#10;                EditorGUILayout.HelpBox($&quot; PLACEMENT MODE: {prefabName} - Click in Scene View to place&quot;, MessageType.Info);&#10;            }&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            if (GUILayout.Button(&quot; Refresh&quot;, GUILayout.Width(80)))&#10;                LoadPrefabs();&#10;            &#10;            _autoRefresh = GUILayout.Toggle(_autoRefresh, &quot;Auto Refresh&quot;, GUILayout.Width(100));&#10;            &#10;            GUILayout.FlexibleSpace();&#10;            &#10;            if (_placementMode &amp;&amp; GUILayout.Button(&quot;❌ Exit Placement&quot;, GUILayout.Width(120)))&#10;            {&#10;                _placementMode = false;&#10;                _selectedPrefabForPlacement = null;&#10;            }&#10;            &#10;            _batchMode = GUILayout.Toggle(_batchMode, &quot;Batch Mode&quot;, _buttonStyle ?? GUI.skin.button, GUILayout.Width(100));&#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawFrequentPrefabs()&#10;        {&#10;            if (_frequentPrefabs.Count == 0) return;&#10;            &#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.LabelField(&quot;⭐ Most Used Prefabs (Right-click in Scene for quick menu)&quot;, EditorStyles.boldLabel);&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            for (int i = 0; i &lt; Mathf.Min(_frequentPrefabs.Count, 6); i++)&#10;            {&#10;                GameObject prefab = _frequentPrefabs[i];&#10;                if (prefab == null) continue;&#10;                &#10;                Texture2D preview = GetPrefabPreview(prefab);&#10;                int usageCount = _prefabUsageCount.ContainsKey(prefab) ? _prefabUsageCount[prefab] : 0;&#10;                &#10;                // Create a vertical layout for the button content&#10;                EditorGUILayout.BeginVertical(GUILayout.Width(90), GUILayout.Height(80));&#10;                &#10;                // Draw preview image&#10;                if (preview != null)&#10;                {&#10;                    Rect imageRect = GUILayoutUtility.GetRect(64, 40, GUILayout.ExpandWidth(false));&#10;                    imageRect.x += (90 - 64) / 2; // Center the image&#10;                    GUI.DrawTexture(imageRect, preview, ScaleMode.ScaleToFit);&#10;                }&#10;                else&#10;                {&#10;                    GUILayoutUtility.GetRect(64, 40); // Reserve space even if no preview&#10;                }&#10;                &#10;                // Draw button with name and usage count&#10;                string buttonText = $&quot;{prefab.name}\n({usageCount})&quot;;&#10;                if (GUILayout.Button(buttonText, GUILayout.Height(35)))&#10;                {&#10;                    StartPlacementMode(prefab);&#10;                }&#10;                &#10;                EditorGUILayout.EndVertical();&#10;            }&#10;            &#10;            GUILayout.FlexibleSpace();&#10;            if (GUILayout.Button(&quot;️ Reset Usage&quot;, GUILayout.Width(100), GUILayout.Height(80)))&#10;            {&#10;                if (EditorUtility.DisplayDialog(&quot;Reset Usage Data&quot;, &quot;This will reset all prefab usage statistics.&quot;, &quot;Reset&quot;, &quot;Cancel&quot;))&#10;                {&#10;                    _prefabUsageCount.Clear();&#10;                    UpdateFrequentPrefabs();&#10;                    SaveUsageData();&#10;                }&#10;            }&#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawFiltersAndSearch()&#10;        {&#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.LabelField(&quot; Filters &amp; Search&quot;, EditorStyles.boldLabel);&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            EditorGUILayout.LabelField(&quot;Search:&quot;, GUILayout.Width(50));&#10;            string newSearch = EditorGUILayout.TextField(_searchFilter);&#10;            if (newSearch != _searchFilter)&#10;            {&#10;                _searchFilter = newSearch;&#10;                ApplyFilters();&#10;            }&#10;            EditorGUILayout.EndHorizontal();&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            EditorGUILayout.LabelField(&quot;Filter:&quot;, GUILayout.Width(50));&#10;            FilterType newFilter = (FilterType)EditorGUILayout.EnumPopup(_filterType);&#10;            if (newFilter != _filterType)&#10;            {&#10;                _filterType = newFilter;&#10;                ApplyFilters();&#10;            }&#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawQuickSettings()&#10;        {&#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.BeginHorizontal();&#10;            EditorGUILayout.LabelField(&quot;⚙️ Quick Settings&quot;, EditorStyles.boldLabel);&#10;            _showAdvancedSettings = EditorGUILayout.Foldout(_showAdvancedSettings, &quot;Advanced&quot;);&#10;            EditorGUILayout.EndHorizontal();&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            EditorGUILayout.LabelField(&quot;Grid Snap (PPU):&quot;, GUILayout.Width(100));&#10;            _ppu = EditorGUILayout.FloatField(_ppu, GUILayout.Width(60));&#10;            &#10;            EditorGUILayout.LabelField(&quot;Default Drop:&quot;, GUILayout.Width(80));&#10;            _defaultDropPrefab = (GameObject)EditorGUILayout.ObjectField(_defaultDropPrefab, typeof(GameObject), false);&#10;            EditorGUILayout.EndHorizontal();&#10;            &#10;            if (_showAdvancedSettings)&#10;            {&#10;                EditorGUILayout.BeginHorizontal();&#10;                if (GUILayout.Button(&quot; Batch Set Drops (Instances Only)&quot;))&#10;                    BatchSetDropsInstances();&#10;                EditorGUILayout.EndHorizontal();&#10;            }&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawPrefabsList()&#10;        {&#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.LabelField(&quot; Prefabs&quot;, EditorStyles.boldLabel);&#10;            &#10;            if (_filteredPrefabs.Count == 0)&#10;            {&#10;                EditorGUILayout.HelpBox(&quot;No prefabs match current filters.&quot;, MessageType.Info);&#10;                EditorGUILayout.EndVertical();&#10;                return;&#10;            }&#10;&#10;            _scrollPosition = EditorGUILayout.BeginScrollView(_scrollPosition, GUILayout.Height(300));&#10;            &#10;            for (int i = 0; i &lt; _filteredPrefabs.Count; i++)&#10;            {&#10;                DrawPrefabCard(_filteredPrefabs[i], i);&#10;            }&#10;            &#10;            EditorGUILayout.EndScrollView();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawPrefabCard(GameObject prefab, int index)&#10;        {&#10;            bool isSelected = _selectedPrefabs.Contains(index);&#10;            GUIStyle cardStyle = isSelected &amp;&amp; _selectedButtonStyle != null ? _selectedButtonStyle : &#10;                                (_cardStyle ?? GUI.skin.box);&#10;            &#10;            EditorGUILayout.BeginVertical(cardStyle);&#10;            &#10;            // Header with prefab info and preview&#10;            EditorGUILayout.BeginHorizontal();&#10;            &#10;            if (_batchMode)&#10;            {&#10;                bool newSelected = EditorGUILayout.Toggle(isSelected, GUILayout.Width(20));&#10;                if (newSelected != isSelected)&#10;                {&#10;                    if (newSelected)&#10;                        _selectedPrefabs.Add(index);&#10;                    else&#10;                        _selectedPrefabs.Remove(index);&#10;                }&#10;            }&#10;            &#10;            // Preview image&#10;            Texture2D preview = GetPrefabPreview(prefab);&#10;            if (preview != null)&#10;            {&#10;                GUILayout.Label(preview, GUILayout.Width(48), GUILayout.Height(48));&#10;            }&#10;            else&#10;            {&#10;                // Fallback - draw a colored box with emoji icon&#10;                GUIStyle iconStyle = new GUIStyle(GUI.skin.label)&#10;                {&#10;                    fontSize = 24,&#10;                    alignment = TextAnchor.MiddleCenter&#10;                };&#10;                &#10;                string icon = GetPrefabIcon(prefab);&#10;                Rect iconRect = GUILayoutUtility.GetRect(48, 48);&#10;                &#10;                // Draw background&#10;                EditorGUI.DrawRect(iconRect, new Color(0.3f, 0.3f, 0.3f, 0.5f));&#10;                GUI.Label(iconRect, icon, iconStyle);&#10;            }&#10;            &#10;            // Vertical layout for name and info&#10;            EditorGUILayout.BeginVertical();&#10;            &#10;            // Prefab name&#10;            EditorGUILayout.LabelField(prefab.name, EditorStyles.boldLabel);&#10;            &#10;            // Quick info badges in a horizontal layout&#10;            EditorGUILayout.BeginHorizontal();&#10;            DrawInfoBadges(prefab);&#10;            EditorGUILayout.EndHorizontal();&#10;            &#10;            EditorGUILayout.EndVertical();&#10;            &#10;            GUILayout.FlexibleSpace();&#10;            &#10;            EditorGUILayout.EndHorizontal();&#10;            &#10;            // Quick actions&#10;            EditorGUILayout.BeginHorizontal();&#10;            &#10;            if (GUILayout.Button(&quot;️ Place&quot;, GUILayout.Width(60)))&#10;                StartPlacementMode(prefab);&#10;            &#10;            if (GUILayout.Button(&quot; Instant&quot;, GUILayout.Width(60)))&#10;                PlacePrefabInstant(prefab);&#10;            &#10;            if (GUILayout.Button(&quot; Select&quot;, GUILayout.Width(60)))&#10;                Selection.activeObject = prefab;&#10;            &#10;            // Context-specific buttons&#10;            DrawContextButtons(prefab);&#10;            &#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;            &#10;            GUILayout.Space(2);&#10;        }&#10;&#10;        private Texture2D GetPrefabPreview(GameObject prefab)&#10;        {&#10;            if (_previewCache.ContainsKey(prefab) &amp;&amp; _previewCache[prefab] != null)&#10;                return _previewCache[prefab];&#10;            &#10;            // Try to get asset preview first&#10;            Texture2D preview = AssetPreview.GetAssetPreview(prefab);&#10;            &#10;            // If no preview available, try mini thumbnail&#10;            if (preview == null)&#10;                preview = AssetPreview.GetMiniThumbnail(prefab);&#10;            &#10;            // Cache the result (even if null to avoid repeated calls)&#10;            _previewCache[prefab] = preview;&#10;            &#10;            return preview;&#10;        }&#10;&#10;        private void DrawInfoBadges(GameObject prefab)&#10;        {&#10;            bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;            bool isContainer = prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp; &#10;                              prefab.GetComponent&lt;PowerUpContainer&gt;();&#10;            &#10;            if (isEnemy)&#10;            {&#10;                bool hasDrop = prefab.GetComponent&lt;EnemyDropOnDeath&gt;();&#10;                EditorGUILayout.LabelField(hasDrop ? &quot; Drops&quot; : &quot;❌ No Drop&quot;, &#10;                    EditorStyles.miniLabel, GUILayout.Width(60));&#10;            }&#10;            &#10;            if (isContainer)&#10;            {&#10;                bool hasLauncher = prefab.GetComponent&lt;ProximityLauncher&gt;();&#10;                EditorGUILayout.LabelField(hasLauncher ? &quot; Launcher&quot; : &quot; Static&quot;, &#10;                    EditorStyles.miniLabel, GUILayout.Width(70));&#10;            }&#10;            &#10;            // Layer info&#10;            EditorGUILayout.LabelField($&quot;Layer: {LayerMask.LayerToName(prefab.layer)}&quot;, &#10;                EditorStyles.miniLabel, GUILayout.Width(80));&#10;        }&#10;&#10;        private void DrawContextButtons(GameObject prefab)&#10;        {&#10;            bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;            bool isContainer = prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp; &#10;                              prefab.GetComponent&lt;PowerUpContainer&gt;();&#10;            &#10;            if (isEnemy)&#10;            {&#10;                bool hasDrop = prefab.GetComponent&lt;EnemyDropOnDeath&gt;();&#10;                if (GUILayout.Button(hasDrop ? &quot; Update Drop&quot; : &quot;➕ Add Drop&quot;, GUILayout.Width(100)))&#10;                {&#10;                    if (_defaultDropPrefab != null)&#10;                        ApplyEnemyDropSettingsToInstances(prefab, _defaultDropPrefab);&#10;                    else&#10;                        EditorUtility.DisplayDialog(&quot;No Drop Prefab&quot;, &quot;Please set a default drop prefab first!&quot;, &quot;OK&quot;);&#10;                }&#10;            }&#10;            &#10;            if (isContainer)&#10;            {&#10;                bool hasLauncher = prefab.GetComponent&lt;ProximityLauncher&gt;();&#10;                if (GUILayout.Button(hasLauncher ? &quot; Remove Launcher&quot; : &quot;➕ Add Launcher&quot;, GUILayout.Width(120)))&#10;                    ApplyContainerSettingsToInstances(prefab, !hasLauncher);&#10;            }&#10;        }&#10;&#10;        private void DrawBatchOperations()&#10;        {&#10;            if (!_batchMode || _selectedPrefabs.Count == 0) return;&#10;            &#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.LabelField($&quot; Batch Operations ({_selectedPrefabs.Count} selected)&quot;, EditorStyles.boldLabel);&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            if (GUILayout.Button(&quot;️ Place All&quot;))&#10;                BatchPlaceSelectedWithMouse();&#10;            if (GUILayout.Button(&quot; Instant Place&quot;))&#10;                BatchPlaceSelected();&#10;            if (GUILayout.Button(&quot; Set Drops&quot;))&#10;                BatchSetDropsSelected();&#10;            if (GUILayout.Button(&quot; Toggle Launchers&quot;))&#10;                BatchToggleLaunchers();&#10;            if (GUILayout.Button(&quot;❌ Clear Selection&quot;))&#10;                _selectedPrefabs.Clear();&#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void OnSceneGUI(SceneView sceneView)&#10;        {&#10;            Event e = Event.current;&#10;            &#10;            // Handle right-click for radial menu&#10;            if (e.type == EventType.MouseDown &amp;&amp; e.button == 1 &amp;&amp; !_placementMode)&#10;            {&#10;                _showRadialMenu = true;&#10;                _radialMenuPosition = e.mousePosition;&#10;                sceneView.Repaint();&#10;                e.Use();&#10;                return;&#10;            }&#10;            &#10;            // Handle radial menu&#10;            if (_showRadialMenu)&#10;            {&#10;                HandleRadialMenu(sceneView);&#10;                return;&#10;            }&#10;            &#10;            // Handle placement mode&#10;            if (_placementMode &amp;&amp; _selectedPrefabForPlacement != null)&#10;            {&#10;                if (e.type == EventType.KeyDown &amp;&amp; e.keyCode == KeyCode.Escape)&#10;                {&#10;                    _placementMode = false;&#10;                    _selectedPrefabForPlacement = null;&#10;                    e.Use();&#10;                    return;&#10;                }&#10;&#10;                if (e.type == EventType.MouseDown &amp;&amp; e.button == 0)&#10;                {&#10;                    Ray ray = HandleUtility.GUIPointToWorldRay(e.mousePosition);&#10;                    Vector3 worldPos = ray.origin;&#10;                    worldPos.z = 0; // Assuming 2D game&#10;&#10;                    // Grid snap if Shift is held&#10;                    if (e.shift &amp;&amp; _ppu &gt; 0)&#10;                    {&#10;                        worldPos.x = Mathf.Round(worldPos.x * _ppu) / _ppu;&#10;                        worldPos.y = Mathf.Round(worldPos.y * _ppu) / _ppu;&#10;                    }&#10;&#10;                    PlacePrefabAtPosition(_selectedPrefabForPlacement, worldPos);&#10;                    e.Use();&#10;                }&#10;&#10;                // Draw preview at mouse position&#10;                if (e.type == EventType.Repaint)&#10;                {&#10;                    Ray ray = HandleUtility.GUIPointToWorldRay(e.mousePosition);&#10;                    Vector3 worldPos = ray.origin;&#10;                    worldPos.z = 0;&#10;&#10;                    if (e.shift &amp;&amp; _ppu &gt; 0)&#10;                    {&#10;                        worldPos.x = Mathf.Round(worldPos.x * _ppu) / _ppu;&#10;                        worldPos.y = Mathf.Round(worldPos.y * _ppu) / _ppu;&#10;                    }&#10;&#10;                    Handles.color = Color.yellow;&#10;                    Handles.DrawWireCube(worldPos, Vector3.one * 0.5f);&#10;                    Handles.Label(worldPos + Vector3.up * 0.5f, _selectedPrefabForPlacement.name);&#10;                }&#10;&#10;                HandleUtility.AddDefaultControl(GUIUtility.GetControlID(FocusType.Passive));&#10;            }&#10;        }&#10;&#10;        private void HandleRadialMenu(SceneView sceneView)&#10;        {&#10;            Event e = Event.current;&#10;            &#10;            // Draw radial menu&#10;            Handles.BeginGUI();&#10;            &#10;            Vector2 center = _radialMenuPosition;&#10;            float radius = 80f;&#10;            &#10;            // Background circle&#10;            Handles.color = new Color(0, 0, 0, 0.5f);&#10;            Handles.DrawSolidDisc(center, Vector3.forward, radius);&#10;            &#10;            Handles.color = Color.white;&#10;            Handles.DrawWireDisc(center, Vector3.forward, radius);&#10;            &#10;            // Draw prefab options in circle&#10;            int prefabCount = Mathf.Min(_frequentPrefabs.Count, MAX_FREQUENT_PREFABS);&#10;            for (int i = 0; i &lt; prefabCount; i++)&#10;            {&#10;                if (_frequentPrefabs[i] == null) continue;&#10;                &#10;                float angle = (i / (float)prefabCount) * 360f - 90f; // Start from top&#10;                Vector2 direction = new Vector2(Mathf.Cos(angle * Mathf.Deg2Rad), Mathf.Sin(angle * Mathf.Deg2Rad));&#10;                Vector2 buttonPos = center + direction * (radius * 0.7f);&#10;                &#10;                // Highlight if mouse is over&#10;                Vector2 mousePos = e.mousePosition;&#10;                bool isHovered = Vector2.Distance(mousePos, buttonPos) &lt; 30f;&#10;                &#10;                if (isHovered)&#10;                {&#10;                    Handles.color = Color.yellow;&#10;                    Handles.DrawSolidDisc(buttonPos, Vector3.forward, 30f);&#10;                    Handles.color = Color.white;&#10;                }&#10;                &#10;                // Draw preview image or fallback icon&#10;                Texture2D preview = GetPrefabPreview(_frequentPrefabs[i]);&#10;                if (preview != null)&#10;                {&#10;                    // Draw the preview image&#10;                    Rect imageRect = new Rect(buttonPos.x - 20, buttonPos.y - 20, 40, 40);&#10;                    GUI.DrawTexture(imageRect, preview, ScaleMode.ScaleToFit);&#10;                }&#10;                else&#10;                {&#10;                    // Draw fallback colored circle with emoji&#10;                    Handles.color = new Color(0.4f, 0.4f, 0.4f, 0.8f);&#10;                    Handles.DrawSolidDisc(buttonPos, Vector3.forward, 20f);&#10;                    &#10;                    string icon = GetPrefabIcon(_frequentPrefabs[i]);&#10;                    GUIStyle iconStyle = new GUIStyle(GUI.skin.label)&#10;                    {&#10;                        fontSize = 16,&#10;                        alignment = TextAnchor.MiddleCenter,&#10;                        normal = { textColor = Color.white }&#10;                    };&#10;                    &#10;                    GUI.Label(new Rect(buttonPos.x - 15, buttonPos.y - 10, 30, 20), icon, iconStyle);&#10;                    Handles.color = Color.white;&#10;                }&#10;                &#10;                // Draw name below&#10;                string displayName = _frequentPrefabs[i].name;&#10;                if (displayName.Length &gt; 8) displayName = displayName.Substring(0, 8) + &quot;...&quot;;&#10;                &#10;                GUI.Label(new Rect(buttonPos.x - 30, buttonPos.y + 25, 60, 20), displayName, EditorStyles.centeredGreyMiniLabel);&#10;                &#10;                // Handle click&#10;                if (isHovered &amp;&amp; e.type == EventType.MouseDown &amp;&amp; e.button == 0)&#10;                {&#10;                    StartPlacementMode(_frequentPrefabs[i]);&#10;                    _showRadialMenu = false;&#10;                    e.Use();&#10;                }&#10;            }&#10;            &#10;            // Close menu if clicked outside or right-clicked&#10;            if ((e.type == EventType.MouseDown &amp;&amp; Vector2.Distance(e.mousePosition, center) &gt; radius) ||&#10;                (e.type == EventType.MouseDown &amp;&amp; e.button == 1))&#10;            {&#10;                _showRadialMenu = false;&#10;                e.Use();&#10;            }&#10;            &#10;            // Instructions&#10;            GUI.Label(new Rect(center.x - 100, center.y + radius + 10, 200, 20), &#10;                &quot;Click prefab to place • Right-click to cancel&quot;, EditorStyles.centeredGreyMiniLabel);&#10;            &#10;            Handles.EndGUI();&#10;            &#10;            sceneView.Repaint();&#10;        }&#10;&#10;        private void StartPlacementMode(GameObject prefab)&#10;        {&#10;            _placementMode = true;&#10;            _selectedPrefabForPlacement = prefab;&#10;            &#10;            // Track usage&#10;            IncrementPrefabUsage(prefab);&#10;            &#10;            EditorUtility.DisplayDialog(&quot;Placement Mode&quot;, &#10;                $&quot;Click in Scene View to place {prefab.name}.\nHold Shift for grid snap.\nRight-click for quick menu.\nPress Escape to stop.&quot;, &quot;OK&quot;);&#10;        }&#10;&#10;        private void HandlePlacementMode()&#10;        {&#10;            if (_placementMode &amp;&amp; _selectedPrefabForPlacement == null)&#10;            {&#10;                _placementMode = false;&#10;            }&#10;        }&#10;&#10;        // Usage Tracking System&#10;        private void IncrementPrefabUsage(GameObject prefab)&#10;        {&#10;            if (_prefabUsageCount.ContainsKey(prefab))&#10;                _prefabUsageCount[prefab]++;&#10;            else&#10;                _prefabUsageCount[prefab] = 1;&#10;            &#10;            UpdateFrequentPrefabs();&#10;            SaveUsageData();&#10;        }&#10;&#10;        private void UpdateFrequentPrefabs()&#10;        {&#10;            _frequentPrefabs.Clear();&#10;            &#10;            var sortedPrefabs = _prefabUsageCount&#10;                .Where(kvp =&gt; kvp.Key != null)&#10;                .OrderByDescending(kvp =&gt; kvp.Value)&#10;                .Take(MAX_FREQUENT_PREFABS)&#10;                .Select(kvp =&gt; kvp.Key);&#10;            &#10;            _frequentPrefabs.AddRange(sortedPrefabs);&#10;        }&#10;&#10;        private void SaveUsageData()&#10;        {&#10;            string data = &quot;&quot;;&#10;            foreach (var kvp in _prefabUsageCount)&#10;            {&#10;                if (kvp.Key != null)&#10;                {&#10;                    string guid = AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(kvp.Key));&#10;                    data += $&quot;{guid}:{kvp.Value};&quot;;&#10;                }&#10;            }&#10;            EditorPrefs.SetString(&quot;PrefabAuditor_UsageData&quot;, data);&#10;        }&#10;&#10;        private void LoadUsageData()&#10;        {&#10;            _prefabUsageCount.Clear();&#10;            string data = EditorPrefs.GetString(&quot;PrefabAuditor_UsageData&quot;, &quot;&quot;);&#10;            &#10;            if (string.IsNullOrEmpty(data)) return;&#10;            &#10;            string[] entries = data.Split(';');&#10;            foreach (string entry in entries)&#10;            {&#10;                if (string.IsNullOrEmpty(entry)) continue;&#10;                &#10;                string[] parts = entry.Split(':');&#10;                if (parts.Length == 2)&#10;                {&#10;                    string guid = parts[0];&#10;                    if (int.TryParse(parts[1], out int count))&#10;                    {&#10;                        string path = AssetDatabase.GUIDToAssetPath(guid);&#10;                        GameObject prefab = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);&#10;                        if (prefab != null)&#10;                        {&#10;                            _prefabUsageCount[prefab] = count;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Batch Operations&#10;        private void BatchPlaceSelectedWithMouse()&#10;        {&#10;            if (_selectedPrefabs.Count == 0) return;&#10;            &#10;            // Start placement mode with first selected prefab&#10;            if (_selectedPrefabs.Count &gt; 0 &amp;&amp; _selectedPrefabs[0] &lt; _filteredPrefabs.Count)&#10;            {&#10;                StartPlacementMode(_filteredPrefabs[_selectedPrefabs[0]]);&#10;            }&#10;        }&#10;&#10;        private void BatchPlaceSelected()&#10;        {&#10;            Vector3 basePos = Vector3.zero;&#10;            foreach (int index in _selectedPrefabs)&#10;            {&#10;                if (index &lt; _filteredPrefabs.Count)&#10;                {&#10;                    PlacePrefabAtPosition(_filteredPrefabs[index], basePos);&#10;                    basePos.x += 2f; // Offset each placement&#10;                }&#10;            }&#10;        }&#10;&#10;        private void BatchSetDropsSelected()&#10;        {&#10;            if (_defaultDropPrefab == null)&#10;            {&#10;                EditorUtility.DisplayDialog(&quot;No Drop Prefab&quot;, &quot;Please set a default drop prefab first!&quot;, &quot;OK&quot;);&#10;                return;&#10;            }&#10;            &#10;            foreach (int index in _selectedPrefabs)&#10;            {&#10;                if (index &lt; _filteredPrefabs.Count)&#10;                {&#10;                    GameObject prefab = _filteredPrefabs[index];&#10;                    bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;                    if (isEnemy)&#10;                        ApplyEnemyDropSettingsToInstances(prefab, _defaultDropPrefab);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void BatchToggleLaunchers()&#10;        {&#10;            foreach (int index in _selectedPrefabs)&#10;            {&#10;                if (index &lt; _filteredPrefabs.Count)&#10;                {&#10;                    GameObject prefab = _filteredPrefabs[index];&#10;                    bool isContainer = prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp; &#10;                                      prefab.GetComponent&lt;PowerUpContainer&gt;();&#10;                    if (isContainer)&#10;                    {&#10;                        bool hasLauncher = prefab.GetComponent&lt;ProximityLauncher&gt;();&#10;                        ApplyContainerSettingsToInstances(prefab, !hasLauncher);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void BatchSetDropsInstances()&#10;        {&#10;            if (_defaultDropPrefab == null)&#10;            {&#10;                EditorUtility.DisplayDialog(&quot;No Drop Prefab&quot;, &quot;Please set a default drop prefab first!&quot;, &quot;OK&quot;);&#10;                return;&#10;            }&#10;            &#10;            int updatedCount = 0;&#10;            foreach (GameObject prefab in _filteredPrefabs)&#10;            {&#10;                bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;                if (isEnemy)&#10;                {&#10;                    ApplyEnemyDropSettingsToInstances(prefab, _defaultDropPrefab);&#10;                    updatedCount++;&#10;                }&#10;            }&#10;            EditorUtility.DisplayDialog(&quot;Batch Set Drops&quot;, $&quot;Updated drop settings for {updatedCount} enemy instances in scene.&quot;, &quot;OK&quot;);&#10;        }&#10;&#10;        // Placement Methods (Instance-only modifications)&#10;        private void PlacePrefabInstant(GameObject prefab)&#10;        {&#10;            PlacePrefabAtPosition(prefab, Vector3.zero);&#10;        }&#10;&#10;        private void PlacePrefabAtPosition(GameObject prefab, Vector3 position)&#10;        {&#10;            try&#10;            {&#10;                GameObject go = (GameObject)PrefabUtility.InstantiatePrefab(prefab);&#10;                go.transform.position = position;&#10;                Selection.activeGameObject = go;&#10;                &#10;                // Track usage&#10;                IncrementPrefabUsage(prefab);&#10;                &#10;                // Apply instance modifications if this is an enemy with no drop settings&#10;                bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;                if (isEnemy &amp;&amp; _defaultDropPrefab != null &amp;&amp; !prefab.GetComponent&lt;EnemyDropOnDeath&gt;())&#10;                {&#10;                    EnemyDropOnDeath enemyDrop = go.AddComponent&lt;EnemyDropOnDeath&gt;();&#10;                    enemyDrop.dropPrefab = _defaultDropPrefab;&#10;                }&#10;            }&#10;            catch (System.Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to place prefab {prefab.name}: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        // Instance-only modification methods&#10;        private void ApplyEnemyDropSettingsToInstances(GameObject prefab, GameObject dropPrefab)&#10;        {&#10;            // Find all instances of this prefab in the scene and update them&#10;            GameObject[] allObjects = Object.FindObjectsByType&lt;GameObject&gt;(FindObjectsSortMode.None);&#10;            int updatedCount = 0;&#10;            &#10;            foreach (GameObject obj in allObjects)&#10;            {&#10;                if (PrefabUtility.GetCorrespondingObjectFromSource(obj) == prefab)&#10;                {&#10;                    try&#10;                    {&#10;                        EnemyDropOnDeath enemyDrop = obj.GetComponent&lt;EnemyDropOnDeath&gt;() ?? &#10;                                                    obj.AddComponent&lt;EnemyDropOnDeath&gt;();&#10;                        enemyDrop.dropPrefab = dropPrefab;&#10;                        EditorUtility.SetDirty(obj);&#10;                        updatedCount++;&#10;                    }&#10;                    catch (System.Exception e)&#10;                    {&#10;                        Debug.LogError($&quot;Failed to apply enemy drop settings to instance {obj.name}: {e.Message}&quot;);&#10;                    }&#10;                }&#10;            }&#10;            &#10;            if (updatedCount &gt; 0)&#10;                EditorUtility.DisplayDialog(&quot;Updated Instances&quot;, $&quot;Updated {updatedCount} instances of {prefab.name} in the scene.&quot;, &quot;OK&quot;);&#10;            else&#10;                EditorUtility.DisplayDialog(&quot;No Instances&quot;, $&quot;No instances of {prefab.name} found in the current scene.&quot;, &quot;OK&quot;);&#10;        }&#10;&#10;        private void ApplyContainerSettingsToInstances(GameObject prefab, bool hasProximityLauncher)&#10;        {&#10;            // Find all instances of this prefab in the scene and update them&#10;            GameObject[] allObjects = Object.FindObjectsByType&lt;GameObject&gt;(FindObjectsSortMode.None);&#10;            int updatedCount = 0;&#10;            &#10;            foreach (GameObject obj in allObjects)&#10;            {&#10;                if (PrefabUtility.GetCorrespondingObjectFromSource(obj) == prefab)&#10;                {&#10;                    try&#10;                    {&#10;                        ProximityLauncher launcher = obj.GetComponent&lt;ProximityLauncher&gt;();&#10;                        if (hasProximityLauncher &amp;&amp; launcher == null)&#10;                            obj.AddComponent&lt;ProximityLauncher&gt;();&#10;                        else if (!hasProximityLauncher &amp;&amp; launcher)&#10;                            DestroyImmediate(launcher);&#10;&#10;                        EditorUtility.SetDirty(obj);&#10;                        updatedCount++;&#10;                    }&#10;                    catch (System.Exception e)&#10;                    {&#10;                        Debug.LogError($&quot;Failed to apply container settings to instance {obj.name}: {e.Message}&quot;);&#10;                    }&#10;                }&#10;            }&#10;            &#10;            if (updatedCount &gt; 0)&#10;                EditorUtility.DisplayDialog(&quot;Updated Instances&quot;, $&quot;Updated {updatedCount} instances of {prefab.name} in the scene.&quot;, &quot;OK&quot;);&#10;            else&#10;                EditorUtility.DisplayDialog(&quot;No Instances&quot;, $&quot;No instances of {prefab.name} found in the current scene.&quot;, &quot;OK&quot;);&#10;        }&#10;&#10;        private void ApplyFilters()&#10;        {&#10;            _filteredPrefabs.Clear();&#10;            &#10;            foreach (GameObject prefab in _prefabs)&#10;            {&#10;                if (!MatchesSearch(prefab)) continue;&#10;                if (!MatchesFilter(prefab)) continue;&#10;                &#10;                _filteredPrefabs.Add(prefab);&#10;            }&#10;        }&#10;&#10;        private bool MatchesSearch(GameObject prefab)&#10;        {&#10;            if (string.IsNullOrEmpty(_searchFilter)) return true;&#10;            return prefab.name.ToLower().Contains(_searchFilter.ToLower());&#10;        }&#10;&#10;        private bool MatchesFilter(GameObject prefab)&#10;        {&#10;            switch (_filterType)&#10;            {&#10;                case FilterType.Enemies:&#10;                    return (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;                case FilterType.Containers:&#10;                    return prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp; &#10;                           prefab.GetComponent&lt;PowerUpContainer&gt;();&#10;                case FilterType.Others:&#10;                    bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;                    bool isContainer = prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp; &#10;                                      prefab.GetComponent&lt;PowerUpContainer&gt;();&#10;                    return !isEnemy &amp;&amp; !isContainer;&#10;                default:&#10;                    return true;&#10;            }&#10;        }&#10;&#10;        // Utility Methods&#10;        private void LoadPrefabs()&#10;        {&#10;            _prefabs.Clear();&#10;            _previewCache.Clear(); // Clear preview cache when reloading&#10;            &#10;            string[] guids = AssetDatabase.FindAssets(&quot;t:Prefab&quot;, new[] { &quot;Assets/Prefabs&quot; });&#10;            foreach (string guid in guids)&#10;            {&#10;                string path = AssetDatabase.GUIDToAssetPath(guid);&#10;                GameObject prefab = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);&#10;                if (prefab)&#10;                    _prefabs.Add(prefab);&#10;            }&#10;            ApplyFilters();&#10;        }&#10;&#10;        [MenuItem(&quot;Tools/Level Auditor &amp; Prefab Manager&quot;)]&#10;        public static void ShowWindow()&#10;        {&#10;            var window = GetWindow&lt;PrefabAuditorWindow&gt;(&quot;Level Auditor&quot;);&#10;            window.minSize = new Vector2(500, 600);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using System.Linq;&#10;using Enemies.Behaviors;&#10;using PowerUps.Container;&#10;using UnityEditor;&#10;using UnityEngine;&#10;using Utilities;&#10;&#10;namespace Editor&#10;{&#10;    public class PrefabAuditorWindow : EditorWindow&#10;    {&#10;        private readonly List&lt;GameObject&gt; _prefabs = new();&#10;        private readonly List&lt;GameObject&gt; _filteredPrefabs = new();&#10;        private Vector2 _scrollPosition;&#10;        private string _searchFilter = &quot;&quot;;&#10;        private FilterType _filterType = FilterType.All;&#10;        private bool _autoRefresh = true;&#10;        &#10;        // Quick settings&#10;        private float _ppu = 16f;&#10;        private GameObject _defaultDropPrefab;&#10;        private bool _showAdvancedSettings = false;&#10;        private bool _placementMode = false;&#10;        private GameObject _selectedPrefabForPlacement;&#10;        &#10;        // Radial Menu System&#10;        private bool _showRadialMenu = false;&#10;        private Vector2 _radialMenuPosition;&#10;        private readonly Dictionary&lt;GameObject, int&gt; _prefabUsageCount = new();&#10;        private List&lt;GameObject&gt; _frequentPrefabs = new();&#10;        private const int MAX_FREQUENT_PREFABS = 8;&#10;        &#10;        // Batch operations&#10;        private readonly List&lt;int&gt; _selectedPrefabs = new();&#10;        private bool _batchMode = false;&#10;        &#10;        // UI Colors and Styles&#10;        private static GUIStyle _headerStyle;&#10;        private static GUIStyle _cardStyle;&#10;        private static GUIStyle _buttonStyle;&#10;        private static GUIStyle _selectedButtonStyle;&#10;        &#10;        // Preview icon cache&#10;        private readonly Dictionary&lt;GameObject, Texture2D&gt; _previewCache = new();&#10;        &#10;        private enum FilterType&#10;        {&#10;            All,&#10;            Enemies,&#10;            Containers,&#10;            Others&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            LoadPrefabs();&#10;            LoadUsageData();&#10;            UpdateFrequentPrefabs();&#10;            SceneView.duringSceneGui += OnSceneGUI;&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            SaveUsageData();&#10;            SceneView.duringSceneGui -= OnSceneGUI;&#10;        }&#10;&#10;        private void InitializeStyles()&#10;        {&#10;            if (_headerStyle != null) return; // Already initialized&#10;            &#10;            _headerStyle = new GUIStyle(EditorStyles.boldLabel)&#10;            {&#10;                fontSize = 14,&#10;                normal = { textColor = EditorGUIUtility.isProSkin ? Color.white : Color.black }&#10;            };&#10;            &#10;            _cardStyle = new GUIStyle(GUI.skin.box)&#10;            {&#10;                padding = new RectOffset(10, 10, 10, 10),&#10;                margin = new RectOffset(5, 5, 2, 2)&#10;            };&#10;            &#10;            _buttonStyle = new GUIStyle(GUI.skin.button)&#10;            {&#10;                padding = new RectOffset(10, 10, 5, 5)&#10;            };&#10;            &#10;            _selectedButtonStyle = new GUIStyle(_buttonStyle)&#10;            {&#10;                normal = { background = EditorGUIUtility.isProSkin ? &#10;                    MakeTex(1, 1, new Color(0.3f, 0.5f, 0.8f, 1f)) : &#10;                    MakeTex(1, 1, new Color(0.6f, 0.8f, 1f, 1f)) }&#10;            };&#10;        }&#10;&#10;        private Texture2D MakeTex(int width, int height, Color color)&#10;        {&#10;            Color[] pix = new Color[width * height];&#10;            for (int i = 0; i &lt; pix.Length; i++)&#10;                pix[i] = color;&#10;            &#10;            Texture2D result = new Texture2D(width, height);&#10;            result.SetPixels(pix);&#10;            result.Apply();&#10;            return result;&#10;        }&#10;&#10;        private void OnGUI()&#10;        {&#10;            InitializeStyles();&#10;            &#10;            DrawHeader();&#10;            DrawFrequentPrefabs();&#10;            DrawFiltersAndSearch();&#10;            DrawQuickSettings();&#10;            DrawPrefabsList();&#10;            DrawBatchOperations();&#10;            &#10;            if (_autoRefresh &amp;&amp; GUI.changed)&#10;                ApplyFilters();&#10;            &#10;            HandlePlacementMode();&#10;            &#10;            if (_showRadialMenu)&#10;                Repaint();&#10;        }&#10;&#10;        private void DrawHeader()&#10;        {&#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.LabelField(&quot; Level Auditor &amp; Prefab Manager&quot;, _headerStyle ?? EditorStyles.boldLabel);&#10;            EditorGUILayout.LabelField($&quot;Found {_prefabs.Count} prefabs | Showing {_filteredPrefabs.Count}&quot;, EditorStyles.miniLabel);&#10;            &#10;            if (_placementMode)&#10;            {&#10;                string prefabName = _selectedPrefabForPlacement ? _selectedPrefabForPlacement.name : &quot;None&quot;;&#10;                EditorGUILayout.HelpBox($&quot; PLACEMENT MODE: {prefabName} - Click in Scene View to place&quot;, MessageType.Info);&#10;            }&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            if (GUILayout.Button(&quot; Refresh&quot;, GUILayout.Width(80)))&#10;                LoadPrefabs();&#10;            &#10;            _autoRefresh = GUILayout.Toggle(_autoRefresh, &quot;Auto Refresh&quot;, GUILayout.Width(100));&#10;            &#10;            GUILayout.FlexibleSpace();&#10;            &#10;            if (_placementMode &amp;&amp; GUILayout.Button(&quot;❌ Exit Placement&quot;, GUILayout.Width(120)))&#10;            {&#10;                _placementMode = false;&#10;                _selectedPrefabForPlacement = null;&#10;            }&#10;            &#10;            _batchMode = GUILayout.Toggle(_batchMode, &quot;Batch Mode&quot;, _buttonStyle ?? GUI.skin.button, GUILayout.Width(100));&#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawFrequentPrefabs()&#10;        {&#10;            if (_frequentPrefabs.Count == 0) return;&#10;            &#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.LabelField(&quot;⭐ Most Used Prefabs (Right-click in Scene for quick menu)&quot;, EditorStyles.boldLabel);&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            for (int i = 0; i &lt; Mathf.Min(_frequentPrefabs.Count, 6); i++)&#10;            {&#10;                GameObject prefab = _frequentPrefabs[i];&#10;                if (prefab == null) continue;&#10;                &#10;                Texture2D preview = GetPrefabPreview(prefab);&#10;                int usageCount = _prefabUsageCount.ContainsKey(prefab) ? _prefabUsageCount[prefab] : 0;&#10;                &#10;                // Create a vertical layout for the button content&#10;                EditorGUILayout.BeginVertical(GUILayout.Width(90), GUILayout.Height(80));&#10;                &#10;                // Draw preview image&#10;                if (preview != null)&#10;                {&#10;                    Rect imageRect = GUILayoutUtility.GetRect(64, 40, GUILayout.ExpandWidth(false));&#10;                    imageRect.x += (90 - 64) / 2; // Center the image&#10;                    GUI.DrawTexture(imageRect, preview, ScaleMode.ScaleToFit);&#10;                }&#10;                else&#10;                {&#10;                    GUILayoutUtility.GetRect(64, 40); // Reserve space even if no preview&#10;                }&#10;                &#10;                // Draw button with name and usage count&#10;                string buttonText = $&quot;{prefab.name}\n({usageCount})&quot;;&#10;                if (GUILayout.Button(buttonText, GUILayout.Height(35)))&#10;                {&#10;                    StartPlacementMode(prefab);&#10;                }&#10;                &#10;                EditorGUILayout.EndVertical();&#10;            }&#10;            &#10;            GUILayout.FlexibleSpace();&#10;            if (GUILayout.Button(&quot;️ Reset Usage&quot;, GUILayout.Width(100), GUILayout.Height(80)))&#10;            {&#10;                if (EditorUtility.DisplayDialog(&quot;Reset Usage Data&quot;, &quot;This will reset all prefab usage statistics.&quot;, &quot;Reset&quot;, &quot;Cancel&quot;))&#10;                {&#10;                    _prefabUsageCount.Clear();&#10;                    UpdateFrequentPrefabs();&#10;                    SaveUsageData();&#10;                }&#10;            }&#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawFiltersAndSearch()&#10;        {&#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.LabelField(&quot; Filters &amp; Search&quot;, EditorStyles.boldLabel);&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            EditorGUILayout.LabelField(&quot;Search:&quot;, GUILayout.Width(50));&#10;            string newSearch = EditorGUILayout.TextField(_searchFilter);&#10;            if (newSearch != _searchFilter)&#10;            {&#10;                _searchFilter = newSearch;&#10;                ApplyFilters();&#10;            }&#10;            EditorGUILayout.EndHorizontal();&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            EditorGUILayout.LabelField(&quot;Filter:&quot;, GUILayout.Width(50));&#10;            FilterType newFilter = (FilterType)EditorGUILayout.EnumPopup(_filterType);&#10;            if (newFilter != _filterType)&#10;            {&#10;                _filterType = newFilter;&#10;                ApplyFilters();&#10;            }&#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawQuickSettings()&#10;        {&#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.BeginHorizontal();&#10;            EditorGUILayout.LabelField(&quot;⚙️ Quick Settings&quot;, EditorStyles.boldLabel);&#10;            _showAdvancedSettings = EditorGUILayout.Foldout(_showAdvancedSettings, &quot;Advanced&quot;);&#10;            EditorGUILayout.EndHorizontal();&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            EditorGUILayout.LabelField(&quot;Grid Snap (PPU):&quot;, GUILayout.Width(100));&#10;            _ppu = EditorGUILayout.FloatField(_ppu, GUILayout.Width(60));&#10;            &#10;            EditorGUILayout.LabelField(&quot;Default Drop:&quot;, GUILayout.Width(80));&#10;            _defaultDropPrefab = (GameObject)EditorGUILayout.ObjectField(_defaultDropPrefab, typeof(GameObject), false);&#10;            EditorGUILayout.EndHorizontal();&#10;            &#10;            if (_showAdvancedSettings)&#10;            {&#10;                EditorGUILayout.BeginHorizontal();&#10;                if (GUILayout.Button(&quot; Batch Set Drops (Instances Only)&quot;))&#10;                    BatchSetDropsInstances();&#10;                EditorGUILayout.EndHorizontal();&#10;            }&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawPrefabsList()&#10;        {&#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.LabelField(&quot; Prefabs&quot;, EditorStyles.boldLabel);&#10;            &#10;            if (_filteredPrefabs.Count == 0)&#10;            {&#10;                EditorGUILayout.HelpBox(&quot;No prefabs match current filters.&quot;, MessageType.Info);&#10;                EditorGUILayout.EndVertical();&#10;                return;&#10;            }&#10;&#10;            _scrollPosition = EditorGUILayout.BeginScrollView(_scrollPosition, GUILayout.Height(300));&#10;            &#10;            for (int i = 0; i &lt; _filteredPrefabs.Count; i++)&#10;            {&#10;                DrawPrefabCard(_filteredPrefabs[i], i);&#10;            }&#10;            &#10;            EditorGUILayout.EndScrollView();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawPrefabCard(GameObject prefab, int index)&#10;        {&#10;            bool isSelected = _selectedPrefabs.Contains(index);&#10;            GUIStyle cardStyle = isSelected &amp;&amp; _selectedButtonStyle != null ? _selectedButtonStyle : &#10;                                (_cardStyle ?? GUI.skin.box);&#10;            &#10;            EditorGUILayout.BeginVertical(cardStyle);&#10;            &#10;            // Header with prefab info and preview&#10;            EditorGUILayout.BeginHorizontal();&#10;            &#10;            if (_batchMode)&#10;            {&#10;                bool newSelected = EditorGUILayout.Toggle(isSelected, GUILayout.Width(20));&#10;                if (newSelected != isSelected)&#10;                {&#10;                    if (newSelected)&#10;                        _selectedPrefabs.Add(index);&#10;                    else&#10;                        _selectedPrefabs.Remove(index);&#10;                }&#10;            }&#10;            &#10;            // Preview image&#10;            Texture2D preview = GetPrefabPreview(prefab);&#10;            if (preview != null)&#10;            {&#10;                GUILayout.Label(preview, GUILayout.Width(48), GUILayout.Height(48));&#10;            }&#10;            else&#10;            {&#10;                // Fallback - draw a colored box with emoji icon&#10;                GUIStyle iconStyle = new GUIStyle(GUI.skin.label)&#10;                {&#10;                    fontSize = 24,&#10;                    alignment = TextAnchor.MiddleCenter&#10;                };&#10;                &#10;                string icon = GetPrefabIcon(prefab);&#10;                Rect iconRect = GUILayoutUtility.GetRect(48, 48);&#10;                &#10;                // Draw background&#10;                EditorGUI.DrawRect(iconRect, new Color(0.3f, 0.3f, 0.3f, 0.5f));&#10;                GUI.Label(iconRect, icon, iconStyle);&#10;            }&#10;            &#10;            // Vertical layout for name and info&#10;            EditorGUILayout.BeginVertical();&#10;            &#10;            // Prefab name&#10;            EditorGUILayout.LabelField(prefab.name, EditorStyles.boldLabel);&#10;            &#10;            // Quick info badges in a horizontal layout&#10;            EditorGUILayout.BeginHorizontal();&#10;            DrawInfoBadges(prefab);&#10;            EditorGUILayout.EndHorizontal();&#10;            &#10;            EditorGUILayout.EndVertical();&#10;            &#10;            GUILayout.FlexibleSpace();&#10;            &#10;            EditorGUILayout.EndHorizontal();&#10;            &#10;            // Quick actions&#10;            EditorGUILayout.BeginHorizontal();&#10;            &#10;            if (GUILayout.Button(&quot;️ Place&quot;, GUILayout.Width(60)))&#10;                StartPlacementMode(prefab);&#10;            &#10;            if (GUILayout.Button(&quot; Instant&quot;, GUILayout.Width(60)))&#10;                PlacePrefabInstant(prefab);&#10;            &#10;            if (GUILayout.Button(&quot; Select&quot;, GUILayout.Width(60)))&#10;                Selection.activeObject = prefab;&#10;            &#10;            // Context-specific buttons&#10;            DrawContextButtons(prefab);&#10;            &#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;            &#10;            GUILayout.Space(2);&#10;        }&#10;&#10;        private Texture2D GetPrefabPreview(GameObject prefab)&#10;        {&#10;            if (_previewCache.ContainsKey(prefab) &amp;&amp; _previewCache[prefab] != null)&#10;                return _previewCache[prefab];&#10;            &#10;            // Try to get asset preview first&#10;            Texture2D preview = AssetPreview.GetAssetPreview(prefab);&#10;            &#10;            // If no preview available, try mini thumbnail&#10;            if (preview == null)&#10;                preview = AssetPreview.GetMiniThumbnail(prefab);&#10;            &#10;            // Cache the result (even if null to avoid repeated calls)&#10;            _previewCache[prefab] = preview;&#10;            &#10;            return preview;&#10;        }&#10;&#10;        private void DrawInfoBadges(GameObject prefab)&#10;        {&#10;            bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;            bool isContainer = prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp; &#10;                              prefab.GetComponent&lt;PowerUpContainer&gt;();&#10;            &#10;            if (isEnemy)&#10;            {&#10;                bool hasDrop = prefab.GetComponent&lt;EnemyDropOnDeath&gt;();&#10;                EditorGUILayout.LabelField(hasDrop ? &quot; Drops&quot; : &quot;❌ No Drop&quot;, &#10;                    EditorStyles.miniLabel, GUILayout.Width(60));&#10;            }&#10;            &#10;            if (isContainer)&#10;            {&#10;                bool hasLauncher = prefab.GetComponent&lt;ProximityLauncher&gt;();&#10;                EditorGUILayout.LabelField(hasLauncher ? &quot; Launcher&quot; : &quot; Static&quot;, &#10;                    EditorStyles.miniLabel, GUILayout.Width(70));&#10;            }&#10;            &#10;            // Layer info&#10;            EditorGUILayout.LabelField($&quot;Layer: {LayerMask.LayerToName(prefab.layer)}&quot;, &#10;                EditorStyles.miniLabel, GUILayout.Width(80));&#10;        }&#10;&#10;        private void DrawContextButtons(GameObject prefab)&#10;        {&#10;            bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;            bool isContainer = prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp; &#10;                              prefab.GetComponent&lt;PowerUpContainer&gt;();&#10;            &#10;            if (isEnemy)&#10;            {&#10;                bool hasDrop = prefab.GetComponent&lt;EnemyDropOnDeath&gt;();&#10;                if (GUILayout.Button(hasDrop ? &quot; Update Drop&quot; : &quot;➕ Add Drop&quot;, GUILayout.Width(100)))&#10;                {&#10;                    if (_defaultDropPrefab != null)&#10;                        ApplyEnemyDropSettingsToInstances(prefab, _defaultDropPrefab);&#10;                    else&#10;                        EditorUtility.DisplayDialog(&quot;No Drop Prefab&quot;, &quot;Please set a default drop prefab first!&quot;, &quot;OK&quot;);&#10;                }&#10;            }&#10;            &#10;            if (isContainer)&#10;            {&#10;                bool hasLauncher = prefab.GetComponent&lt;ProximityLauncher&gt;();&#10;                if (GUILayout.Button(hasLauncher ? &quot; Remove Launcher&quot; : &quot;➕ Add Launcher&quot;, GUILayout.Width(120)))&#10;                    ApplyContainerSettingsToInstances(prefab, !hasLauncher);&#10;            }&#10;        }&#10;&#10;        private void DrawBatchOperations()&#10;        {&#10;            if (!_batchMode || _selectedPrefabs.Count == 0) return;&#10;            &#10;            EditorGUILayout.BeginVertical(_cardStyle ?? GUI.skin.box);&#10;            EditorGUILayout.LabelField($&quot; Batch Operations ({_selectedPrefabs.Count} selected)&quot;, EditorStyles.boldLabel);&#10;            &#10;            EditorGUILayout.BeginHorizontal();&#10;            if (GUILayout.Button(&quot;️ Place All&quot;))&#10;                BatchPlaceSelectedWithMouse();&#10;            if (GUILayout.Button(&quot; Instant Place&quot;))&#10;                BatchPlaceSelected();&#10;            if (GUILayout.Button(&quot; Set Drops&quot;))&#10;                BatchSetDropsSelected();&#10;            if (GUILayout.Button(&quot; Toggle Launchers&quot;))&#10;                BatchToggleLaunchers();&#10;            if (GUILayout.Button(&quot;❌ Clear Selection&quot;))&#10;                _selectedPrefabs.Clear();&#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void OnSceneGUI(SceneView sceneView)&#10;        {&#10;            Event e = Event.current;&#10;            &#10;            // Handle right-click for radial menu&#10;            if (e.type == EventType.MouseDown &amp;&amp; e.button == 1 &amp;&amp; !_placementMode)&#10;            {&#10;                _showRadialMenu = true;&#10;                _radialMenuPosition = e.mousePosition;&#10;                sceneView.Repaint();&#10;                e.Use();&#10;                return;&#10;            }&#10;            &#10;            // Handle radial menu&#10;            if (_showRadialMenu)&#10;            {&#10;                HandleRadialMenu(sceneView);&#10;                return;&#10;            }&#10;            &#10;            // Handle placement mode&#10;            if (_placementMode &amp;&amp; _selectedPrefabForPlacement != null)&#10;            {&#10;                if (e.type == EventType.KeyDown &amp;&amp; e.keyCode == KeyCode.Escape)&#10;                {&#10;                    _placementMode = false;&#10;                    _selectedPrefabForPlacement = null;&#10;                    e.Use();&#10;                    return;&#10;                }&#10;&#10;                if (e.type == EventType.MouseDown &amp;&amp; e.button == 0)&#10;                {&#10;                    Ray ray = HandleUtility.GUIPointToWorldRay(e.mousePosition);&#10;                    Vector3 worldPos = ray.origin;&#10;                    worldPos.z = 0; // Assuming 2D game&#10;&#10;                    // Grid snap if Shift is held&#10;                    if (e.shift &amp;&amp; _ppu &gt; 0)&#10;                    {&#10;                        worldPos.x = Mathf.Round(worldPos.x * _ppu) / _ppu;&#10;                        worldPos.y = Mathf.Round(worldPos.y * _ppu) / _ppu;&#10;                    }&#10;&#10;                    PlacePrefabAtPosition(_selectedPrefabForPlacement, worldPos);&#10;                    e.Use();&#10;                }&#10;&#10;                // Draw preview at mouse position&#10;                if (e.type == EventType.Repaint)&#10;                {&#10;                    Ray ray = HandleUtility.GUIPointToWorldRay(e.mousePosition);&#10;                    Vector3 worldPos = ray.origin;&#10;                    worldPos.z = 0;&#10;&#10;                    if (e.shift &amp;&amp; _ppu &gt; 0)&#10;                    {&#10;                        worldPos.x = Mathf.Round(worldPos.x * _ppu) / _ppu;&#10;                        worldPos.y = Mathf.Round(worldPos.y * _ppu) / _ppu;&#10;                    }&#10;&#10;                    Handles.color = Color.yellow;&#10;                    Handles.DrawWireCube(worldPos, Vector3.one * 0.5f);&#10;                    Handles.Label(worldPos + Vector3.up * 0.5f, _selectedPrefabForPlacement.name);&#10;                }&#10;&#10;                HandleUtility.AddDefaultControl(GUIUtility.GetControlID(FocusType.Passive));&#10;            }&#10;        }&#10;&#10;        private void HandleRadialMenu(SceneView sceneView)&#10;        {&#10;            Event e = Event.current;&#10;            &#10;            // Draw radial menu&#10;            Handles.BeginGUI();&#10;            &#10;            Vector2 center = _radialMenuPosition;&#10;            float radius = 80f;&#10;            &#10;            // Background circle&#10;            Handles.color = new Color(0, 0, 0, 0.5f);&#10;            Handles.DrawSolidDisc(center, Vector3.forward, radius);&#10;            &#10;            Handles.color = Color.white;&#10;            Handles.DrawWireDisc(center, Vector3.forward, radius);&#10;            &#10;            // Draw prefab options in circle&#10;            int prefabCount = Mathf.Min(_frequentPrefabs.Count, MAX_FREQUENT_PREFABS);&#10;            for (int i = 0; i &lt; prefabCount; i++)&#10;            {&#10;                if (_frequentPrefabs[i] == null) continue;&#10;                &#10;                float angle = (i / (float)prefabCount) * 360f - 90f; // Start from top&#10;                Vector2 direction = new Vector2(Mathf.Cos(angle * Mathf.Deg2Rad), Mathf.Sin(angle * Mathf.Deg2Rad));&#10;                Vector2 buttonPos = center + direction * (radius * 0.7f);&#10;                &#10;                // Highlight if mouse is over&#10;                Vector2 mousePos = e.mousePosition;&#10;                bool isHovered = Vector2.Distance(mousePos, buttonPos) &lt; 30f;&#10;                &#10;                if (isHovered)&#10;                {&#10;                    Handles.color = Color.yellow;&#10;                    Handles.DrawSolidDisc(buttonPos, Vector3.forward, 30f);&#10;                    Handles.color = Color.white;&#10;                }&#10;                &#10;                // Draw preview image or fallback icon&#10;                Texture2D preview = GetPrefabPreview(_frequentPrefabs[i]);&#10;                if (preview != null)&#10;                {&#10;                    // Draw the preview image&#10;                    Rect imageRect = new Rect(buttonPos.x - 20, buttonPos.y - 20, 40, 40);&#10;                    GUI.DrawTexture(imageRect, preview, ScaleMode.ScaleToFit);&#10;                }&#10;                else&#10;                {&#10;                    // Draw fallback colored circle with emoji&#10;                    Handles.color = new Color(0.4f, 0.4f, 0.4f, 0.8f);&#10;                    Handles.DrawSolidDisc(buttonPos, Vector3.forward, 20f);&#10;                    &#10;                    string icon = GetPrefabIcon(_frequentPrefabs[i]);&#10;                    GUIStyle iconStyle = new GUIStyle(GUI.skin.label)&#10;                    {&#10;                        fontSize = 16,&#10;                        alignment = TextAnchor.MiddleCenter,&#10;                        normal = { textColor = Color.white }&#10;                    };&#10;                    &#10;                    GUI.Label(new Rect(buttonPos.x - 15, buttonPos.y - 10, 30, 20), icon, iconStyle);&#10;                    Handles.color = Color.white;&#10;                }&#10;                &#10;                // Draw name below&#10;                string displayName = _frequentPrefabs[i].name;&#10;                if (displayName.Length &gt; 8) displayName = displayName.Substring(0, 8) + &quot;...&quot;;&#10;                &#10;                GUI.Label(new Rect(buttonPos.x - 30, buttonPos.y + 25, 60, 20), displayName, EditorStyles.centeredGreyMiniLabel);&#10;                &#10;                // Handle click&#10;                if (isHovered &amp;&amp; e.type == EventType.MouseDown &amp;&amp; e.button == 0)&#10;                {&#10;                    StartPlacementMode(_frequentPrefabs[i]);&#10;                    _showRadialMenu = false;&#10;                    e.Use();&#10;                }&#10;            }&#10;            &#10;            // Close menu if clicked outside or right-clicked&#10;            if ((e.type == EventType.MouseDown &amp;&amp; Vector2.Distance(e.mousePosition, center) &gt; radius) ||&#10;                (e.type == EventType.MouseDown &amp;&amp; e.button == 1))&#10;            {&#10;                _showRadialMenu = false;&#10;                e.Use();&#10;            }&#10;            &#10;            // Instructions&#10;            GUI.Label(new Rect(center.x - 100, center.y + radius + 10, 200, 20), &#10;                &quot;Click prefab to place • Right-click to cancel&quot;, EditorStyles.centeredGreyMiniLabel);&#10;            &#10;            Handles.EndGUI();&#10;            &#10;            sceneView.Repaint();&#10;        }&#10;&#10;        private void StartPlacementMode(GameObject prefab)&#10;        {&#10;            _placementMode = true;&#10;            _selectedPrefabForPlacement = prefab;&#10;            &#10;            // Track usage&#10;            IncrementPrefabUsage(prefab);&#10;            &#10;            EditorUtility.DisplayDialog(&quot;Placement Mode&quot;, &#10;                $&quot;Click in Scene View to place {prefab.name}.\nHold Shift for grid snap.\nRight-click for quick menu.\nPress Escape to stop.&quot;, &quot;OK&quot;);&#10;        }&#10;&#10;        private void HandlePlacementMode()&#10;        {&#10;            if (_placementMode &amp;&amp; _selectedPrefabForPlacement == null)&#10;            {&#10;                _placementMode = false;&#10;            }&#10;        }&#10;&#10;        // Usage Tracking System&#10;        private void IncrementPrefabUsage(GameObject prefab)&#10;        {&#10;            if (_prefabUsageCount.ContainsKey(prefab))&#10;                _prefabUsageCount[prefab]++;&#10;            else&#10;                _prefabUsageCount[prefab] = 1;&#10;            &#10;            UpdateFrequentPrefabs();&#10;            SaveUsageData();&#10;        }&#10;&#10;        private void UpdateFrequentPrefabs()&#10;        {&#10;            _frequentPrefabs.Clear();&#10;            &#10;            var sortedPrefabs = _prefabUsageCount&#10;                .Where(kvp =&gt; kvp.Key != null)&#10;                .OrderByDescending(kvp =&gt; kvp.Value)&#10;                .Take(MAX_FREQUENT_PREFABS)&#10;                .Select(kvp =&gt; kvp.Key);&#10;            &#10;            _frequentPrefabs.AddRange(sortedPrefabs);&#10;        }&#10;&#10;        private void SaveUsageData()&#10;        {&#10;            string data = &quot;&quot;;&#10;            foreach (var kvp in _prefabUsageCount)&#10;            {&#10;                if (kvp.Key != null)&#10;                {&#10;                    string guid = AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(kvp.Key));&#10;                    data += $&quot;{guid}:{kvp.Value};&quot;;&#10;                }&#10;            }&#10;            EditorPrefs.SetString(&quot;PrefabAuditor_UsageData&quot;, data);&#10;        }&#10;&#10;        private void LoadUsageData()&#10;        {&#10;            _prefabUsageCount.Clear();&#10;            string data = EditorPrefs.GetString(&quot;PrefabAuditor_UsageData&quot;, &quot;&quot;);&#10;            &#10;            if (string.IsNullOrEmpty(data)) return;&#10;            &#10;            string[] entries = data.Split(';');&#10;            foreach (string entry in entries)&#10;            {&#10;                if (string.IsNullOrEmpty(entry)) continue;&#10;                &#10;                string[] parts = entry.Split(':');&#10;                if (parts.Length == 2)&#10;                {&#10;                    string guid = parts[0];&#10;                    if (int.TryParse(parts[1], out int count))&#10;                    {&#10;                        string path = AssetDatabase.GUIDToAssetPath(guid);&#10;                        GameObject prefab = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);&#10;                        if (prefab != null)&#10;                        {&#10;                            _prefabUsageCount[prefab] = count;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Batch Operations&#10;        private void BatchPlaceSelectedWithMouse()&#10;        {&#10;            if (_selectedPrefabs.Count == 0) return;&#10;&#10;            // Start placement mode with first selected prefab&#10;            if (_selectedPrefabs.Count &gt; 0 &amp;&amp; _selectedPrefabs[0] &lt; _filteredPrefabs.Count)&#10;            {&#10;                StartPlacementMode(_filteredPrefabs[_selectedPrefabs[0]]);&#10;            }&#10;        }&#10;&#10;        private void BatchPlaceSelected()&#10;        {&#10;            Vector3 basePos = Vector3.zero;&#10;            foreach (int index in _selectedPrefabs)&#10;            {&#10;                if (index &lt; _filteredPrefabs.Count)&#10;                {&#10;                    PlacePrefabAtPosition(_filteredPrefabs[index], basePos);&#10;                    basePos.x += 2f; // Offset each placement&#10;                }&#10;            }&#10;        }&#10;&#10;        private void BatchSetDropsSelected()&#10;        {&#10;            if (_defaultDropPrefab == null)&#10;            {&#10;                EditorUtility.DisplayDialog(&quot;No Drop Prefab&quot;, &quot;Please set a default drop prefab first!&quot;, &quot;OK&quot;);&#10;                return;&#10;            }&#10;&#10;            foreach (int index in _selectedPrefabs)&#10;            {&#10;                if (index &lt; _filteredPrefabs.Count)&#10;                {&#10;                    GameObject prefab = _filteredPrefabs[index];&#10;                    bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;                    if (isEnemy)&#10;                        ApplyEnemyDropSettingsToInstances(prefab, _defaultDropPrefab);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void BatchToggleLaunchers()&#10;        {&#10;            foreach (int index in _selectedPrefabs)&#10;            {&#10;                if (index &lt; _filteredPrefabs.Count)&#10;                {&#10;                    GameObject prefab = _filteredPrefabs[index];&#10;                    bool isContainer = prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp;&#10;                                      prefab.GetComponent&lt;PowerUpContainer&gt;();&#10;                    if (isContainer)&#10;                    {&#10;                        bool hasLauncher = prefab.GetComponent&lt;ProximityLauncher&gt;();&#10;                        ApplyContainerSettingsToInstances(prefab, !hasLauncher);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void BatchSetDropsInstances()&#10;        {&#10;            if (_defaultDropPrefab == null)&#10;            {&#10;                EditorUtility.DisplayDialog(&quot;No Drop Prefab&quot;, &quot;Please set a default drop prefab first!&quot;, &quot;OK&quot;);&#10;                return;&#10;            }&#10;&#10;            int updatedCount = 0;&#10;            foreach (GameObject prefab in _filteredPrefabs)&#10;            {&#10;                bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;                if (isEnemy)&#10;                {&#10;                    ApplyEnemyDropSettingsToInstances(prefab, _defaultDropPrefab);&#10;                    updatedCount++;&#10;                }&#10;            }&#10;            EditorUtility.DisplayDialog(&quot;Batch Set Drops&quot;, $&quot;Updated drop settings for {updatedCount} enemy instances in scene.&quot;, &quot;OK&quot;);&#10;        }&#10;&#10;        // Placement Methods (Instance-only modifications)&#10;        private void PlacePrefabInstant(GameObject prefab)&#10;        {&#10;            PlacePrefabAtPosition(prefab, Vector3.zero);&#10;        }&#10;&#10;        private void PlacePrefabAtPosition(GameObject prefab, Vector3 position)&#10;        {&#10;            try&#10;            {&#10;                GameObject go = (GameObject)PrefabUtility.InstantiatePrefab(prefab);&#10;                go.transform.position = position;&#10;                Selection.activeGameObject = go;&#10;&#10;                // Track usage&#10;                IncrementPrefabUsage(prefab);&#10;&#10;                // Apply instance modifications if this is an enemy with no drop settings&#10;                bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;                if (isEnemy &amp;&amp; _defaultDropPrefab != null &amp;&amp; !prefab.GetComponent&lt;EnemyDropOnDeath&gt;())&#10;                {&#10;                    EnemyDropOnDeath enemyDrop = go.AddComponent&lt;EnemyDropOnDeath&gt;();&#10;                    enemyDrop.dropPrefab = _defaultDropPrefab;&#10;                }&#10;            }&#10;            catch (System.Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to place prefab {prefab.name}: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        // Instance-only modification methods&#10;        private void ApplyEnemyDropSettingsToInstances(GameObject prefab, GameObject dropPrefab)&#10;        {&#10;            // Find all instances of this prefab in the scene and update them&#10;            GameObject[] allObjects = Object.FindObjectsByType&lt;GameObject&gt;(FindObjectsSortMode.None);&#10;            int updatedCount = 0;&#10;&#10;            foreach (GameObject obj in allObjects)&#10;            {&#10;                if (PrefabUtility.GetCorrespondingObjectFromSource(obj) == prefab)&#10;                {&#10;                    try&#10;                    {&#10;                        EnemyDropOnDeath enemyDrop = obj.GetComponent&lt;EnemyDropOnDeath&gt;() ??&#10;                                                    obj.AddComponent&lt;EnemyDropOnDeath&gt;();&#10;                        enemyDrop.dropPrefab = dropPrefab;&#10;                        EditorUtility.SetDirty(obj);&#10;                        updatedCount++;&#10;                    }&#10;                    catch (System.Exception e)&#10;                    {&#10;                        Debug.LogError($&quot;Failed to apply enemy drop settings to instance {obj.name}: {e.Message}&quot;);&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (updatedCount &gt; 0)&#10;                EditorUtility.DisplayDialog(&quot;Updated Instances&quot;, $&quot;Updated {updatedCount} instances of {prefab.name} in the scene.&quot;, &quot;OK&quot;);&#10;            else&#10;                EditorUtility.DisplayDialog(&quot;No Instances&quot;, $&quot;No instances of {prefab.name} found in the current scene.&quot;, &quot;OK&quot;);&#10;        }&#10;&#10;        private void ApplyContainerSettingsToInstances(GameObject prefab, bool hasProximityLauncher)&#10;        {&#10;            // Find all instances of this prefab in the scene and update them&#10;            GameObject[] allObjects = Object.FindObjectsByType&lt;GameObject&gt;(FindObjectsSortMode.None);&#10;            int updatedCount = 0;&#10;&#10;            foreach (GameObject obj in allObjects)&#10;            {&#10;                if (PrefabUtility.GetCorrespondingObjectFromSource(obj) == prefab)&#10;                {&#10;                    try&#10;                    {&#10;                        ProximityLauncher launcher = obj.GetComponent&lt;ProximityLauncher&gt;();&#10;                        if (hasProximityLauncher &amp;&amp; launcher == null)&#10;                            obj.AddComponent&lt;ProximityLauncher&gt;();&#10;                        else if (!hasProximityLauncher &amp;&amp; launcher)&#10;                            DestroyImmediate(launcher);&#10;&#10;                        EditorUtility.SetDirty(obj);&#10;                        updatedCount++;&#10;                    }&#10;                    catch (System.Exception e)&#10;                    {&#10;                        Debug.LogError($&quot;Failed to apply container settings to instance {obj.name}: {e.Message}&quot;);&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (updatedCount &gt; 0)&#10;                EditorUtility.DisplayDialog(&quot;Updated Instances&quot;, $&quot;Updated {updatedCount} instances of {prefab.name} in the scene.&quot;, &quot;OK&quot;);&#10;            else&#10;                EditorUtility.DisplayDialog(&quot;No Instances&quot;, $&quot;No instances of {prefab.name} found in the current scene.&quot;, &quot;OK&quot;);&#10;        }&#10;&#10;        private void ApplyFilters()&#10;        {&#10;            _filteredPrefabs.Clear();&#10;&#10;            foreach (GameObject prefab in _prefabs)&#10;            {&#10;                if (!MatchesSearch(prefab)) continue;&#10;                if (!MatchesFilter(prefab)) continue;&#10;&#10;                _filteredPrefabs.Add(prefab);&#10;            }&#10;        }&#10;&#10;        private bool MatchesSearch(GameObject prefab)&#10;        {&#10;            if (string.IsNullOrEmpty(_searchFilter)) return true;&#10;            return prefab.name.ToLower().Contains(_searchFilter.ToLower());&#10;        }&#10;&#10;        private bool MatchesFilter(GameObject prefab)&#10;        {&#10;            switch (_filterType)&#10;            {&#10;                case FilterType.Enemies:&#10;                    return (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;                case FilterType.Containers:&#10;                    return prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp;&#10;                           prefab.GetComponent&lt;PowerUpContainer&gt;();&#10;                case FilterType.Others:&#10;                    bool isEnemy = (1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0;&#10;                    bool isContainer = prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp;&#10;                                      prefab.GetComponent&lt;PowerUpContainer&gt;();&#10;                    return !isEnemy &amp;&amp; !isContainer;&#10;                default:&#10;                    return true;&#10;            }&#10;        }&#10;&#10;        // Utility Methods&#10;        private void LoadPrefabs()&#10;        {&#10;            _prefabs.Clear();&#10;            _previewCache.Clear(); // Clear preview cache when reloading&#10;&#10;            string[] guids = AssetDatabase.FindAssets(&quot;t:Prefab&quot;, new[] { &quot;Assets/Prefabs&quot; });&#10;            foreach (string guid in guids)&#10;            {&#10;                string path = AssetDatabase.GUIDToAssetPath(guid);&#10;                GameObject prefab = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);&#10;                if (prefab)&#10;                    _prefabs.Add(prefab);&#10;            }&#10;            ApplyFilters();&#10;        }&#10;&#10;        [MenuItem(&quot;Tools/Level Auditor &amp; Prefab Manager&quot;)]&#10;        public static void ShowWindow()&#10;        {&#10;            var window = GetWindow&lt;PrefabAuditorWindow&gt;(&quot;Level Auditor&quot;);&#10;            window.minSize = new Vector2(500, 600);&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scenes/LevelsTemplatePipeline.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scenes/LevelsTemplatePipeline.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using UnityEditor.SceneTemplate;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;&#10;public class LevelsTemplatePipeline : ISceneTemplatePipeline&#10;{&#10;    public virtual bool IsValidTemplateForInstantiation(SceneTemplateAsset sceneTemplateAsset)&#10;    {&#10;        return true;&#10;    }&#10;&#10;    public virtual void BeforeTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, bool isAdditive, string sceneName)&#10;    {&#10;        &#10;    }&#10;&#10;    public virtual void AfterTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, Scene scene, bool isAdditive, string sceneName)&#10;    {&#10;        var sceneFolder = System.IO.Path.Combine(&quot;Assets&quot;, &quot;Scenes&quot;);&#10;        var sceneFiles = System.IO.Directory.GetFiles(sceneFolder, &quot;Level*.unity&quot;);&#10;        int levelPrefixLength = &quot;Level&quot;.Length;&#10;        int maxLevel = sceneFiles&#10;            .Select(System.IO.Path.GetFileNameWithoutExtension)&#10;            .Where(fileName =&gt; fileName.StartsWith(&quot;Level&quot;))&#10;            .Select(fileName =&gt; int.TryParse(fileName[levelPrefixLength..], out int num) ? num : 0)&#10;            .DefaultIfEmpty(0)&#10;            .Max();&#10;        string newLevelName = $&quot;Level{maxLevel + 1}&quot;;&#10;        scene.name = newLevelName;&#10;        SceneManager.SetActiveScene(scene);&#10;        Debug.Log($&quot;[LevelsTemplatePipeline] Instantiated new level: {newLevelName}&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Linq;&#10;using UnityEditor.SceneTemplate;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;&#10;public class LevelsTemplatePipeline : ISceneTemplatePipeline&#10;{&#10;    public virtual bool IsValidTemplateForInstantiation(SceneTemplateAsset sceneTemplateAsset)&#10;    {&#10;        return true;&#10;    }&#10;&#10;    public virtual void BeforeTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, bool isAdditive, string sceneName)&#10;    {&#10;        &#10;    }&#10;&#10;    public virtual void AfterTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, Scene scene, bool isAdditive, string sceneName)&#10;    {&#10;        var sceneFolder = System.IO.Path.Combine(&quot;Assets&quot;, &quot;Scenes&quot;);&#10;        var sceneFiles = System.IO.Directory.GetFiles(sceneFolder, &quot;Level*.unity&quot;);&#10;        int levelPrefixLength = &quot;Level&quot;.Length;&#10;        int maxLevel = sceneFiles&#10;            .Select(System.IO.Path.GetFileNameWithoutExtension)&#10;            .Where(fileName =&gt; fileName.StartsWith(&quot;Level&quot;))&#10;            .Select(fileName =&gt; int.TryParse(fileName[levelPrefixLength..], out int num) ? num : 0)&#10;            .DefaultIfEmpty(0)&#10;            .Max();&#10;        string newLevelName = $&quot;Level{maxLevel + 1}&quot;;&#10;        scene.name = newLevelName;&#10;        SceneManager.SetActiveScene(scene);&#10;        Debug.Log($&quot;[LevelsTemplatePipeline] Instantiated new level: {newLevelName}&quot;);&#10;&#10;        // Show save file dialog with the new scene name as default&#10;#if UNITY_EDITOR&#10;        string savePath = UnityEditor.EditorUtility.SaveFilePanel(&#10;            &quot;Save New Scene&quot;,&#10;            sceneFolder,&#10;            newLevelName,&#10;            &quot;unity&quot;&#10;        );&#10;        if (!string.IsNullOrEmpty(savePath))&#10;        {&#10;            UnityEditor.SceneManagement.EditorSceneManager.SaveScene(scene, savePath);&#10;            Debug.Log($&quot;[LevelsTemplatePipeline] Scene saved to: {savePath}&quot;);&#10;        }&#10;#endif&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/ScoreCollectionTracker.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/ScoreCollectionTracker.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/GameEvents.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/GameEvents.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Core.Events&#10;{&#10;    public enum GameState&#10;    {&#10;        MainMenu,&#10;        Loading,&#10;        Playing,&#10;        Paused,&#10;        GameOver,&#10;        Victory,&#10;        Restarting&#10;    }&#10;&#10;    public struct GameStateChangedEvent&#10;    {&#10;        public GameState PreviousState;&#10;        public GameState NewState;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerHealthChangedEvent&#10;    {&#10;        public int CurrentHp;&#10;        public int MaxHp;&#10;        public int Damage;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerLivesChangedEvent&#10;    {&#10;        public int MaxLives;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct ScoreChangedEvent&#10;    {&#10;        public Vector3 Position;&#10;        public int ScoreAmount; // Delta amount&#10;        public int TotalScore; // Overall score&#10;    }&#10;&#10;    // Base event structure for consistency&#10;    public interface IGameEvent&#10;    {&#10;        float Timestamp { get; }&#10;    }&#10;&#10;    public struct PlayerDeathEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public Vector3 DeathPosition;&#10;    }&#10;&#10;    public struct LevelStartedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;    }&#10;&#10;    public struct LevelCompletedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;        public float CompletionTime;&#10;    }&#10;&#10;&#10;    public struct GameOverEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Core.Events&#10;{&#10;    public enum GameState&#10;    {&#10;        MainMenu,&#10;        Loading,&#10;        Playing,&#10;        Paused,&#10;        GameOver,&#10;        Victory,&#10;        Restarting&#10;    }&#10;&#10;    public struct GameStateChangedEvent&#10;    {&#10;        public GameState PreviousState;&#10;        public GameState NewState;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerHealthChangedEvent&#10;    {&#10;        public int CurrentHp;&#10;        public int MaxHp;&#10;        public int Damage;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerLivesChangedEvent&#10;    {&#10;        public int PreviousLives;&#10;        public int CurrentLives;&#10;        public int MaxLives;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct ScoreChangedEvent&#10;    {&#10;        public Vector3 Position;&#10;        public int ScoreAmount; // Delta amount&#10;        public int TotalScore; // Overall score&#10;    }&#10;&#10;    // Base event structure for consistency&#10;    public interface IGameEvent&#10;    {&#10;        float Timestamp { get; }&#10;    }&#10;&#10;    public struct PlayerDeathEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public Vector3 DeathPosition;&#10;    }&#10;&#10;    public struct LevelStartedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;    }&#10;&#10;    public struct LevelCompletedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;        public float CompletionTime;&#10;    }&#10;&#10;&#10;    public struct GameOverEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/FrogProximityJump.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/FrogProximityJump.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using Player.Components;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Emits an event when the player is within a certain distance&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class FrogProximityTrigger : MonoBehaviour, ITrigger&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float triggerDistance = 3f;&#10;        [SerializeField] private float jumpCooldown = 2f;&#10;        [SerializeField] private int checkEveryNFrames = 1;&#10;&#10;        private int _frameCounter;&#10;        private bool _grounded;&#10;        private float _lastTriggerTime;&#10;        private Transform _player;&#10;&#10;        private void Start()&#10;        {&#10;            _player = PlayerLocator.PlayerTransform;&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public bool IsTriggered { get; private set; }&#10;&#10;        public void CheckTrigger()&#10;        {&#10;            if (++_frameCounter % checkEveryNFrames != 0 || !_player) return;&#10;&#10;            Vector2 toPlayer = _player.position - transform.position;&#10;            float sqrDist = toPlayer.sqrMagnitude;&#10;            float sqrTrigger = triggerDistance * triggerDistance;&#10;&#10;            if (sqrDist &lt; sqrTrigger &amp;&amp; Time.time - _lastTriggerTime &gt; jumpCooldown &amp;&amp; _grounded)&#10;            {&#10;                IsTriggered = true;&#10;                _lastTriggerTime = Time.time;&#10;            }&#10;            else&#10;            {&#10;                IsTriggered = false;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using Player.Components;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Emits an event when the player is within a certain distance&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class FrogProximityTrigger : MonoBehaviour, ITrigger&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float triggerDistance = 3f;&#10;        [SerializeField] private float jumpCooldown = 2f;&#10;        [SerializeField] private int checkEveryNFrames = 1;&#10;&#10;        private int _frameCounter;&#10;        private bool _grounded;&#10;        private float _lastTriggerTime;&#10;        private Transform _player;&#10;&#10;        private void Start()&#10;        {&#10;            _player = PlayerLocator.PlayerTransform;&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public bool IsTriggered { get; private set; }&#10;&#10;        public void CheckTrigger()&#10;        {&#10;            if (++_frameCounter % checkEveryNFrames != 0 || !_player) return;&#10;&#10;            Vector2 toPlayer = _player.position - transform.position;&#10;            float sqrDist = toPlayer.sqrMagnitude;&#10;            float sqrTrigger = triggerDistance * triggerDistance;&#10;&#10;            if (sqrDist &lt; sqrTrigger &amp;&amp; Time.time - _lastTriggerTime &gt; jumpCooldown &amp;&amp; _grounded)&#10;            {&#10;                IsTriggered = true;&#10;                _lastTriggerTime = Time.time;&#10;            }&#10;            else&#10;            {&#10;                IsTriggered = false;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/JumpMover.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/JumpMover.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to make the enemy jump forward&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class JumpCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float jumpForceX = 2f;&#10;        [SerializeField] private float jumpForceY = 5f;&#10;&#10;        private bool _grounded;&#10;        private Rigidbody2D _rb;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (_grounded)&#10;            {&#10;                Vector2 jumpDir = new(transform.localScale.x * jumpForceX, jumpForceY);&#10;                _rb.linearVelocity = jumpDir;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to make the enemy jump forward&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class JumpCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float jumpForceX = 2f;&#10;        [SerializeField] private float jumpForceY = 5f;&#10;&#10;        private bool _grounded;&#10;        private Rigidbody2D _rb;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (_grounded)&#10;            {&#10;                Vector2 jumpDir = new(transform.localScale.x * jumpForceX, jumpForceY);&#10;                _rb.linearVelocity = jumpDir;&#10;            }&#10;        }&#10;&#10;        public void ResetState()&#10;        {&#10;            _grounded = false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/ProjectileShooter.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/ProjectileShooter.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using Weapons.Models;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to shoot a projectile at intervals&#10;    public class ProjectileShootCommand : MonoBehaviour, IAttackCommand&#10;    {&#10;        [SerializeField] private FireballWeapon fireballWeapon;&#10;        [SerializeField] private float fireInterval = 2f;&#10;&#10;        private float _lastFireTime;&#10;&#10;        private void Start()&#10;        {&#10;            fireballWeapon.Equip();&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (!fireballWeapon)&#10;                return;&#10;&#10;            if (Time.time - _lastFireTime &lt; fireInterval)&#10;                return;&#10;&#10;            fireballWeapon.Shoot();&#10;            _lastFireTime = Time.time;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using Weapons.Models;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to shoot a projectile at intervals&#10;    public class ProjectileShootCommand : MonoBehaviour, IAttackCommand&#10;    {&#10;        [SerializeField] private FireballWeapon fireballWeapon;&#10;        [SerializeField] private float fireInterval = 2f;&#10;&#10;        private float _lastFireTime;&#10;&#10;        private void Start()&#10;        {&#10;            fireballWeapon.Equip();&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (!fireballWeapon)&#10;                return;&#10;&#10;            if (Time.time - _lastFireTime &lt; fireInterval)&#10;                return;&#10;&#10;            fireballWeapon.Shoot();&#10;            _lastFireTime = Time.time;&#10;        }&#10;&#10;        public void ResetCooldown()&#10;        {&#10;            _lastFireTime = 0f;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/VerticalMover.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/VerticalMover.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy up and down&#10;    public class VerticalMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float amplitude = 2f;&#10;        [SerializeField] private float frequency = 0.8f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocityY = (y - _rb.position.y) / Time.fixedDeltaTime;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy up and down&#10;    public class VerticalMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float amplitude = 2f;&#10;        [SerializeField] private float frequency = 0.8f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocityY = (y - _rb.position.y) / Time.fixedDeltaTime;&#10;        }&#10;&#10;        public void ResetPosition()&#10;        {&#10;            _rb.position = new Vector2(_rb.position.x, _startY);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/WaveMover.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/WaveMover.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy in a wave pattern&#10;    public class WaveMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float speed = 2f;&#10;        [SerializeField] private float amplitude = 1f;&#10;        [SerializeField] private float frequency = 1.11f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocity = new Vector2(-speed, (y - _rb.position.y) / Time.fixedDeltaTime);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy in a wave pattern&#10;    public class WaveMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float speed = 2f;&#10;        [SerializeField] private float amplitude = 1f;&#10;        [SerializeField] private float frequency = 1.11f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocity = new Vector2(-speed, (y - _rb.position.y) / Time.fixedDeltaTime);&#10;        }&#10;&#10;        public void ResetPosition()&#10;        {&#10;            _rb.position = new Vector2(_rb.position.x, _startY);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/BehaviorOrchestrator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/BehaviorOrchestrator.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyBehaviorController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyBehaviorController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Wires up modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyBehaviorController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (ITriggerBehavior trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;            foreach (IMovementBehavior move in _movementBehaviors) move.Move();&#10;            foreach (IAttackBehavior attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Coordinates modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyBehaviorController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (ITriggerBehavior trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;        }&#10;&#10;        private void FixedUpdate()&#10;        {&#10;            foreach (IMovementBehavior move in _movementBehaviors) move.Move();&#10;        }&#10;&#10;        private void LateUpdate()&#10;        {&#10;            foreach (IAttackBehavior attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyController.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Wires up modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (var trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;            foreach (var move in _movementBehaviors) move.Move();&#10;            foreach (var attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/TriggerManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/TriggerManager.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using System.Linq;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Manages periodic checks for all triggers in the scene&#10;    public class TriggerManager : MonoBehaviour&#10;    {&#10;        private TriggerGroup[] _triggerGroups;&#10;&#10;        private void Awake()&#10;        {&#10;            _triggerGroups = FindObjectsOfType&lt;MonoBehaviour&gt;().OfType&lt;TriggerGroup&gt;().ToArray();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (var group in _triggerGroups)&#10;            {&#10;                group.Update();&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using System.Linq;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Manages periodic checks for all triggers in the scene&#10;    public class TriggerManager : MonoBehaviour&#10;    {&#10;        private TriggerGroup[] _triggerGroups;&#10;&#10;        private void Awake()&#10;        {&#10;            _triggerGroups = FindObjectsOfType&lt;MonoBehaviour&gt;().OfType&lt;TriggerGroup&gt;().ToArray();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IAttackBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IAttackBehavior.cs" />
              <option name="originalContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IAttackBehavior&#10;    {&#10;        void Attack();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IAttackBehavior&#10;    {&#10;        void Attack();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IMovementBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IMovementBehavior.cs" />
              <option name="originalContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IMovementBehavior&#10;    {&#10;        void Move();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IMovementBehavior&#10;    {&#10;        void Move();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/ITriggerBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/ITriggerBehavior.cs" />
              <option name="originalContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface ITrigger&#10;    {&#10;        bool IsTriggered { get; }&#10;    }&#10;&#10;    public interface ITriggerBehavior&#10;    {&#10;        void CheckTrigger();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface ITrigger&#10;    {&#10;        bool IsTriggered { get; }&#10;        void CheckTrigger();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/Behaviors/EnemyBehaviors.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/Behaviors/EnemyBehaviors.cs" />
              <option name="updatedContent" value="namespace Enemy.Behaviors&#10;{&#10;    // Optional movement behavior&#10;    public interface IMovable&#10;    {&#10;        void Move();&#10;    }&#10;&#10;    // Optional player proximity reaction&#10;    public interface IPlayerProximityReactable&#10;    {&#10;        void OnPlayerNearby();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/BirdEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/BirdEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Bird: Moves left, goes up and down&#10;    public class BirdEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private float moveSpeed = 2f;&#10;        [SerializeField] private float verticalAmplitude = 1f;&#10;        [SerializeField] private float verticalFrequency = 1f;&#10;        private Vector3 _startPos;&#10;        private float _time;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _startPos = transform.position;&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            _time += Time.deltaTime;&#10;            float yOffset = Mathf.Sin(_time * verticalFrequency) * verticalAmplitude;&#10;            transform.position = _startPos + new Vector3(-moveSpeed * _time, yOffset, 0);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBase.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public abstract class EnemyBase : MonoBehaviour&#10;    {&#10;        protected Rigidbody2D rb;&#10;        protected Collider2D col;&#10;        protected virtual void Awake()&#10;        {&#10;            rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            col = GetComponent&lt;Collider2D&gt;();&#10;        }&#10;&#10;        public virtual void Move() { }&#10;        public virtual void Attack() { }&#10;        public virtual void OnPlayerNearby() { }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBuilder.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBuilder.cs" />
              <option name="originalContent" value="using Enemy.Behaviors;&#10;using Weapons.Models;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyBuilder&#10;    {&#10;        private readonly EnemyBase _enemy;&#10;&#10;        public EnemyBuilder(EnemyBase enemy)&#10;        {&#10;            _enemy = enemy;&#10;        }&#10;&#10;        public EnemyBuilder WithFireSnakeBehavior()&#10;        {&#10;            // Example: assign FireballWeapon if available&#10;            var fireSnake = _enemy as FireSnakeEnemy;&#10;            if (fireSnake)&#10;            {&#10;                FireballWeapon weapon = fireSnake.GetComponentInChildren&lt;FireballWeapon&gt;();&#10;                if (weapon)&#10;                {&#10;                    weapon.Equip();&#10;                    // Additional setup if needed&#10;                }&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSpiderBehavior()&#10;        {&#10;            // Assign movement or proximity logic as needed&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithBirdBehavior()&#10;        {&#10;            // Assign movement logic as needed&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSnakeBehavior()&#10;        {&#10;            // Assign jump logic as needed&#10;            var snake = _enemy as SnakeEnemy;&#10;            if (snake)&#10;            {&#10;                // Example: assign a jump movement component or set jump parameters&#10;                // (Assume SnakeEnemy implements IMovable and has a Jump method)&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithFrogBehavior()&#10;        {&#10;            // Assign jump and proximity logic as needed&#10;            var frog = _enemy as FrogEnemy;&#10;            if (frog)&#10;            {&#10;                // Example: assign a jump movement component or set jump parameters&#10;                // (Assume FrogEnemy implements IMovable and IPlayerProximityReactable)&#10;            }&#10;            return this;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemy.Behaviors;&#10;using Weapons.Models;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyBuilder&#10;    {&#10;        private readonly EnemyBase _enemy;&#10;&#10;        public EnemyBuilder(EnemyBase enemy)&#10;        {&#10;            _enemy = enemy;&#10;        }&#10;&#10;        public EnemyBuilder WithFireSnakeBehavior()&#10;        {&#10;            // Example: assign FireballWeapon if available&#10;            var fireSnake = _enemy as FireSnakeEnemy;&#10;            if (fireSnake)&#10;            {&#10;                FireballWeapon weapon = fireSnake.GetComponentInChildren&lt;FireballWeapon&gt;();&#10;                if (weapon)&#10;                {&#10;                    weapon.Equip();&#10;                    // Additional setup if needed&#10;                }&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSpiderBehavior()&#10;        {&#10;            // Spider: Can move up/down or stay static in air&#10;            var spider = _enemy as SpiderEnemy;&#10;            if (spider)&#10;            {&#10;                // No extra setup needed; movement handled in SpiderEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithBirdBehavior()&#10;        {&#10;            // Bird: Moves left, goes up and down&#10;            var bird = _enemy as BirdEnemy;&#10;            if (bird)&#10;            {&#10;                // No extra setup needed; movement handled in BirdEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSnakeBehavior()&#10;        {&#10;            // Snake: Jumps forward&#10;            var snake = _enemy as SnakeEnemy;&#10;            if (snake)&#10;            {&#10;                // No extra setup needed; jump logic handled in SnakeEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithFrogBehavior()&#10;        {&#10;            // Frog: Jumps higher/farther, jumps when player is near&#10;            var frog = _enemy as FrogEnemy;&#10;            if (frog)&#10;            {&#10;                // No extra setup needed; jump and proximity handled in FrogEnemy&#10;            }&#10;            return this;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDirector.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDirector.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public static class EnemyDirector&#10;    {&#10;        // Entry point for configuring an enemy in the scene&#10;        public static void ConstructEnemy(EnemyType type, EnemyBase enemy)&#10;        {&#10;            // The director delegates the construction to the factory&#10;            EnemyFactory.ConfigureEnemy(type, enemy);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyFactory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyFactory.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public enum EnemyType&#10;    {&#10;        FireSnake,&#10;        Spider,&#10;        Bird,&#10;        Snake,&#10;        Frog&#10;    }&#10;&#10;    public static class EnemyFactory&#10;    {&#10;        // Configures an existing enemy instance using the builder pattern&#10;        public static void ConfigureEnemy(EnemyType type, EnemyBase enemy)&#10;        {&#10;            if (enemy == null) throw new ArgumentNullException(nameof(enemy));&#10;            var builder = new EnemyBuilder(enemy);&#10;            switch (type)&#10;            {&#10;                case EnemyType.FireSnake:&#10;                    builder.WithFireSnakeBehavior();&#10;                    break;&#10;                case EnemyType.Spider:&#10;                    builder.WithSpiderBehavior();&#10;                    break;&#10;                case EnemyType.Bird:&#10;                    builder.WithBirdBehavior();&#10;                    break;&#10;                case EnemyType.Snake:&#10;                    builder.WithSnakeBehavior();&#10;                    break;&#10;                case EnemyType.Frog:&#10;                    builder.WithFrogBehavior();&#10;                    break;&#10;                default:&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/FireSnakeEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/FireSnakeEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Weapons.Models;&#10;&#10;namespace Enemy&#10;{&#10;    public class FireSnakeEnemy : EnemyBase&#10;    {&#10;        [SerializeField] private FireballWeapon fireballWeapon;&#10;        [SerializeField] private float attackCooldown = 2f;&#10;        private float _nextAttackTime;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            if (fireballWeapon != null)&#10;                fireballWeapon.Equip();&#10;        }&#10;&#10;        public override void Attack()&#10;        {&#10;            if (fireballWeapon == null)&#10;                return;&#10;            if (Time.time &lt; _nextAttackTime)&#10;                return;&#10;            fireballWeapon.Shoot();&#10;            _nextAttackTime = Time.time + attackCooldown;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/FrogEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/FrogEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Frog: Jumps higher and farther, jumps when player is near&#10;    public class FrogEnemy : EnemyBase, IMovable, IPlayerProximityReactable&#10;    {&#10;        [SerializeField] private float jumpForce = 12f;&#10;        [SerializeField] private float jumpDistance = 6f;&#10;        [SerializeField] private float jumpCooldown = 2f;&#10;        private float _nextJumpTime;&#10;        private Rigidbody2D _rb;&#10;        private bool _playerNearby;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (_playerNearby &amp;&amp; Time.time &gt;= _nextJumpTime)&#10;            {&#10;                Vector2 jumpVector = new Vector2(jumpDistance, jumpForce);&#10;                _rb.AddForce(jumpVector, ForceMode2D.Impulse);&#10;                _nextJumpTime = Time.time + jumpCooldown;&#10;                _playerNearby = false; // Only jump once per proximity event&#10;            }&#10;        }&#10;&#10;        public void OnPlayerNearby()&#10;        {&#10;            _playerNearby = true;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/EnemyBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/EnemyBase.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/FireSnake.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/FireSnake.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/SnakeEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/SnakeEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Snake: Jumps forward&#10;    public class SnakeEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private float jumpForce = 7f;&#10;        [SerializeField] private float jumpInterval = 2f;&#10;        private float _nextJumpTime;&#10;        private Rigidbody2D _rb;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (Time.time &gt;= _nextJumpTime)&#10;            {&#10;                _rb.AddForce(Vector2.right * jumpForce, ForceMode2D.Impulse);&#10;                _nextJumpTime = Time.time + jumpInterval;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/SpiderEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/SpiderEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Spider: Can move up/down or stay static in air&#10;    public class SpiderEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private bool canMove = true;&#10;        [SerializeField] private float moveSpeed = 2f;&#10;        [SerializeField] private float moveDistance = 3f;&#10;        private Vector3 _startPos;&#10;        private bool _movingUp = true;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _startPos = transform.position;&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (!canMove) return;&#10;            float delta = moveSpeed * Time.deltaTime * (_movingUp ? 1 : -1);&#10;            transform.position += new Vector3(0, delta, 0);&#10;            if (Mathf.Abs(transform.position.y - _startPos.y) &gt; moveDistance)&#10;                _movingUp = !_movingUp;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Health.Interfaces;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class AlwaysAllowDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        public bool CanBeDamagedBy(GameObject damager) =&gt; true;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All layers by default&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target))&#10;                return;&#10;&#10;            int amount = _dealer?.GetDamageAmount() ?? 1;&#10;            damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using System.Linq;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class BidirectionalDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject other = collision.gameObject;&#10;            GameObject self = gameObject;&#10;&#10;            // 1. This object damages the other&#10;            TryDealDamage(self, other, _dealer, _damageConditions, targetLayers);&#10;&#10;            // 2. The other object damages this&#10;            var otherDealer = other.GetComponent&lt;IDamageDealer&gt;();&#10;            var otherConditions = other.GetComponent&lt;DamageConditionsComponent&gt;();&#10;            TryDealDamage(other, self, otherDealer, otherConditions, targetLayers);&#10;        }&#10;&#10;        private static void TryDealDamage(&#10;            GameObject dealerObj,&#10;            GameObject targetObj,&#10;            IDamageDealer dealer,&#10;            DamageConditionsComponent conditions,&#10;            LayerMask targetLayers)&#10;        {&#10;            if (dealer == null) return;&#10;            if (((1 &lt;&lt; targetObj.layer) &amp; targetLayers) == 0) return;&#10;            var damageable = targetObj.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (conditions &amp;&amp; !conditions.CanBeDamagedBy(targetObj)) return;&#10;            int amount = dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, dealerObj);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;// This script is now deprecated in favor of TakeDamageOnCollision for most use cases.&#10;// Please use TakeDamageOnCollision on all damageable objects instead." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            foreach (IDamageCondition cond in _conditions)&#10;            {&#10;                if (cond != null &amp;&amp; !cond.CanBeDamagedBy(damager))&#10;                    return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            return _conditions.All(cond =&gt; cond == null || cond.CanBeDamagedBy(damager));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs" />
              <option name="originalContent" value="using Health.Damage;&#10;using UnityEditor;&#10;using UnityEngine;&#10;&#10;[CustomPropertyDrawer(typeof(ConditionLeaf))]&#10;public class ConditionLeafPropertyDrawer : ConditionNodePropertyDrawer {}&#10;&#10;[CustomPropertyDrawer(typeof(AndCondition))]&#10;public class AndConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;AND Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(OrCondition))]&#10;public class OrConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;OR Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(NotCondition))]&#10;public class NotConditionPropertyDrawer : ConditionNodePropertyDrawer {}&#10;" />
              <option name="updatedContent" value="// All custom property drawers for node types are now handled by ConditionNodePropertyDrawer.&#10;// This file is no longer needed and can be deleted, or you can leave it empty." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/README.md" />
              <option name="updatedContent" value="// Health/README.md&#10;&#10;# Health System Setup Guide&#10;&#10;## Folder Structure&#10;- `Core/` – Health logic&#10;- `Interfaces/` – All interfaces&#10;- `Shield/` – Shield logic&#10;- `Invincibility/` – Invincibility logic&#10;- `Damage/` – Damage logic and conditions&#10;&#10;## How to Compose Entities in Unity Editor&#10;&#10;### Player (Basic)&#10;- Add `HealthComponent` (Core)&#10;&#10;### Player with Shield&#10;- Add `HealthComponent` (Core)&#10;- Add `ShieldComponent` (Shield)&#10;&#10;### Player with Invincibility&#10;- Add `HealthComponent` (Core)&#10;- Add `InvincibilityComponent` (Invincibility)&#10;- Connect to your `IPowerUp` system to toggle invincibility&#10;&#10;### Enemy&#10;- Add `HealthComponent` (Core)&#10;&#10;### Hazard (Standard)&#10;- Add `HazardComponent` (Damage)&#10;- Add `DamageDealerComponent` (Damage)&#10;- Add a damage condition (e.g., `AlwaysAllowDamage`, `OnlyInvincibleCanDamage`, `OnlyShieldedCanDamage`) as needed&#10;- Assign the condition(s) to the `HazardComponent`'s `damageConditions` array in the Inspector&#10;&#10;### Custom Damage Conditions&#10;- Create a new MonoBehaviour implementing `IDamageCondition`&#10;- Add it to the hazard GameObject&#10;- Assign it in the `HazardComponent`&#10;&#10;## Extending&#10;- To add new damage conditions, create a new script implementing `IDamageCondition` and add it in the Editor. No need to modify existing code.&#10;&#10;## Events&#10;- Use UnityEvents or C# events on components for custom reactions (e.g., OnDeath, OnShieldBroken)&#10;&#10;## Cleanup&#10;- Remove old scripts like `ShieldActiveDisappearHazard`, `OnlyInvincibilityDamageController`, etc. after migration.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// When enabled, instantly kills any damageable object the player collides with.&#10;    /// Should be enabled only when the player is invincible.&#10;    /// &lt;/summary&gt;&#10;    [DisallowMultipleComponent]&#10;    public class PlayerInvincibleDamageDealer : MonoBehaviour, IDamageDealer&#10;    {&#10;        [SerializeField] private int damageAmount = 9999; // &quot;Kill&quot; value&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All by default&#10;&#10;        public int GetDamageAmount() =&gt; damageAmount;&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if (((1 &lt;&lt; collision.gameObject.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            var damageable = collision.gameObject.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable != null)&#10;            {&#10;                damageable.Damage(damageAmount, gameObject);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Services/PlayerLivesService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Services/PlayerLivesService.cs" />
              <option name="originalContent" value="using System;&#10;using Core.Data;&#10;using Core.Events;&#10;using Player.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Player.Services&#10;{&#10;    public class PlayerLivesService : IPlayerLivesService&#10;    {&#10;        private readonly IEventBus _eventBus;&#10;        private readonly IGameDataService _gameDataService;&#10;&#10;        public PlayerLivesService(IGameDataService gameDataService, IEventBus eventBus)&#10;        {&#10;            _gameDataService = gameDataService;&#10;            _eventBus = eventBus;&#10;            MaxLives = GameData.MaxLives;&#10;&#10;            Debug.Log(&quot;[PlayerLivesService] Initialized with max lives: &quot; + MaxLives);&#10;            &#10;            if (_gameDataService == null)&#10;            {&#10;                Debug.LogError(&quot;[PlayerLivesService] _gameDataService is null.&quot;);&#10;            }&#10;&#10;            if (_eventBus == null)&#10;            {&#10;                Debug.LogError(&quot;[PlayerLivesService] _eventBus is null.&quot;);&#10;            }&#10;        }&#10;&#10;        public int CurrentLives =&gt; _gameDataService.CurrentData.lives;&#10;        public int MaxLives { get; }&#10;&#10;        public bool HasLivesRemaining =&gt; CurrentLives &gt; 0;&#10;&#10;        public event Action&lt;int&gt; OnLivesChanged;&#10;        public event Action&lt;Vector3&gt; OnOneUpAwarded;&#10;        public bool TryUseLife()&#10;        {&#10;            if (CurrentLives &lt;= 0) return false;&#10;&#10;            int newLives = CurrentLives - 1;&#10;&#10;            _eventBus?.Publish(new PlayerLivesChangedEvent&#10;            {&#10;                PreviousLives = CurrentLives,&#10;                CurrentLives = newLives,&#10;                MaxLives = MaxLives,&#10;                PreviousLives = CurrentLives,&#10;            });&#10;&#10;            return newLives &gt; 0;&#10;        }&#10;&#10;        public void ResetLives()&#10;        {&#10;            _gameDataService.UpdateLives(MaxLives);&#10;            OnLivesChanged?.Invoke(MaxLives);&#10;        }&#10;&#10;        public void AddLife(Vector3 collectPosition)&#10;        {&#10;            int newLives = CurrentLives + 1;&#10;            _gameDataService.UpdateLives(newLives);&#10;            OnLivesChanged?.Invoke(newLives);&#10;            OnOneUpAwarded?.Invoke(collectPosition);&#10;            _eventBus?.Publish(new PlayerLivesChangedEvent&#10;            {&#10;            int newLives = CurrentLives + 1;&#10;            });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using Core.Data;&#10;using Core.Events;&#10;using Player.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Player.Services&#10;{&#10;    public class PlayerLivesService : IPlayerLivesService&#10;    {&#10;        private readonly IEventBus _eventBus;&#10;        private readonly IGameDataService _gameDataService;&#10;&#10;        public PlayerLivesService(IGameDataService gameDataService, IEventBus eventBus)&#10;        {&#10;            _gameDataService = gameDataService;&#10;            _eventBus = eventBus;&#10;            MaxLives = GameData.MaxLives;&#10;&#10;            Debug.Log(&quot;[PlayerLivesService] Initialized with max lives: &quot; + MaxLives);&#10;            &#10;            if (_gameDataService == null)&#10;            {&#10;                Debug.LogError(&quot;[PlayerLivesService] _gameDataService is null.&quot;);&#10;            }&#10;&#10;            if (_eventBus == null)&#10;            {&#10;                Debug.LogError(&quot;[PlayerLivesService] _eventBus is null.&quot;);&#10;            }&#10;        }&#10;&#10;        public int CurrentLives =&gt; _gameDataService.CurrentData.lives;&#10;        public int MaxLives { get; }&#10;&#10;        public bool HasLivesRemaining =&gt; CurrentLives &gt; 0;&#10;&#10;        public event Action&lt;int&gt; OnLivesChanged;&#10;        public event Action&lt;Vector3&gt; OnOneUpAwarded;&#10;        public bool TryUseLife()&#10;        {&#10;            if (CurrentLives &lt;= 0) return false;&#10;&#10;            int previousLives = CurrentLives;&#10;            int newLives = previousLives - 1;&#10;&#10;            // Update lives before publishing the event&#10;            _gameDataService.UpdateLives(newLives);&#10;&#10;            OnLivesChanged?.Invoke(newLives);&#10;&#10;            _eventBus?.Publish(new PlayerLivesChangedEvent&#10;            {&#10;                PreviousLives = previousLives,&#10;                CurrentLives = newLives,&#10;                MaxLives = MaxLives,&#10;                Timestamp = Time.time&#10;            });&#10;&#10;            return newLives &gt; 0;&#10;        }&#10;&#10;        public void ResetLives()&#10;        {&#10;            _gameDataService.UpdateLives(MaxLives);&#10;            OnLivesChanged?.Invoke(MaxLives);&#10;        }&#10;&#10;        public void AddLife(Vector3 collectPosition)&#10;        {&#10;            int previousLives = CurrentLives;&#10;            int newLives = previousLives + 1;&#10;&#10;            // Update lives before publishing the event&#10;            _gameDataService.UpdateLives(newLives);&#10;&#10;            OnLivesChanged?.Invoke(newLives);&#10;            OnOneUpAwarded?.Invoke(collectPosition);&#10;            _eventBus?.Publish(new PlayerLivesChangedEvent&#10;            {&#10;                PreviousLives = previousLives,&#10;                CurrentLives = newLives,&#10;                MaxLives = MaxLives,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Pooling/PooledObject.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Pooling/PooledObject.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Pooling&#10;{&#10;    public class PooledObject : MonoBehaviour&#10;    {&#10;        public GameObject prefab;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>