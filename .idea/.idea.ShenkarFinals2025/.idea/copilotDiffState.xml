<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Audio/Controllers/PlayerAudioController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Audio/Controllers/PlayerAudioController.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using Audio.Data;&#10;using Audio.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Audio.Controllers&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Player-specific audio controller following Single Responsibility Principle&#10;    /// Only handles player audio events, delegates actual audio playing to AudioService&#10;    /// &lt;/summary&gt;&#10;    public class PlayerAudioController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Player Sound Events&quot;)]&#10;        [SerializeField] private SoundData jumpSound;&#10;        [SerializeField] private SoundData collectSound;&#10;        [SerializeField] private SoundData deathSound;&#10;        [SerializeField] private SoundData damageSound;&#10;        &#10;        private IAudioService _audioService;&#10;        &#10;        [Inject]&#10;        public void Construct(IAudioService audioService)&#10;        {&#10;            _audioService = audioService;&#10;        }&#10;        &#10;        public void PlayJumpSound()&#10;        {&#10;            PlaySoundData(jumpSound);&#10;        }&#10;        &#10;        public void PlayCollectSound()&#10;        {&#10;            PlaySoundData(collectSound);&#10;        }&#10;        &#10;        public void PlayDeathSound()&#10;        {&#10;            PlaySoundData(deathSound);&#10;        }&#10;        &#10;        public void PlayDamageSound()&#10;        {&#10;            PlaySoundData(damageSound);&#10;        }&#10;        &#10;        public void PlayCollectSoundAtPosition(Vector3 position)&#10;        {&#10;            PlaySoundDataAtPosition(collectSound, position);&#10;        }&#10;        &#10;        private void PlaySoundData(SoundData soundData)&#10;        {&#10;            if (soundData?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(&#10;                    soundData.clip, &#10;                    soundData.GetRandomizedVolume(), &#10;                    soundData.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;        &#10;        private void PlaySoundDataAtPosition(SoundData soundData, Vector3 position)&#10;        {&#10;            if (soundData?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySoundAtPosition(&#10;                    soundData.clip, &#10;                    position,&#10;                    soundData.GetRandomizedVolume(), &#10;                    soundData.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Audio/DI/AudioLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Audio/DI/AudioLifetimeScope.cs" />
              <option name="originalContent" value="using Audio.Controllers;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using Audio.Services;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using Player.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace Audio.DI&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Dependency injection configuration for audio system&#10;    /// Follows Dependency Inversion Principle by registering interfaces&#10;    /// Registers ALL classes that need audio injection&#10;    /// &lt;/summary&gt;&#10;    public class AudioLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            builder.RegisterComponentInHierarchy&lt;AudioService&gt;()&#10;                .As&lt;IAudioService&gt;()&#10;                .AsSelf();&#10;&#10;            RegisterAudioDependentComponents(builder);&#10;        }&#10;&#10;        private static void RegisterAudioDependentComponents(IContainerBuilder builder)&#10;        {&#10;            // Register Player Audio Components&#10;            builder.RegisterComponentInHierarchy&lt;PlayerAudioController&gt;();&#10;            &#10;            // Register Player Services that need audio&#10;            builder.RegisterComponentInHierarchy&lt;HealthBonusService&gt;();&#10;            &#10;            // Register Level Selection Controller that needs audio&#10;            builder.RegisterComponentInHierarchy&lt;LevelSelectionController&gt;();&#10;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Audio.Data;&#10;using Audio.Interfaces;&#10;using Audio.Services;&#10;using LevelSelection;&#10;using Player.Components;&#10;using Player.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace Audio.DI&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Dependency injection configuration for audio system&#10;    /// Follows Dependency Inversion Principle by registering interfaces&#10;    /// Registers ALL classes that need audio injection&#10;    /// &lt;/summary&gt;&#10;    public class AudioLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            builder.RegisterComponentInHierarchy&lt;AudioService&gt;()&#10;                .As&lt;IAudioService&gt;()&#10;                .AsSelf();&#10;&#10;            RegisterAudioDependentComponents(builder);&#10;        }&#10;&#10;        private static void RegisterAudioDependentComponents(IContainerBuilder builder)&#10;        {&#10;            // Register Player Components that need audio&#10;            builder.RegisterComponentInHierarchy&lt;PlayerSoundController&gt;();&#10;            &#10;            // Register Player Services that need audio&#10;            builder.RegisterComponentInHierarchy&lt;HealthBonusService&gt;();&#10;            &#10;            // Register Level Selection Controller that needs audio&#10;            builder.RegisterComponentInHierarchy&lt;LevelSelectionController&gt;();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Audio/Data/AudioConfig.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Audio/Data/AudioConfig.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Audio.Data&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Configuration data for audio settings (Single Responsibility)&#10;    /// &lt;/summary&gt;&#10;    [System.Serializable]&#10;    public class AudioConfig&#10;    {&#10;        [Header(&quot;Volume Settings&quot;)]&#10;        [Range(0f, 1f)] public float masterVolume = 1f;&#10;        [Range(0f, 1f)] public float sfxVolume = 1f;&#10;        [Range(0f, 1f)] public float musicVolume = 1f;&#10;        &#10;        [Header(&quot;Audio Source Settings&quot;)]&#10;        public int maxConcurrentSounds = 10;&#10;        public float defaultPitch = 1f;&#10;        &#10;        [Header(&quot;3D Audio Settings&quot;)]&#10;        public float spatialBlend = 0f; // 0 = 2D, 1 = 3D&#10;        public float minDistance = 1f;&#10;        public float maxDistance = 500f;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Audio/Data/SoundData.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Audio/Data/SoundData.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Audio.Data&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Simple sound data container without ScriptableObjects&#10;    /// &lt;/summary&gt;&#10;    [System.Serializable]&#10;    public class SoundData&#10;    {&#10;        [Header(&quot;Audio Clip&quot;)]&#10;        public AudioClip clip;&#10;        &#10;        [Header(&quot;Settings&quot;)]&#10;        [Range(0f, 1f)] public float volume = 1f;&#10;        [Range(0.1f, 3f)] public float pitch = 1f;&#10;        [Range(0f, 0.5f)] public float randomVolumeVariance = 0f;&#10;        [Range(0f, 0.5f)] public float randomPitchVariance = 0f;&#10;        &#10;        [Header(&quot;3D Audio&quot;)]&#10;        public bool use3D = false;&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Get randomized volume within variance range&#10;        /// &lt;/summary&gt;&#10;        public float GetRandomizedVolume()&#10;        {&#10;            return volume + Random.Range(-randomVolumeVariance, randomVolumeVariance);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Get randomized pitch within variance range&#10;        /// &lt;/summary&gt;&#10;        public float GetRandomizedPitch()&#10;        {&#10;            return pitch + Random.Range(-randomPitchVariance, randomPitchVariance);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Audio/Data/SoundEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Audio/Data/SoundEvent.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Audio/Interfaces/IAudioService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Audio/Interfaces/IAudioService.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Audio.Interfaces&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Main audio service interface for playing sounds and music&#10;    /// &lt;/summary&gt;&#10;    public interface IAudioService&#10;    {&#10;        void PlaySound(AudioClip clip, float volume = 1f, float pitch = 1f);&#10;        void PlaySoundAtPosition(AudioClip clip, Vector3 position, float volume = 1f, float pitch = 1f);&#10;        void PlayMusic(AudioClip clip, float volume = 1f, bool loop = true);&#10;        void StopMusic();&#10;        void SetMasterVolume(float volume);&#10;        void SetSFXVolume(float volume);&#10;        void SetMusicVolume(float volume);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Audio/Services/AudioService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Audio/Services/AudioService.cs" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Audio.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Main audio service implementation following SOLID principles&#10;    /// Single Responsibility: Manages all audio playback&#10;    /// Open/Closed: Extensible through interfaces&#10;    /// Dependency Inversion: Depends on abstractions&#10;    /// &lt;/summary&gt;&#10;    public class AudioService : MonoBehaviour, IAudioService&#10;    {&#10;        [SerializeField] private AudioConfig audioConfig = new AudioConfig();&#10;        &#10;        private AudioSource _musicSource;&#10;        private List&lt;AudioSource&gt; _sfxSources;&#10;        private int _currentSfxIndex = 0;&#10;        &#10;        private float _masterVolume = 1f;&#10;        private float _sfxVolume = 1f;&#10;        private float _musicVolume = 1f;&#10;&#10;        private void Awake()&#10;        {&#10;            // Don't destroy on load for persistent audio&#10;            DontDestroyOnLoad(gameObject);&#10;            &#10;            InitializeAudioSources();&#10;            LoadVolumeSettings();&#10;        }&#10;&#10;        private void InitializeAudioSources()&#10;        {&#10;            // Create dedicated music source&#10;            _musicSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            _musicSource.loop = true;&#10;            _musicSource.playOnAwake = false;&#10;            &#10;            // Create pool of SFX sources for concurrent sounds&#10;            _sfxSources = new List&lt;AudioSource&gt;();&#10;            int maxSources = audioConfig.maxConcurrentSounds;&#10;            &#10;            for (int i = 0; i &lt; maxSources; i++)&#10;            {&#10;                AudioSource sfxSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;                sfxSource.playOnAwake = false;&#10;                sfxSource.loop = false;&#10;                _sfxSources.Add(sfxSource);&#10;            }&#10;        }&#10;&#10;        private void LoadVolumeSettings()&#10;        {&#10;            _masterVolume = audioConfig.masterVolume;&#10;            _sfxVolume = audioConfig.sfxVolume;&#10;            _musicVolume = audioConfig.musicVolume;&#10;        }&#10;&#10;        public void PlaySound(AudioClip clip, float volume = 1f, float pitch = 1f)&#10;        {&#10;            if (!clip) return;&#10;            &#10;            AudioSource availableSource = GetAvailableSfxSource();&#10;            if (!availableSource) return;&#10;&#10;            ConfigureSfxSource(availableSource, clip, volume, pitch);&#10;            availableSource.Play();&#10;        }&#10;&#10;        public void PlaySoundAtPosition(AudioClip clip, Vector3 position, float volume = 1f, float pitch = 1f)&#10;        {&#10;            if (!clip) return;&#10;            &#10;            // Create temporary audio source at position for 3D audio&#10;            GameObject tempAudioObject = new GameObject($&quot;TempAudio_{clip.name}&quot;);&#10;            tempAudioObject.transform.position = position;&#10;            &#10;            AudioSource tempSource = tempAudioObject.AddComponent&lt;AudioSource&gt;();&#10;            ConfigureSfxSource(tempSource, clip, volume, pitch, true);&#10;            &#10;            tempSource.Play();&#10;            &#10;            // Destroy after clip finishes&#10;            Destroy(tempAudioObject, clip.length);&#10;        }&#10;&#10;        public void PlayMusic(AudioClip clip, float volume = 1f, bool loop = true)&#10;        {&#10;            if (!clip || !_musicSource) return;&#10;            &#10;            _musicSource.clip = clip;&#10;            _musicSource.volume = volume * _musicVolume * _masterVolume;&#10;            _musicSource.loop = loop;&#10;            _musicSource.Play();&#10;        }&#10;&#10;        public void StopMusic()&#10;        {&#10;            if (_musicSource)&#10;            {&#10;                _musicSource.Stop();&#10;            }&#10;        }&#10;&#10;        public void SetMasterVolume(float volume)&#10;        {&#10;            _masterVolume = Mathf.Clamp01(volume);&#10;            UpdateAllVolumes();&#10;        }&#10;&#10;        public void SetSFXVolume(float volume)&#10;        {&#10;            _sfxVolume = Mathf.Clamp01(volume);&#10;        }&#10;&#10;        public void SetMusicVolume(float volume)&#10;        {&#10;            _musicVolume = Mathf.Clamp01(volume);&#10;            if (_musicSource &amp;&amp; _musicSource.isPlaying)&#10;            {&#10;                _musicSource.volume = _musicSource.volume * _musicVolume * _masterVolume;&#10;            }&#10;        }&#10;&#10;        private AudioSource GetAvailableSfxSource()&#10;        {&#10;            // Find an available (not playing) source&#10;            foreach (var source in _sfxSources)&#10;            {&#10;                if (!source.isPlaying)&#10;                {&#10;                    return source;&#10;                }&#10;            }&#10;            &#10;            // If all sources are busy, use round-robin&#10;            AudioSource roundRobinSource = _sfxSources[_currentSfxIndex];&#10;            _currentSfxIndex = (_currentSfxIndex + 1) % _sfxSources.Count;&#10;            return roundRobinSource;&#10;        }&#10;&#10;        private void ConfigureSfxSource(AudioSource source, AudioClip clip, float volume, float pitch, bool is3D = false)&#10;        {&#10;            source.clip = clip;&#10;            source.volume = volume * _sfxVolume * _masterVolume;&#10;            source.pitch = pitch;&#10;            &#10;            source.spatialBlend = is3D ? 1f : audioConfig.spatialBlend;&#10;            source.minDistance = audioConfig.minDistance;&#10;            source.maxDistance = audioConfig.maxDistance;&#10;        }&#10;&#10;        private void UpdateAllVolumes()&#10;        {&#10;            // Update music volume&#10;            if (_musicSource &amp;&amp; _musicSource.isPlaying)&#10;            {&#10;                float currentMusicVolume = _musicSource.volume / (_musicVolume * _masterVolume);&#10;                _musicSource.volume = currentMusicVolume * _musicVolume * _masterVolume;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/DI/GameLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/DI/GameLifetimeScope.cs" />
              <option name="originalContent" value="using Collectables.Score;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using Player.Interfaces;&#10;using Player.Services;&#10;using Player.UI;&#10;using Pooling;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;using Weapons.Models;&#10;using Weapons.Services;&#10;&#10;namespace Core.DI&#10;{&#10;    public class GameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Awake()&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Awake called.&quot;);&#10;            AddToAutoInject&lt;FireballWeapon&gt;();&#10;            base.Awake();&#10;        }&#10;&#10;        private void AddToAutoInject&lt;T&gt;() where T : Component&#10;        {&#10;&#10;            var components = FindObjectsByType&lt;T&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;&#10;            foreach (T comp in components)&#10;            {&#10;                autoInjectGameObjects.Add(comp.gameObject);&#10;            }&#10;        }&#10;&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Configuring DI container...&quot;);&#10;&#10;            // Register Core Services&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;&#10;            // Register EventBus as IEventPublisher as well (since EventBus implements IEventPublisher)&#10;            builder.Register&lt;IEventPublisher&gt;(resolver =&gt; resolver.Resolve&lt;IEventBus&gt;(), Lifetime.Singleton);&#10;&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IScoreService, ScoreService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ILevelDiscoveryService, LevelDiscoveryService&gt;(Lifetime.Singleton);&#10;            builder.RegisterComponentInHierarchy&lt;SceneLoadService&gt;().As&lt;ISceneLoadService&gt;();&#10;&#10;&#10;            // Register Player Services&#10;            builder.Register&lt;IPlayerLivesService&gt;(resolver&#10;                =&gt; new PlayerLivesService(&#10;                    resolver.Resolve&lt;GameDataCoordinator&gt;()&#10;                ), Lifetime.Singleton);&#10;&#10;&#10;            // Game Management&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;EndLevelZone&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;HealthBonusService&gt;();&#10;            // Pooling System&#10;            builder.RegisterComponentInHierarchy&lt;PoolManager&gt;().As&lt;IPoolService&gt;();&#10;&#10;            // Weapons&#10;            builder.RegisterComponentInHierarchy&lt;AxeWeapon&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;WeaponManagerService&gt;();&#10;&#10;            // Health&#10;            builder.RegisterComponentInHierarchy&lt;PlayerHealthController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerLivesUIController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerAnimationController&gt;();&#10;&#10;            builder.RegisterComponentInHierarchy&lt;ScoreController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PopupTextService&gt;();&#10;&#10;&#10;            Debug.Log(&quot;[GameLifetimeScope] DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Collectables.Score;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using Health.Damage;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using Player.Interfaces;&#10;using Player.Services;&#10;using Player.UI;&#10;using Pooling;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;using Weapons.Models;&#10;using Weapons.Services;&#10;&#10;namespace Core.DI&#10;{&#10;    public class GameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Awake()&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Awake called.&quot;);&#10;            AddToAutoInject&lt;FireballWeapon&gt;();&#10;            base.Awake();&#10;        }&#10;&#10;        private void AddToAutoInject&lt;T&gt;() where T : Component&#10;        {&#10;&#10;            var components = FindObjectsByType&lt;T&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;&#10;            foreach (T comp in components)&#10;            {&#10;                autoInjectGameObjects.Add(comp.gameObject);&#10;            }&#10;        }&#10;&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Configuring DI container...&quot;);&#10;&#10;            // Register Core Services&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;&#10;            // Register EventBus as IEventPublisher as well (since EventBus implements IEventPublisher)&#10;            builder.Register&lt;IEventPublisher&gt;(resolver =&gt; resolver.Resolve&lt;IEventBus&gt;(), Lifetime.Singleton);&#10;&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IScoreService, ScoreService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ILevelDiscoveryService, LevelDiscoveryService&gt;(Lifetime.Singleton);&#10;            builder.RegisterComponentInHierarchy&lt;SceneLoadService&gt;().As&lt;ISceneLoadService&gt;();&#10;&#10;&#10;            // Register Player Services&#10;            builder.Register&lt;IPlayerLivesService&gt;(resolver&#10;                =&gt; new PlayerLivesService(&#10;                    resolver.Resolve&lt;GameDataCoordinator&gt;()&#10;                ), Lifetime.Singleton);&#10;&#10;&#10;            // Game Management&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;EndLevelZone&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;HealthBonusService&gt;();&#10;            // Pooling System&#10;            builder.RegisterComponentInHierarchy&lt;PoolManager&gt;().As&lt;IPoolService&gt;();&#10;&#10;            // Weapons&#10;            builder.RegisterComponentInHierarchy&lt;AxeWeapon&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;WeaponManagerService&gt;();&#10;&#10;            // Health&#10;            builder.RegisterComponentInHierarchy&lt;PlayerHealthController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerLivesUIController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerAnimationController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PeriodicBypassDamageDealer&gt;();&#10;&#10;            // Score System&#10;            builder.RegisterComponentInHierarchy&lt;ScoreController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PopupTextService&gt;();&#10;&#10;&#10;            Debug.Log(&quot;[GameLifetimeScope] DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Data/GameDataService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Data/GameDataService.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Core.Data&#10;{&#10;    public class GameDataService : IGameDataService&#10;    {&#10;        private readonly IGameDataRepository _repository;&#10;&#10;        [Inject]&#10;        public GameDataService(IGameDataRepository repository)&#10;        {&#10;            _repository = repository;&#10;            CurrentData = _repository.LoadData();&#10;        }&#10;&#10;        public GameData CurrentData { get; private set; }&#10;&#10;        public event Action&lt;GameData&gt; OnDataChanged;&#10;&#10;        public void UpdateLives(int lives)&#10;        {&#10;            CurrentData.lives = lives;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateScore(int score)&#10;        {&#10;            int previousScore = CurrentData.score;&#10;            CurrentData.score = score;&#10;            &#10;            // Update maxScore if current score is higher&#10;            if (score &gt; CurrentData.maxScore)&#10;            {&#10;                CurrentData.maxScore = score;&#10;                Debug.Log($&quot;[GameDataService] New high score achieved: {score}&quot;);&#10;            }&#10;            &#10;            Debug.Log($&quot;[GameDataService] Score updated: {previousScore} -&gt; {score}, MaxScore: {CurrentData.maxScore}&quot;);&#10;            NotifyDataChanged();&#10;            &#10;            // Force save on score changes to ensure persistence&#10;            SaveData();&#10;        }&#10;&#10;&#10;        public void UpdateCurrentLevel(string levelName)&#10;        {&#10;            CurrentData.currentLevel = levelName;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateBestTime(string levelName, float time)&#10;        {&#10;            var gameData = CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update overall best time&#10;            if (time &lt; gameData.bestTime)&#10;            {&#10;                gameData.bestTime = time;&#10;            }&#10;&#10;            // Update per-level best time&#10;            if (!gameData.LevelBestTimes.ContainsKey(levelName) || time &lt; gameData.LevelBestTimes[levelName])&#10;            {&#10;                gameData.LevelBestTimes[levelName] = time;&#10;            }&#10;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void ResetAllData()&#10;        {&#10;            _repository.DeleteData();&#10;            CurrentData = _repository.LoadData();&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void ResetProgressData()&#10;        {&#10;            // Reset only player progress data, preserve score and fruit count&#10;            CurrentData.lives = GameData.MaxLives;&#10;            CurrentData.currentLevel = &quot;&quot;;&#10;            CurrentData.selectedLevelIndex = 0;&#10;            // Note: Score, maxScore, fruitCollected, unlockedLevels, completedLevels, and best times are preserved&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void SaveData()&#10;        {&#10;            _repository.SaveData(CurrentData);&#10;        }&#10;&#10;        public void AddFruitCollected()&#10;        {&#10;            CurrentData.fruitCollected++;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime)&#10;        {&#10;            var gameData = CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update completed levels list&#10;            if (isCompleted &amp;&amp; !gameData.completedLevels.Contains(levelName))&#10;            {&#10;                gameData.completedLevels.Add(levelName);&#10;            }&#10;&#10;            // Update best time&#10;            if (!gameData.LevelBestTimes.ContainsKey(levelName) || completionTime &lt; gameData.LevelBestTimes[levelName])&#10;            {&#10;                gameData.LevelBestTimes[levelName] = completionTime;&#10;            }&#10;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UnlockLevel(string levelName)&#10;        {&#10;            if (CurrentData != null &amp;&amp; !string.IsNullOrEmpty(levelName) &amp;&amp; !CurrentData.unlockedLevels.Contains(levelName))&#10;            {&#10;                CurrentData.unlockedLevels.Add(levelName);&#10;                Debug.Log($&quot;[GameDataService] Level '{levelName}' unlocked and added to unlocked levels list&quot;);&#10;                NotifyDataChanged();&#10;                SaveData(); &#10;            }&#10;        }&#10;&#10;        public async Task&lt;List&lt;LevelData&gt;&gt; GetLevelDataAsync(ILevelDiscoveryService discoveryService)&#10;        {&#10;            if (CurrentData.levelDataCacheValid &amp;&amp; CurrentData.cachedLevelData.Any())&#10;            {&#10;                // Always re-apply default unlock status in case settings changed&#10;                ApplyDefaultUnlockStatus(CurrentData.cachedLevelData);&#10;                return CurrentData.cachedLevelData;&#10;            }&#10;&#10;            var discoveredLevels = await discoveryService.DiscoverLevelsFromSceneAsync();&#10;            CacheLevelData(discoveredLevels);&#10;            return discoveredLevels;&#10;        }&#10;&#10;        private void CacheLevelData(List&lt;LevelData&gt; levelData)&#10;        {&#10;            CurrentData.cachedLevelData = new List&lt;LevelData&gt;(levelData.OrderBy(l =&gt; l.levelIndex));&#10;            CurrentData.levelDataCacheValid = true;&#10;&#10;            // Apply default unlock status from level data&#10;            ApplyDefaultUnlockStatus(levelData);&#10;&#10;            SaveData();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Apply default unlock status from discovered level data&#10;        /// &lt;/summary&gt;&#10;        private void ApplyDefaultUnlockStatus(List&lt;LevelData&gt; levelData)&#10;        {&#10;            foreach (LevelData level in levelData.Where(level =&gt;&#10;                         level.UnlockedByDefault &amp;&amp; !CurrentData.unlockedLevels.Contains(level.levelName)))&#10;            {&#10;                CurrentData.unlockedLevels.Add(level.levelName);&#10;                Debug.Log($&quot;[GameDataService] Auto-unlocked level: {level.levelName} (UnlockedByDefault = true)&quot;);&#10;            }&#10;        }&#10;&#10;        private void NotifyDataChanged()&#10;        {&#10;            OnDataChanged?.Invoke(CurrentData);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Core.Data&#10;{&#10;    public class GameDataService : IGameDataService&#10;    {&#10;        private readonly IGameDataRepository _repository;&#10;&#10;        [Inject]&#10;        public GameDataService(IGameDataRepository repository)&#10;        {&#10;            _repository = repository;&#10;            CurrentData = _repository.LoadData();&#10;        }&#10;&#10;        public GameData CurrentData { get; private set; }&#10;&#10;        public event Action&lt;GameData&gt; OnDataChanged;&#10;&#10;        public void UpdateLives(int lives)&#10;        {&#10;            CurrentData.lives = lives;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateScore(int score)&#10;        {&#10;            int previousScore = CurrentData.score;&#10;            CurrentData.score = score;&#10;            &#10;            // Update maxScore if current score is higher&#10;            if (score &gt; CurrentData.maxScore)&#10;            {&#10;                CurrentData.maxScore = score;&#10;                Debug.Log($&quot;[GameDataService] New high score achieved: {score}&quot;);&#10;            }&#10;            &#10;            Debug.Log($&quot;[GameDataService] Score updated: {previousScore} -&gt; {score}, MaxScore: {CurrentData.maxScore}&quot;);&#10;            NotifyDataChanged();&#10;            &#10;            // Force save on score changes to ensure persistence&#10;            SaveData();&#10;        }&#10;&#10;&#10;        public void UpdateCurrentLevel(string levelName)&#10;        {&#10;            CurrentData.currentLevel = levelName;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateBestTime(string levelName, float time)&#10;        {&#10;            var gameData = CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update overall best time&#10;            if (time &lt; gameData.bestTime)&#10;            {&#10;                gameData.bestTime = time;&#10;            }&#10;&#10;            // Update per-level best time&#10;            if (!gameData.LevelBestTimes.ContainsKey(levelName) || time &lt; gameData.LevelBestTimes[levelName])&#10;            {&#10;                gameData.LevelBestTimes[levelName] = time;&#10;            }&#10;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void ResetAllData()&#10;        {&#10;            _repository.DeleteData();&#10;            CurrentData = _repository.LoadData();&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void ResetProgressData()&#10;        {&#10;            // Reset only level-specific progress data, preserve lives, score and fruit count&#10;            CurrentData.currentLevel = &quot;&quot;;&#10;            CurrentData.selectedLevelIndex = 0;&#10;            // Note: Lives, score, maxScore, fruitCollected, unlockedLevels, completedLevels, and best times are preserved&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void SaveData()&#10;        {&#10;            _repository.SaveData(CurrentData);&#10;        }&#10;&#10;        public void AddFruitCollected()&#10;        {&#10;            CurrentData.fruitCollected++;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime)&#10;        {&#10;            var gameData = CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update completed levels list&#10;            if (isCompleted &amp;&amp; !gameData.completedLevels.Contains(levelName))&#10;            {&#10;                gameData.completedLevels.Add(levelName);&#10;            }&#10;&#10;            // Update best time&#10;            if (!gameData.LevelBestTimes.ContainsKey(levelName) || completionTime &lt; gameData.LevelBestTimes[levelName])&#10;            {&#10;                gameData.LevelBestTimes[levelName] = completionTime;&#10;            }&#10;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UnlockLevel(string levelName)&#10;        {&#10;            if (CurrentData != null &amp;&amp; !string.IsNullOrEmpty(levelName) &amp;&amp; !CurrentData.unlockedLevels.Contains(levelName))&#10;            {&#10;                CurrentData.unlockedLevels.Add(levelName);&#10;                Debug.Log($&quot;[GameDataService] Level '{levelName}' unlocked and added to unlocked levels list&quot;);&#10;                NotifyDataChanged();&#10;                SaveData(); &#10;            }&#10;        }&#10;&#10;        public async Task&lt;List&lt;LevelData&gt;&gt; GetLevelDataAsync(ILevelDiscoveryService discoveryService)&#10;        {&#10;            if (CurrentData.levelDataCacheValid &amp;&amp; CurrentData.cachedLevelData.Any())&#10;            {&#10;                // Always re-apply default unlock status in case settings changed&#10;                ApplyDefaultUnlockStatus(CurrentData.cachedLevelData);&#10;                return CurrentData.cachedLevelData;&#10;            }&#10;&#10;            var discoveredLevels = await discoveryService.DiscoverLevelsFromSceneAsync();&#10;            CacheLevelData(discoveredLevels);&#10;            return discoveredLevels;&#10;        }&#10;&#10;        private void CacheLevelData(List&lt;LevelData&gt; levelData)&#10;        {&#10;            CurrentData.cachedLevelData = new List&lt;LevelData&gt;(levelData.OrderBy(l =&gt; l.levelIndex));&#10;            CurrentData.levelDataCacheValid = true;&#10;&#10;            // Apply default unlock status from level data&#10;            ApplyDefaultUnlockStatus(levelData);&#10;&#10;            SaveData();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Apply default unlock status from discovered level data&#10;        /// &lt;/summary&gt;&#10;        private void ApplyDefaultUnlockStatus(List&lt;LevelData&gt; levelData)&#10;        {&#10;            foreach (LevelData level in levelData.Where(level =&gt;&#10;                         level.UnlockedByDefault &amp;&amp; !CurrentData.unlockedLevels.Contains(level.levelName)))&#10;            {&#10;                CurrentData.unlockedLevels.Add(level.levelName);&#10;                Debug.Log($&quot;[GameDataService] Auto-unlocked level: {level.levelName} (UnlockedByDefault = true)&quot;);&#10;            }&#10;        }&#10;&#10;        private void NotifyDataChanged()&#10;        {&#10;            OnDataChanged?.Invoke(CurrentData);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Data/IGameDataService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Data/IGameDataService.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;&#10;namespace Core.Data&#10;{&#10;    public interface IGameDataService&#10;    {&#10;        GameData CurrentData { get; }&#10;        void UpdateLives(int lives);&#10;        void UpdateScore(int score);&#10;        void AddFruitCollected();&#10;        void UpdateBestTime(string levelName, float time);&#10;        void UpdateCurrentLevel(string levelName);&#10;        void UnlockLevel(string levelName);&#10;        void ResetAllData();&#10;        void SaveData();&#10;        event Action&lt;GameData&gt; OnDataChanged;&#10;        &#10;        // Level data operations that should go through GameDataService&#10;        void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime);&#10;        Task&lt;List&lt;LevelData&gt;&gt; GetLevelDataAsync(ILevelDiscoveryService discoveryService);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#13;&#10;using System.Collections.Generic;&#13;&#10;using System.Threading.Tasks;&#13;&#10;using LevelSelection;&#13;&#10;using LevelSelection.Services;&#13;&#10;&#13;&#10;namespace Core.Data&#13;&#10;{&#13;&#10;    public interface IGameDataService&#13;&#10;    {&#13;&#10;        GameData CurrentData { get; }&#13;&#10;        void UpdateLives(int lives);&#13;&#10;        void UpdateScore(int score);&#13;&#10;        void AddFruitCollected();&#13;&#10;        void UpdateBestTime(string levelName, float time);&#13;&#10;        void UpdateCurrentLevel(string levelName);&#13;&#10;        void UnlockLevel(string levelName);&#13;&#10;        void ResetAllData();&#13;&#10;        void SaveData();&#13;&#10;        void ResetProgressData(); // New method for selective reset&#13;&#10;        event Action&lt;GameData&gt; OnDataChanged;&#13;&#10;        &#13;&#10;        // Level data operations that should go through GameDataService&#13;&#10;        void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime);&#13;&#10;        Task&lt;List&lt;LevelData&gt;&gt; GetLevelDataAsync(ILevelDiscoveryService discoveryService);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/GameDataCoordinator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/GameDataCoordinator.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameDataCoordinator : MonoBehaviour&#10;    {&#10;        &#10;#if UNITY_EDITOR&#10;        [Header(&quot;Debug&quot;)]&#10;        [SerializeField] private bool resetGameData;&#10;#endif&#10;        &#10;        private IAutoSaveService _autoSaveService;&#10;        private IEventBus _eventBus;&#10;        private IGameDataService _gameDataService;&#10;        private ILevelDiscoveryService _levelDiscoveryService;&#10;        private bool _isInitialized;&#10;&#10;        // Track previous values to detect changes&#10;        private int _previousLives = -1;&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            IGameDataService gameDataService,&#10;            IEventBus eventBus,&#10;            IAutoSaveService autoSaveService,&#10;            ILevelDiscoveryService levelDiscoveryService)&#10;        {&#10;            _gameDataService = gameDataService;&#10;            _eventBus = eventBus;&#10;            _autoSaveService = autoSaveService;&#10;            _levelDiscoveryService = levelDiscoveryService;&#10;            _isInitialized = true;&#10;&#10;            Initialize();&#10;        }&#10;&#10;        private void Initialize()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;            _eventBus?.Subscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged);&#10;            _eventBus?.Subscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;        }&#10;&#10;#if UNITY_EDITOR&#10;        private void OnValidate()&#10;        {&#10;            if (resetGameData)&#10;            {&#10;                if (_gameDataService != null)&#10;                {&#10;                    _gameDataService.ResetAllData();&#10;                    Debug.Log(&quot;Game data has been reset.&quot;);&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning(&quot;GameDataService not available. Cannot reset game data.&quot;);&#10;                }&#10;                resetGameData = false;&#10;            }&#10;        }&#10;#endif&#10;&#10;        private void SaveData()&#10;        {&#10;            _gameDataService?.SaveData();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.Update();&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;            _eventBus?.Unsubscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged);&#10;            _eventBus?.Unsubscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;&#10;            _autoSaveService?.ForceSave();&#10;        }&#10;&#10;        private void OnApplicationPause(bool pauseStatus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationPause(pauseStatus);&#10;        }&#10;&#10;        private void OnApplicationFocus(bool hasFocus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationFocus(hasFocus);&#10;        }&#10;&#10;        private void OnPlayerDied(PlayerDeathEvent deathEvent)&#10;        {&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateBestTime(levelEvent.LevelName, levelEvent.CompletionTime);&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnGameStateChanged(GameStateChangedEvent stateEvent)&#10;        {&#10;            if (stateEvent.NewState is GameState.Victory or GameState.GameOver)&#10;            {&#10;                _autoSaveService?.ForceSave();&#10;            }&#10;        }&#10;&#10;        private void OnLevelStarted(LevelStartedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateCurrentLevel(levelEvent.LevelName);&#10;        }&#10;&#10;        private void OnGameDataChanged(GameData newData)&#10;        {&#10;            // Check if lives changed and publish the appropriate event&#10;            if (_previousLives != newData.lives)&#10;            {&#10;                _eventBus?.Publish(new PlayerLivesChangedEvent&#10;                {&#10;                    PreviousLives = _previousLives,&#10;                    CurrentLives = newData.lives,&#10;                    MaxLives = GameData.MaxLives,&#10;                    Timestamp = Time.time&#10;                });&#10;&#10;                _previousLives = newData.lives;&#10;            }&#10;&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent levelEvent)&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = levelEvent.LevelIndex;&#10;                gameData.currentLevel = levelEvent.LevelName;&#10;            }&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = navigationEvent.NewIndex;&#10;            }&#10;        }&#10;&#10;        // Public API for other systems to request data operations&#10;        public void UpdateLives(int lives)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateLives(lives);&#10;        }&#10;&#10;        public void UpdateCurrentLevel(string levelName)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateCurrentLevel(levelName);&#10;        }&#10;&#10;        public void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateLevelProgress(levelName, isCompleted, completionTime);&#10;        }&#10;&#10;        public void UpdateScore(int score)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateScore(score);&#10;        }&#10;&#10;        public void AddFruitCollected()&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.AddFruitCollected();&#10;        }&#10;&#10;        public async Task&lt;List&lt;LevelData&gt;&gt; DiscoverLevelsAsync()&#10;        {&#10;            if (!_isInitialized || _gameDataService == null || _levelDiscoveryService == null)&#10;                return new List&lt;LevelData&gt;();&#10;            return await _gameDataService.GetLevelDataAsync(_levelDiscoveryService);&#10;        }&#10;&#10;        public GameData GetCurrentData()&#10;        {&#10;            return !_isInitialized ? null : _gameDataService?.CurrentData;&#10;        }&#10;&#10;        public void ResetAllData()&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.ResetAllData();&#10;        }&#10;&#10;        // Wrapper methods for GameData operations &#10;        public bool IsLevelUnlocked(string levelName)&#10;        {&#10;            return GetCurrentData()?.IsLevelUnlocked(levelName) ?? false;&#10;        }&#10;&#10;        public bool IsLevelCompleted(string levelName)&#10;        {&#10;            return GetCurrentData()?.IsLevelCompleted(levelName) ?? false;&#10;        }&#10;&#10;        public float GetLevelBestTime(string levelName)&#10;        {&#10;            return GetCurrentData()?.GetLevelBestTime(levelName) ?? float.MaxValue;&#10;        }&#10;&#10;        public int GetLevelBestScore(string levelName)&#10;        {&#10;            return GetCurrentData()?.GetLevelBestScore(levelName) ?? 0;&#10;        }&#10;&#10;        // Additional wrapper methods to avoid GetCurrentData() calls&#10;        public int GetCurrentLives()&#10;        {&#10;            return GetCurrentData()?.lives ?? GameData.MaxLives;&#10;        }&#10;&#10;        public List&lt;string&gt; GetUnlockedLevels()&#10;        {&#10;            return GetCurrentData()?.unlockedLevels ?? new List&lt;string&gt; { &quot;Level_01&quot; };&#10;        }&#10;&#10;        public List&lt;string&gt; GetCompletedLevels()&#10;        {&#10;            return GetCurrentData()?.completedLevels ?? new List&lt;string&gt;();&#10;        }&#10;&#10;        public int GetSelectedLevelIndex()&#10;        {&#10;            return GetCurrentData()?.selectedLevelIndex ?? 0;&#10;        }&#10;&#10;        public void UnlockLevel(string levelName)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UnlockLevel(levelName);&#10;        }&#10;&#10;        public int GetCurrentScore()&#10;        {&#10;            return GetCurrentData()?.score ?? 0;&#10;        }&#10;&#10;        public int GetFruitCollectedCount()&#10;        {&#10;            return GetCurrentData()?.fruitCollected ?? 0;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameDataCoordinator : MonoBehaviour&#10;    {&#10;        &#10;#if UNITY_EDITOR&#10;        [Header(&quot;Debug&quot;)]&#10;        [SerializeField] private bool resetGameData;&#10;#endif&#10;        &#10;        private IAutoSaveService _autoSaveService;&#10;        private IEventBus _eventBus;&#10;        private IGameDataService _gameDataService;&#10;        private ILevelDiscoveryService _levelDiscoveryService;&#10;        private bool _isInitialized;&#10;&#10;        // Track previous values to detect changes&#10;        private int _previousLives = -1;&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            IGameDataService gameDataService,&#10;            IEventBus eventBus,&#10;            IAutoSaveService autoSaveService,&#10;            ILevelDiscoveryService levelDiscoveryService)&#10;        {&#10;            _gameDataService = gameDataService;&#10;            _eventBus = eventBus;&#10;            _autoSaveService = autoSaveService;&#10;            _levelDiscoveryService = levelDiscoveryService;&#10;            _isInitialized = true;&#10;&#10;            Initialize();&#10;        }&#10;&#10;        private void Initialize()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;            _eventBus?.Subscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged);&#10;            _eventBus?.Subscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;        }&#10;&#10;#if UNITY_EDITOR&#10;        private void OnValidate()&#10;        {&#10;            if (resetGameData)&#10;            {&#10;                if (_gameDataService != null)&#10;                {&#10;                    _gameDataService.ResetAllData();&#10;                    Debug.Log(&quot;Game data has been reset.&quot;);&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning(&quot;GameDataService not available. Cannot reset game data.&quot;);&#10;                }&#10;                resetGameData = false;&#10;            }&#10;        }&#10;#endif&#10;&#10;        private void SaveData()&#10;        {&#10;            _gameDataService?.SaveData();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.Update();&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;            _eventBus?.Unsubscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged);&#10;            _eventBus?.Unsubscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;&#10;            _autoSaveService?.ForceSave();&#10;        }&#10;&#10;        private void OnApplicationPause(bool pauseStatus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationPause(pauseStatus);&#10;        }&#10;&#10;        private void OnApplicationFocus(bool hasFocus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationFocus(hasFocus);&#10;        }&#10;&#10;        private void OnPlayerDied(PlayerDeathEvent deathEvent)&#10;        {&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateBestTime(levelEvent.LevelName, levelEvent.CompletionTime);&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnGameStateChanged(GameStateChangedEvent stateEvent)&#10;        {&#10;            if (stateEvent.NewState is GameState.Victory or GameState.GameOver)&#10;            {&#10;                _autoSaveService?.ForceSave();&#10;            }&#10;        }&#10;&#10;        private void OnLevelStarted(LevelStartedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateCurrentLevel(levelEvent.LevelName);&#10;        }&#10;&#10;        private void OnGameDataChanged(GameData newData)&#10;        {&#10;            // Check if lives changed and publish the appropriate event&#10;            if (_previousLives != newData.lives)&#10;            {&#10;                _eventBus?.Publish(new PlayerLivesChangedEvent&#10;                {&#10;                    PreviousLives = _previousLives,&#10;                    CurrentLives = newData.lives,&#10;                    MaxLives = GameData.MaxLives,&#10;                    Timestamp = Time.time&#10;                });&#10;&#10;                _previousLives = newData.lives;&#10;            }&#10;&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent levelEvent)&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = levelEvent.LevelIndex;&#10;                gameData.currentLevel = levelEvent.LevelName;&#10;            }&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = navigationEvent.NewIndex;&#10;            }&#10;        }&#10;&#10;        // Public API for other systems to request data operations&#10;        public void UpdateLives(int lives)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateLives(lives);&#10;        }&#10;&#10;        public void UpdateCurrentLevel(string levelName)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateCurrentLevel(levelName);&#10;        }&#10;&#10;        public void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateLevelProgress(levelName, isCompleted, completionTime);&#10;        }&#10;&#10;        public void UpdateScore(int score)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateScore(score);&#10;        }&#10;&#10;        public void AddFruitCollected()&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.AddFruitCollected();&#10;        }&#10;&#10;        public async Task&lt;List&lt;LevelData&gt;&gt; DiscoverLevelsAsync()&#10;        {&#10;            if (!_isInitialized || _gameDataService == null || _levelDiscoveryService == null)&#10;                return new List&lt;LevelData&gt;();&#10;            return await _gameDataService.GetLevelDataAsync(_levelDiscoveryService);&#10;        }&#10;&#10;        public GameData GetCurrentData()&#10;        {&#10;            return !_isInitialized ? null : _gameDataService?.CurrentData;&#10;        }&#10;&#10;        public void ResetAllData()&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.ResetAllData();&#10;        }&#10;&#10;        public void ResetProgressData()&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.ResetProgressData();&#10;        }&#10;&#10;        // Wrapper methods for GameData operations &#10;        public bool IsLevelUnlocked(string levelName)&#10;        {&#10;            return GetCurrentData()?.IsLevelUnlocked(levelName) ?? false;&#10;        }&#10;&#10;        public bool IsLevelCompleted(string levelName)&#10;        {&#10;            return GetCurrentData()?.IsLevelCompleted(levelName) ?? false;&#10;        }&#10;&#10;        public float GetLevelBestTime(string levelName)&#10;        {&#10;            return GetCurrentData()?.GetLevelBestTime(levelName) ?? float.MaxValue;&#10;        }&#10;&#10;        public int GetLevelBestScore(string levelName)&#10;        {&#10;            return GetCurrentData()?.GetLevelBestScore(levelName) ?? 0;&#10;        }&#10;&#10;        // Additional wrapper methods to avoid GetCurrentData() calls&#10;        public int GetCurrentLives()&#10;        {&#10;            return GetCurrentData()?.lives ?? GameData.MaxLives;&#10;        }&#10;&#10;        public List&lt;string&gt; GetUnlockedLevels()&#10;        {&#10;            return GetCurrentData()?.unlockedLevels ?? new List&lt;string&gt; { &quot;Level_01&quot; };&#10;        }&#10;&#10;        public List&lt;string&gt; GetCompletedLevels()&#10;        {&#10;            return GetCurrentData()?.completedLevels ?? new List&lt;string&gt;();&#10;        }&#10;&#10;        public int GetSelectedLevelIndex()&#10;        {&#10;            return GetCurrentData()?.selectedLevelIndex ?? 0;&#10;        }&#10;&#10;        public void UnlockLevel(string levelName)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UnlockLevel(levelName);&#10;        }&#10;&#10;        public int GetCurrentScore()&#10;        {&#10;            return GetCurrentData()?.score ?? 0;&#10;        }&#10;&#10;        public int GetFruitCollectedCount()&#10;        {&#10;            return GetCurrentData()?.fruitCollected ?? 0;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/GameFlowManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/GameFlowManager.cs" />
              <option name="originalContent" value="using System;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using EasyTransition;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameFlowManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Game Settings&quot;)]&#10;        [SerializeField] private float restartDelay = 2f;&#10;        &#10;        [Header(&quot;Victory Settings&quot;)]&#10;        [SerializeField] private string victorySceneName = &quot;YouWonScene&quot;;&#10;        [SerializeField] private float victoryTransitionDelay = 3f;&#10;        &#10;        private string _currentLevelName = &quot;Unknown&quot;;&#10;        private float _levelStartTime;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private ISceneLoadService _sceneLoadService;&#10;&#10;        private GameState CurrentState { get; set; } = GameState.MainMenu;&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, GameDataCoordinator gameDataCoordinator, ISceneLoadService sceneLoadService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            _sceneLoadService = sceneLoadService;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            _currentLevelName = GetCurrentLevelName();&#10;            &#10;            // Only auto-start gameplay in actual level scenes&#10;            // Other scenes (Level Select, Start Menu, etc.) will manage their own states&#10;            if (ShouldAutoStartGameplay())&#10;            {&#10;                StartGameplay();&#10;            }&#10;        }&#10;&#10;        private static bool ShouldAutoStartGameplay()&#10;        {&#10;            // Only auto-start gameplay in actual level scenes&#10;            string sceneName = SceneManager.GetActiveScene().name;&#10;            return !sceneName.Equals(&quot;Level Select&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; &#10;                   !sceneName.Contains(&quot;Start&quot;) &amp;&amp;&#10;                   !sceneName.Equals(&quot;YouWonScene&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            UnsubscribeFromEvents();&#10;        }&#10;&#10;        private void StartGameplay()&#10;        {&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = _currentLevelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void StartLevel(string levelName)&#10;        {&#10;            _currentLevelName = levelName;&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = levelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void PauseGame()&#10;        {&#10;            if (CurrentState == GameState.Playing)&#10;                ChangeState(GameState.Paused);&#10;        }&#10;&#10;        public void ResumeGame()&#10;        {&#10;            if (CurrentState == GameState.Paused)&#10;                ChangeState(GameState.Playing);&#10;        }&#10;&#10;        public void RestartLevel()&#10;        {&#10;            string currentSceneName = SceneManager.GetActiveScene().name;&#10;            _sceneLoadService?.LoadLevel(currentSceneName);&#10;        }&#10;&#10;        public void HandlePlayerDeath(Vector3 deathPosition)&#10;        {&#10;            _eventBus?.Publish(new PlayerDeathEvent&#10;            {&#10;                DeathPosition = deathPosition,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void CompleteLevel(string currentLevelName)&#10;        {&#10;            float completionTime = Time.time - _levelStartTime;&#10;            &#10;            _eventBus?.Publish(new LevelCompletedEvent&#10;            {&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void RequestLevelLoad(string levelName, string sceneName)&#10;        {&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                SceneName = sceneName&#10;            });&#10;        }&#10;&#10;        public void SelectLevel(string levelName, int levelIndex)&#10;        {&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                LevelIndex = levelIndex&#10;            });&#10;        }&#10;&#10;        public void NavigateLevel(int previousIndex, int newIndex, Vector2 direction)&#10;        {&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = newIndex,&#10;                Direction = direction&#10;            });&#10;        }&#10;&#10;        public void NavigateToLevelSelection()&#10;        {&#10;            try&#10;            {&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to navigate to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void OnGameOver(GameOverEvent gameOverEvent)&#10;        {&#10;            ChangeState(GameState.GameOver);&#10;            RestartLevelAfterDelayAsync(restartDelay);&#10;        }&#10;&#10;        private async void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            ChangeState(GameState.Victory);&#10;&#10;            // First, check if the level was already completed&#10;            bool wasAlreadyCompleted = _gameDataCoordinator.IsLevelCompleted(levelEvent.LevelName);&#10;&#10;            // Now, update the progress (marks as complete, updates best time, etc.)&#10;            _gameDataCoordinator.UpdateLevelProgress(levelEvent.LevelName, true, levelEvent.CompletionTime);&#10;&#10;            // If it's the first time completing this level, unlock the next one&#10;            if (!wasAlreadyCompleted)&#10;            {&#10;                await UnlockNextLevelByIndex(levelEvent.LevelName);&#10;            }&#10;&#10;            if (await IsGameCompletedAsync())&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] All levels completed! Transitioning to YouWonScene...&quot;);&#10;                TransitionToVictorySceneAsync();&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] Level {levelEvent.LevelName} completed. Returning to level selection...&quot;);&#10;                ReturnToLevelSelectionAsync();&#10;            }&#10;        }&#10;&#10;        private async Task UnlockNextLevelByIndex(string completedLevelName)&#10;        {&#10;            Debug.Log($&quot;[GameFlowManager] UnlockNextLevelByIndex called for: {completedLevelName}&quot;);&#10;            &#10;            var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            if (allLevels == null || allLevels.Count == 0) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] No levels discovered for unlocking next level&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Found {allLevels.Count} levels total&quot;);&#10;            &#10;            var completedLevel = allLevels.FirstOrDefault(l =&gt; l.levelName == completedLevelName);&#10;            if (completedLevel == null) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] Could not find completed level: {completedLevelName}&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Completed level index: {completedLevel.levelIndex}&quot;);&#10;            int nextLevelIndex = completedLevel.levelIndex + 1;&#10;&#10;            if (nextLevelIndex &lt; allLevels.Count)&#10;            {&#10;                var nextLevel = allLevels.FirstOrDefault(l =&gt; l.levelIndex == nextLevelIndex);&#10;                if (nextLevel != null)&#10;                {&#10;                    bool isAlreadyUnlocked = _gameDataCoordinator.IsLevelUnlocked(nextLevel.levelName);&#10;                    Debug.Log($&quot;[GameFlowManager] Next level '{nextLevel.levelName}' (index {nextLevelIndex}) - Already unlocked: {isAlreadyUnlocked}&quot;);&#10;                    &#10;                    if (!isAlreadyUnlocked)&#10;                    {&#10;                        _gameDataCoordinator.UnlockLevel(nextLevel.levelName);&#10;                        Debug.Log($&quot;[GameFlowManager] Unlocked next level: {nextLevel.levelName}&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        Debug.Log($&quot;[GameFlowManager] Next level {nextLevel.levelName} was already unlocked&quot;);&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;[GameFlowManager] Could not find level with index {nextLevelIndex}&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] No more levels to unlock (completed level was the last one)&quot;);&#10;            }&#10;        }&#10;&#10;        private async Task&lt;bool&gt; IsGameCompletedAsync()&#10;        {&#10;            try&#10;            {&#10;                // Get all available levels through GameDataCoordinator&#10;                var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;                &#10;                if (allLevels == null || allLevels.Count == 0)&#10;                {&#10;                    Debug.LogWarning(&quot;[GameFlowManager] No levels found in discovery service&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Get completed levels using wrapper method&#10;                var completedLevels = _gameDataCoordinator?.GetCompletedLevels();&#10;                if (completedLevels == null) return false;&#10;&#10;                // Check if all levels are in the completed list&#10;                var completedCount = 0;&#10;                foreach (var level in allLevels)&#10;                {&#10;                    if (completedLevels.Contains(level.levelName))&#10;                    {&#10;                        completedCount++;&#10;                    }&#10;                }&#10;                &#10;                Debug.Log($&quot;[GameFlowManager] Game completion check: {completedCount}/{allLevels.Count} levels completed&quot;);&#10;                &#10;                if (completedCount &gt;= allLevels.Count)&#10;                {&#10;                    Debug.Log(&quot;[GameFlowManager] All levels completed!&quot;);&#10;                    return true;&#10;                }&#10;&#10;                var remainingLevels = allLevels.Where(l =&gt; !completedLevels.Contains(l.levelName)).Select(l =&gt; l.levelName);&#10;                Debug.Log($&quot;[GameFlowManager] Remaining levels: {string.Join(&quot;, &quot;, remainingLevels)}&quot;);&#10;                return false;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Error checking game completion: {e}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private async void TransitionToVictorySceneAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(victoryTransitionDelay * 1000));&#10;                &#10;                _eventBus?.Publish(new GameCompletedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    FinalLevelName = _currentLevelName&#10;                });&#10;                &#10;                _sceneLoadService?.LoadLevel(victorySceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to transition to victory scene: {e}&quot;);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;        }&#10;&#10;        private async void ReturnToLevelSelectionAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(2f * 1000));&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to return to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnPlayerLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            bool lostLife = livesEvent.PreviousLives &gt; livesEvent.CurrentLives;&#10;            bool isGameOver = livesEvent.CurrentLives == 0;&#10;&#10;            if (isGameOver)&#10;            {&#10;                ChangeState(GameState.GameOver);&#10;                _gameDataCoordinator?.ResetAllData();&#10;                _eventBus?.Publish(new GameOverEvent { Timestamp = Time.time });&#10;            }&#10;&#10;            if (lostLife)&#10;            {&#10;                _eventBus?.Publish(new PlayerDeathEvent&#10;                {&#10;                    DeathPosition = PlayerLocator.PlayerTransform.position,&#10;                    Timestamp = Time.time&#10;                });&#10;            }&#10;&#10;            if (isGameOver || lostLife)&#10;            {&#10;                Time.timeScale = 0.01f;&#10;                RestartLevelAfterDelayAsync(restartDelay);&#10;            }&#10;        }&#10;&#10;        private async void RestartLevelAfterDelayAsync(float delay)&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(delay * 1000));&#10;                string currentSceneName = SceneManager.GetActiveScene().name;&#10;                _sceneLoadService?.LoadLevel(currentSceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to restart level after delay: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ChangeState(GameState newState)&#10;        {&#10;            if (CurrentState == newState) return;&#10;&#10;            GameState oldState = CurrentState;&#10;            CurrentState = newState;&#10;&#10;            _eventBus?.Publish(new GameStateChangedEvent&#10;            {&#10;                PreviousState = oldState,&#10;                NewState = newState,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private string GetCurrentLevelName() =&gt; SceneManager.GetActiveScene().name;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using EasyTransition;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameFlowManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Game Settings&quot;)]&#10;        [SerializeField] private float restartDelay = 2f;&#10;        &#10;        [Header(&quot;Victory Settings&quot;)]&#10;        [SerializeField] private string victorySceneName = &quot;YouWonScene&quot;;&#10;        [SerializeField] private float victoryTransitionDelay = 3f;&#10;        &#10;        private string _currentLevelName = &quot;Unknown&quot;;&#10;        private float _levelStartTime;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private ISceneLoadService _sceneLoadService;&#10;&#10;        private GameState CurrentState { get; set; } = GameState.MainMenu;&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, GameDataCoordinator gameDataCoordinator, ISceneLoadService sceneLoadService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            _sceneLoadService = sceneLoadService;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            _currentLevelName = GetCurrentLevelName();&#10;            &#10;            // Only auto-start gameplay in actual level scenes&#10;            // Other scenes (Level Select, Start Menu, etc.) will manage their own states&#10;            if (ShouldAutoStartGameplay())&#10;            {&#10;                StartGameplay();&#10;            }&#10;        }&#10;&#10;        private static bool ShouldAutoStartGameplay()&#10;        {&#10;            // Only auto-start gameplay in actual level scenes&#10;            string sceneName = SceneManager.GetActiveScene().name;&#10;            return !sceneName.Equals(&quot;Level Select&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; &#10;                   !sceneName.Contains(&quot;Start&quot;) &amp;&amp;&#10;                   !sceneName.Equals(&quot;YouWonScene&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            UnsubscribeFromEvents();&#10;        }&#10;&#10;        private void StartGameplay()&#10;        {&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = _currentLevelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void StartLevel(string levelName)&#10;        {&#10;            _currentLevelName = levelName;&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = levelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void PauseGame()&#10;        {&#10;            if (CurrentState == GameState.Playing)&#10;                ChangeState(GameState.Paused);&#10;        }&#10;&#10;        public void ResumeGame()&#10;        {&#10;            if (CurrentState == GameState.Paused)&#10;                ChangeState(GameState.Playing);&#10;        }&#10;&#10;        public void RestartLevel()&#10;        {&#10;            string currentSceneName = SceneManager.GetActiveScene().name;&#10;            _sceneLoadService?.LoadLevel(currentSceneName);&#10;        }&#10;&#10;        public void HandlePlayerDeath(Vector3 deathPosition)&#10;        {&#10;            _eventBus?.Publish(new PlayerDeathEvent&#10;            {&#10;                DeathPosition = deathPosition,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void CompleteLevel(string currentLevelName)&#10;        {&#10;            float completionTime = Time.time - _levelStartTime;&#10;            &#10;            _eventBus?.Publish(new LevelCompletedEvent&#10;            {&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void RequestLevelLoad(string levelName, string sceneName)&#10;        {&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                SceneName = sceneName&#10;            });&#10;        }&#10;&#10;        public void SelectLevel(string levelName, int levelIndex)&#10;        {&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                LevelIndex = levelIndex&#10;            });&#10;        }&#10;&#10;        public void NavigateLevel(int previousIndex, int newIndex, Vector2 direction)&#10;        {&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = newIndex,&#10;                Direction = direction&#10;            });&#10;        }&#10;&#10;        public void NavigateToLevelSelection()&#10;        {&#10;            try&#10;            {&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to navigate to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void OnGameOver(GameOverEvent gameOverEvent)&#10;        {&#10;            ChangeState(GameState.GameOver);&#10;            RestartLevelAfterDelayAsync(restartDelay);&#10;        }&#10;&#10;        private async void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            ChangeState(GameState.Victory);&#10;&#10;            // First, check if the level was already completed&#10;            bool wasAlreadyCompleted = _gameDataCoordinator.IsLevelCompleted(levelEvent.LevelName);&#10;&#10;            // Now, update the progress (marks as complete, updates best time, etc.)&#10;            _gameDataCoordinator.UpdateLevelProgress(levelEvent.LevelName, true, levelEvent.CompletionTime);&#10;&#10;            // If it's the first time completing this level, unlock the next one&#10;            if (!wasAlreadyCompleted)&#10;            {&#10;                await UnlockNextLevelByIndex(levelEvent.LevelName);&#10;            }&#10;&#10;            if (await IsGameCompletedAsync())&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] All levels completed! Transitioning to YouWonScene...&quot;);&#10;                TransitionToVictorySceneAsync();&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] Level {levelEvent.LevelName} completed. Returning to level selection...&quot;);&#10;                ReturnToLevelSelectionAsync();&#10;            }&#10;        }&#10;&#10;        private async Task UnlockNextLevelByIndex(string completedLevelName)&#10;        {&#10;            Debug.Log($&quot;[GameFlowManager] UnlockNextLevelByIndex called for: {completedLevelName}&quot;);&#10;            &#10;            var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            if (allLevels == null || allLevels.Count == 0) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] No levels discovered for unlocking next level&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Found {allLevels.Count} levels total&quot;);&#10;            &#10;            var completedLevel = allLevels.FirstOrDefault(l =&gt; l.levelName == completedLevelName);&#10;            if (completedLevel == null) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] Could not find completed level: {completedLevelName}&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Completed level index: {completedLevel.levelIndex}&quot;);&#10;            int nextLevelIndex = completedLevel.levelIndex + 1;&#10;&#10;            if (nextLevelIndex &lt; allLevels.Count)&#10;            {&#10;                var nextLevel = allLevels.FirstOrDefault(l =&gt; l.levelIndex == nextLevelIndex);&#10;                if (nextLevel != null)&#10;                {&#10;                    bool isAlreadyUnlocked = _gameDataCoordinator.IsLevelUnlocked(nextLevel.levelName);&#10;                    Debug.Log($&quot;[GameFlowManager] Next level '{nextLevel.levelName}' (index {nextLevelIndex}) - Already unlocked: {isAlreadyUnlocked}&quot;);&#10;                    &#10;                    if (!isAlreadyUnlocked)&#10;                    {&#10;                        _gameDataCoordinator.UnlockLevel(nextLevel.levelName);&#10;                        Debug.Log($&quot;[GameFlowManager] Unlocked next level: {nextLevel.levelName}&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        Debug.Log($&quot;[GameFlowManager] Next level {nextLevel.levelName} was already unlocked&quot;);&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;[GameFlowManager] Could not find level with index {nextLevelIndex}&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] No more levels to unlock (completed level was the last one)&quot;);&#10;            }&#10;        }&#10;&#10;        private async Task&lt;bool&gt; IsGameCompletedAsync()&#10;        {&#10;            try&#10;            {&#10;                // Get all available levels through GameDataCoordinator&#10;                var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;                &#10;                if (allLevels == null || allLevels.Count == 0)&#10;                {&#10;                    Debug.LogWarning(&quot;[GameFlowManager] No levels found in discovery service&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Get completed levels using wrapper method&#10;                var completedLevels = _gameDataCoordinator?.GetCompletedLevels();&#10;                if (completedLevels == null) return false;&#10;&#10;                // Check if all levels are in the completed list&#10;                var completedCount = 0;&#10;                foreach (var level in allLevels)&#10;                {&#10;                    if (completedLevels.Contains(level.levelName))&#10;                    {&#10;                        completedCount++;&#10;                    }&#10;                }&#10;                &#10;                Debug.Log($&quot;[GameFlowManager] Game completion check: {completedCount}/{allLevels.Count} levels completed&quot;);&#10;                &#10;                if (completedCount &gt;= allLevels.Count)&#10;                {&#10;                    Debug.Log(&quot;[GameFlowManager] All levels completed!&quot;);&#10;                    return true;&#10;                }&#10;&#10;                var remainingLevels = allLevels.Where(l =&gt; !completedLevels.Contains(l.levelName)).Select(l =&gt; l.levelName);&#10;                Debug.Log($&quot;[GameFlowManager] Remaining levels: {string.Join(&quot;, &quot;, remainingLevels)}&quot;);&#10;                return false;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Error checking game completion: {e}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private async void TransitionToVictorySceneAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(victoryTransitionDelay * 1000));&#10;                &#10;                _eventBus?.Publish(new GameCompletedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    FinalLevelName = _currentLevelName&#10;                });&#10;                &#10;                _sceneLoadService?.LoadLevel(victorySceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to transition to victory scene: {e}&quot;);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;        }&#10;&#10;        private async void ReturnToLevelSelectionAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(2f * 1000));&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to return to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnPlayerLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            bool lostLife = livesEvent.PreviousLives &gt; livesEvent.CurrentLives;&#10;            bool isGameOver = livesEvent.CurrentLives == 0;&#10;&#10;            if (isGameOver)&#10;            {&#10;                ChangeState(GameState.GameOver);&#10;                // Use selective reset to preserve score and level progress&#10;                _gameDataCoordinator?.ResetProgressData();&#10;                _eventBus?.Publish(new GameOverEvent { Timestamp = Time.time });&#10;            }&#10;&#10;            if (lostLife)&#10;            {&#10;                _eventBus?.Publish(new PlayerDeathEvent&#10;                {&#10;                    DeathPosition = PlayerLocator.PlayerTransform.position,&#10;                    Timestamp = Time.time&#10;                });&#10;            }&#10;&#10;            if (isGameOver || lostLife)&#10;            {&#10;                Time.timeScale = 0.01f;&#10;                RestartLevelAfterDelayAsync(restartDelay);&#10;            }&#10;        }&#10;&#10;        private async void RestartLevelAfterDelayAsync(float delay)&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(delay * 1000));&#10;                string currentSceneName = SceneManager.GetActiveScene().name;&#10;                _sceneLoadService?.LoadLevel(currentSceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to restart level after delay: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ChangeState(GameState newState)&#10;        {&#10;            if (CurrentState == newState) return;&#10;&#10;            GameState oldState = CurrentState;&#10;            CurrentState = newState;&#10;&#10;            _eventBus?.Publish(new GameStateChangedEvent&#10;            {&#10;                PreviousState = oldState,&#10;                NewState = newState,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private string GetCurrentLevelName() =&gt; SceneManager.GetActiveScene().name;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Services/AudioManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Services/AudioManager.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionController.cs" />
              <option name="originalContent" value="using System.Threading.Tasks;&#10;using Core;&#10;using Core.Data;&#10;using Core;&#10;using EasyTransition;&#10;using GameFlow;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionController : MonoBehaviour&#10;        [Header(&quot;Configuration&quot;)] [SerializeField]&#10;        private bool autoActivateOnStart = true;&#10;&#10;        [Header(&quot;UI Components&quot;)] [SerializeField]&#10;        private GameObject selectorObject;&#10;&#10;        [SerializeField] private ItemSelectScreen itemSelectScreen;&#10;&#10;        [Header(&quot;Input Actions&quot;)] [SerializeField]&#10;        private InputActionReference navigateAction;&#10;&#10;        [Header(&quot;Input&quot;)]&#10;        [SerializeField] private SoundData lockedSound;&#10;        private IAudioFeedbackService _audioFeedbackService;&#10;        private IAudioService _audioService;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private GameFlowManager _gameFlowManager;&#10;        private IInputFilterService _inputFilterService;&#10;        private IItemSelectService _itemSelectService;&#10;        private ILevelNavigationService _navigationService;&#10;        private ISceneLoadService _sceneLoadService;&#10;        private ISelectorService _selectorService;&#10;&#10;        public bool IsActive { get; private set; }&#10;&#10;        private async void Start()&#10;        {&#10;            await InitializeAsync();&#10;&#10;            if (autoActivateOnStart)&#10;            {&#10;                Activate();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            _selectorService?.Update();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.Enable();&#10;                navigateAction.action.performed += OnNavigate;&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnSubmit;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.performed -= OnNavigate;&#10;                navigateAction.action.Disable();&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.performed -= OnSubmit;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            ILevelNavigationService navigationService,&#10;            IEventBus eventBus,&#10;            ISelectorService selectorService,&#10;            IAudioFeedbackService audioFeedbackService,&#10;            IAudioService audioService,&#10;            IItemSelectService itemSelectService,&#10;            ISceneLoadService sceneLoadService,&#10;            GameFlowManager gameFlowManager,&#10;            GameDataCoordinator gameDataCoordinator)&#10;        {&#10;            _navigationService = navigationService;&#10;            _eventBus = eventBus;&#10;            _selectorService = selectorService;&#10;            _audioFeedbackService = audioFeedbackService;&#10;            _audioService = audioService;&#10;            _itemSelectService = itemSelectService;&#10;            _sceneLoadService = sceneLoadService;&#10;            _gameFlowManager = gameFlowManager;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private async Task InitializeAsync()&#10;        {&#10;            InitializeServices();&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                _gameFlowManager.PauseGame();&#10;            }&#10;&#10;            var levelData = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            await _navigationService.InitializeAsync(levelData);&#10;&#10;            // Configure navigation service with grid width (hardcoded since config removed)&#10;            _navigationService.SetGridWidth(4); // Default grid width&#10;        }&#10;&#10;        private void InitializeServices()&#10;            AudioSource audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (audioSource == null)&#10;            {&#10;                audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;&#10;        {&#10;            _selectorService.Initialize(selectorObject);&#10;            _audioFeedbackService.Initialize(audioSource);&#10;            _inputFilterService.Initialize();&#10;            _itemSelectService.Initialize(itemSelectScreen, _sceneLoadService);&#10;&#10;            _itemSelectService.OnStateChanged += OnItemSelectStateChanged;&#10;&#10;        &#10;        private void OnItemSelectStateChanged(bool isActive)&#10;        {&#10;            _selectorService.SetVisible(!isActive);&#10;            _inputFilterService.SetEnabled(!isActive);&#10;        }&#10;&#10;        private void OnNavigate(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;&#10;            Vector2 direction = context.ReadValue&lt;Vector2&gt;();&#10;&#10;            if (_inputFilterService.ProcessNavigationInput(direction, out Vector2 filteredDirection))&#10;            {&#10;                _navigationService.NavigateInDirection(filteredDirection);&#10;            }&#10;        }&#10;&#10;        private void OnSubmit(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;   &#10;            _navigationService.SelectCurrentLevel();&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            _selectorService.MoveToCurrentLevel(_navigationService);&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent selectionEvent)&#10;        {&#10;            LevelData levelData = _navigationService.CurrentLevel;&#10;            bool isUnlocked = _gameDataCoordinator?.IsLevelUnlocked(levelData?.levelName) ?? false;&#10;            &#10;            if (levelData != null &amp;&amp; !isUnlocked)&#10;                _audioFeedbackService.PlayLockedSound();&#10;                PlayLockedSound();&#10;                return;&#10;            }&#10;            _audioFeedbackService.PlaySelectionSound();&#10;            PlaySelectionSound();&#10;&#10;            string sceneName = _sceneLoadService.GetSceneNameForLevel(levelData);&#10;            _itemSelectService.ShowItemSelect(selectionEvent.LevelName, sceneName);&#10;        }&#10;&#10;        private void OnLevelLoadRequested(LevelLoadRequestedEvent loadEvent)&#10;        {&#10;            _gameDataCoordinator?.UpdateCurrentLevel(loadEvent.LevelName);&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                // Use StartLevel with the correct level name when loading from level selection&#10;                _gameFlowManager.StartLevel(loadEvent.LevelName);&#10;            }&#10;&#10;            _sceneLoadService.LoadLevel(loadEvent.SceneName);&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            IsActive = true;&#10;            _navigationService?.Activate();&#10;&#10;            if (_navigationService?.CurrentIndex &gt;= 0)&#10;            {&#10;                _selectorService?.MoveToCurrentLevel(_navigationService);&#10;            }&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            IsActive = false;&#10;            _navigationService?.Deactivate();&#10;        }&#10;&#10;        public void SetCurrentLevel(int levelIndex)&#10;        {&#10;            _navigationService?.SetCurrentIndex(levelIndex);&#10;    }&#10;}&#10;        }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Threading.Tasks;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using Core;&#10;using Core.Events;&#10;using Data.Coordinator;&#10;using GameFlow;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Controls level selection functionality using the new SOLID audio system directly&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Configuration&quot;)]&#10;        [SerializeField] private bool autoActivateOnStart = true;&#10;        &#10;        [Header(&quot;UI References&quot;)]&#10;        [SerializeField] private GameObject selectorObject;&#10;        [SerializeField] private GameObject itemSelectScreen;&#10;        &#10;        [Header(&quot;Input&quot;)]&#10;        [SerializeField] private InputActionReference navigateAction;&#10;        [SerializeField] private InputActionReference submitAction;&#10;        &#10;        [Header(&quot;Audio&quot;)]&#10;        [SerializeField] private SoundData selectionSound;&#10;        [SerializeField] private SoundData lockedSound;&#10;&#10;        private IAudioService _audioService;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private GameFlowManager _gameFlowManager;&#10;        private IInputFilterService _inputFilterService;&#10;        private IItemSelectService _itemSelectService;&#10;        private ILevelNavigationService _navigationService;&#10;        private ISceneLoadService _sceneLoadService;&#10;        private ISelectorService _selectorService;&#10;&#10;        public bool IsActive { get; private set; }&#10;&#10;        private async void Start()&#10;        {&#10;            await InitializeAsync();&#10;&#10;            if (autoActivateOnStart)&#10;            {&#10;                Activate();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            _selectorService?.Update();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.Enable();&#10;                navigateAction.action.performed += OnNavigate;&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnSubmit;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.performed -= OnNavigate;&#10;                navigateAction.action.Disable();&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.performed -= OnSubmit;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            ILevelNavigationService navigationService,&#10;            IEventBus eventBus,&#10;            ISelectorService selectorService,&#10;            IInputFilterService inputFilterService,&#10;            IAudioService audioService,&#10;            IItemSelectService itemSelectService,&#10;            ISceneLoadService sceneLoadService,&#10;            GameFlowManager gameFlowManager,&#10;            GameDataCoordinator gameDataCoordinator)&#10;        {&#10;            _navigationService = navigationService;&#10;            _eventBus = eventBus;&#10;            _selectorService = selectorService;&#10;            _inputFilterService = inputFilterService;&#10;            _audioService = audioService;&#10;            _itemSelectService = itemSelectService;&#10;            _sceneLoadService = sceneLoadService;&#10;            _gameFlowManager = gameFlowManager;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private async Task InitializeAsync()&#10;        {&#10;            InitializeServices();&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                _gameFlowManager.PauseGame();&#10;            }&#10;&#10;            var levelData = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            await _navigationService.InitializeAsync(levelData);&#10;&#10;            // Configure navigation service with grid width (hardcoded since config removed)&#10;            _navigationService.SetGridWidth(4); // Default grid width&#10;        }&#10;&#10;        private void InitializeServices()&#10;        {&#10;            _selectorService.Initialize(selectorObject);&#10;            _inputFilterService.Initialize();&#10;            _itemSelectService.Initialize(itemSelectScreen, _sceneLoadService);&#10;&#10;            _itemSelectService.OnStateChanged += OnItemSelectStateChanged;&#10;        }&#10;        &#10;        private void OnItemSelectStateChanged(bool isActive)&#10;        {&#10;            _selectorService.SetVisible(!isActive);&#10;            _inputFilterService.SetEnabled(!isActive);&#10;        }&#10;&#10;        private void OnNavigate(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;&#10;            Vector2 direction = context.ReadValue&lt;Vector2&gt;();&#10;&#10;            if (_inputFilterService.ProcessNavigationInput(direction, out Vector2 filteredDirection))&#10;            {&#10;                _navigationService.NavigateInDirection(filteredDirection);&#10;            }&#10;        }&#10;&#10;        private void OnSubmit(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;   &#10;            _navigationService.SelectCurrentLevel();&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            _selectorService.MoveToCurrentLevel(_navigationService);&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent selectionEvent)&#10;        {&#10;            LevelData levelData = _navigationService.CurrentLevel;&#10;            bool isUnlocked = _gameDataCoordinator?.IsLevelUnlocked(levelData?.levelName) ?? false;&#10;            &#10;            if (levelData != null &amp;&amp; !isUnlocked)&#10;            {&#10;                PlayLockedSound();&#10;                return;&#10;            }&#10;&#10;            PlaySelectionSound();&#10;&#10;            string sceneName = _sceneLoadService.GetSceneNameForLevel(levelData);&#10;            _itemSelectService.ShowItemSelect(selectionEvent.LevelName, sceneName);&#10;        }&#10;&#10;        private void OnLevelLoadRequested(LevelLoadRequestedEvent loadEvent)&#10;        {&#10;            _gameDataCoordinator?.UpdateCurrentLevel(loadEvent.LevelName);&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                // Use StartLevel with the correct level name when loading from level selection&#10;                _gameFlowManager.StartLevel(loadEvent.LevelName);&#10;            }&#10;&#10;            _sceneLoadService.LoadLevel(loadEvent.SceneName);&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            IsActive = true;&#10;            _navigationService?.Activate();&#10;&#10;            if (_navigationService?.CurrentIndex &gt;= 0)&#10;            {&#10;                _selectorService?.MoveToCurrentLevel(_navigationService);&#10;            }&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            IsActive = false;&#10;            _navigationService?.Deactivate();&#10;        }&#10;&#10;        public void SetCurrentLevel(int levelIndex)&#10;        {&#10;            _navigationService?.SetCurrentIndex(levelIndex);&#10;        }&#10;&#10;        private void PlaySelectionSound()&#10;        {&#10;            if (selectionSound?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(&#10;                    selectionSound.clip,&#10;                    selectionSound.GetRandomizedVolume(),&#10;                    selectionSound.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;&#10;        private void PlayLockedSound()&#10;        {&#10;            if (lockedSound?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(&#10;                    lockedSound.clip,&#10;                    lockedSound.GetRandomizedVolume(),&#10;                    lockedSound.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/AudioFeedbackService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/AudioFeedbackService.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Handles audio feedback for level selection events (Single Responsibility)&#10;    /// &lt;/summary&gt;&#10;    public class AudioFeedbackService : IAudioFeedbackService&#10;    {&#10;        private AudioSource _audioSource;&#10;&#10;        public void Initialize(AudioSource audioSource)&#10;        {&#10;            _audioSource = audioSource;&#10;        }&#10;&#10;&#10;        public void PlaySelectionSound()&#10;        {&#10;            if (_audioSource)&#10;            {&#10;                _audioSource.PlayOneShot(_audioSource.clip);&#10;            }&#10;        }&#10;&#10;        public void PlayLockedSound()&#10;        {&#10;            if (_audioSource)&#10;            {&#10;                _audioSource.PlayOneShot(_audioSource.clip);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Audio.Data;&#10;using Audio.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Handles audio feedback for level selection events using the new SOLID audio system&#10;    /// &lt;/summary&gt;&#10;    public class AudioFeedbackService : IAudioFeedbackService&#10;    {&#10;        [SerializeField] private SoundData selectionSound;&#10;        [SerializeField] private SoundData lockedSound;&#10;        &#10;        private IAudioService _audioService;&#10;        &#10;        [Inject]&#10;        public void Construct(IAudioService audioService)&#10;        {&#10;            _audioService = audioService;&#10;        }&#10;&#10;        public void Initialize(AudioSource audioSource)&#10;        {&#10;            // No longer needed with the new system, but kept for interface compatibility&#10;        }&#10;&#10;        public void SetSounds(SoundData selectionSound, SoundData lockedSound)&#10;        {&#10;            this.selectionSound = selectionSound;&#10;            this.lockedSound = lockedSound;&#10;        }&#10;&#10;        public void PlaySelectionSound()&#10;        {&#10;            if (selectionSound?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(&#10;                    selectionSound.clip,&#10;                    selectionSound.GetRandomizedVolume(),&#10;                    selectionSound.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;&#10;        public void PlayLockedSound()&#10;        {&#10;            if (lockedSound?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(&#10;                    lockedSound.clip,&#10;                    lockedSound.GetRandomizedVolume(),&#10;                    lockedSound.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/IAudioFeedbackService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/IAudioFeedbackService.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for audio feedback during level selection&#10;    /// &lt;/summary&gt;&#10;    public interface IAudioFeedbackService&#10;    {&#10;        void Initialize(AudioSource audioSource);&#10;        void PlaySelectionSound();&#10;        void PlayLockedSound();&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="using Audio.Data;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for audio feedback during level selection&#10;    ///     Updated to work with the new SOLID audio system&#10;    /// &lt;/summary&gt;&#10;    public interface IAudioFeedbackService&#10;    {&#10;        void Initialize(AudioSource audioSource);&#10;        void SetSounds(SoundData selectionSound, SoundData lockedSound);&#10;        void PlaySelectionSound();&#10;        void PlayLockedSound();&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerSoundController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerSoundController.cs" />
              <option name="originalContent" value="using System;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using Core.Events;&#10;using Collectables.Score;&#10;using Health.Interfaces;&#10;using ModularCharacterController.Core;&#10;using ModularCharacterController.Core.Components;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Unified player audio controller that handles both sound events and audio playback&#10;    /// Combines event subscription logic with SOLID audio system integration&#10;    /// &lt;/summary&gt;&#10;    public class PlayerSoundController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Player Sound Events&quot;)]&#10;        [SerializeField] private SoundData jumpSound;&#10;        [SerializeField] private SoundData collectSound;&#10;        [SerializeField] private SoundData deathSound;&#10;        [SerializeField] private SoundData damageSound;&#10;        &#10;        private IAudioService _audioService;&#10;        private IHealthEvents _health;&#10;        private InputHandler _inputHandler;&#10;        private MccGroundCheck _groundCheck;&#10;        &#10;        [Inject]&#10;        public void Construct(IAudioService audioService)&#10;        {&#10;            _audioService = audioService;&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            _health = GetComponent&lt;IHealthEvents&gt;();&#10;            _inputHandler = GetComponent&lt;InputHandler&gt;();&#10;            _groundCheck = GetComponent&lt;MccGroundCheck&gt;();&#10;        }&#10;        &#10;        private void OnEnable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected += OnScoreCollected;&#10;            &#10;            if (_health != null)&#10;            {&#10;                _health.OnDeath += OnDeath;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected -= OnScoreCollected;&#10;            &#10;            if (_health != null)&#10;            {&#10;                _health.OnDeath -= OnDeath;&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            InputContext input = _inputHandler.CurrentInput;&#10;            if (input.JumpPressed &amp;&amp; _groundCheck.IsGrounded)&#10;            {&#10;                PlayJumpSound();&#10;            }&#10;        }&#10;        &#10;        #region Event Handlers&#10;        &#10;        private void OnScoreCollected(int score, Vector3 position)&#10;        {&#10;            PlayCollectSoundAtPosition(position);&#10;        }&#10;&#10;        private void OnDeath()&#10;        {&#10;            PlayDeathSound();&#10;        }&#10;        &#10;        &#10;        #endregion&#10;        &#10;        #region Public Audio Methods&#10;        &#10;        public void PlayJumpSound()&#10;        {&#10;            PlaySoundData(jumpSound);&#10;        }&#10;        &#10;        public void PlayCollectSound()&#10;        {&#10;            PlaySoundData(collectSound);&#10;        }&#10;&#10;        private void PlayDeathSound()&#10;        {&#10;            PlaySoundData(deathSound);&#10;        }&#10;        &#10;        public void PlayDamageSound()&#10;        {&#10;            PlaySoundData(damageSound);&#10;        }&#10;        &#10;        public void PlayCollectSoundAtPosition(Vector3 position)&#10;        {&#10;            PlaySoundData(collectSound, position);&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Private Audio Helpers&#10;        &#10;        private void PlaySoundData(SoundData soundData)&#10;        {&#10;            if (soundData?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(&#10;                    soundData.clip, &#10;                    soundData.GetRandomizedVolume(), &#10;                    soundData.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;        &#10;        private void PlaySoundDataAtPosition(SoundData soundData, Vector3 position)&#10;        {&#10;            if (soundData?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySoundAtPosition(&#10;                    soundData.clip, &#10;                    position,&#10;                    soundData.GetRandomizedVolume(), &#10;                    soundData.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using Core.Events;&#10;using Collectables.Score;&#10;using Health.Interfaces;&#10;using ModularCharacterController.Core;&#10;using ModularCharacterController.Core.Components;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Unified player audio controller that handles both sound events and audio playback&#10;    /// Combines event subscription logic with SOLID audio system integration&#10;    /// &lt;/summary&gt;&#10;    public class PlayerSoundController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Player Sound Events&quot;)]&#10;        [SerializeField] private SoundData jumpSound;&#10;        [SerializeField] private SoundData collectSound;&#10;        [SerializeField] private SoundData deathSound;&#10;        &#10;        private IAudioService _audioService;&#10;        private IHealthEvents _health;&#10;        private InputHandler _inputHandler;&#10;        private MccGroundCheck _groundCheck;&#10;        &#10;        [Inject]&#10;        public void Construct(IAudioService audioService)&#10;        {&#10;            _audioService = audioService;&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            _health = GetComponent&lt;IHealthEvents&gt;();&#10;            _inputHandler = GetComponent&lt;InputHandler&gt;();&#10;            _groundCheck = GetComponent&lt;MccGroundCheck&gt;();&#10;        }&#10;        &#10;        private void OnEnable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected += OnScoreCollected;&#10;            &#10;            if (_health != null)&#10;            {&#10;                _health.OnDeath += OnDeath;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected -= OnScoreCollected;&#10;            &#10;            if (_health != null)&#10;            {&#10;                _health.OnDeath -= OnDeath;&#10;            }&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            InputContext input = _inputHandler.CurrentInput;&#10;            if (input.JumpPressed &amp;&amp; _groundCheck.IsGrounded)&#10;            {&#10;                PlayJumpSound();&#10;            }&#10;        }&#10;        &#10;        #region Event Handlers&#10;        &#10;        private void OnScoreCollected(int score, Vector3 position)&#10;        {&#10;            PlayCollectSoundAtPosition(position);&#10;        }&#10;&#10;        private void OnDeath()&#10;        {&#10;            PlayDeathSound();&#10;        }&#10;        &#10;        &#10;        #endregion&#10;        &#10;        #region Public Audio Methods&#10;        &#10;        public void PlayJumpSound()&#10;        {&#10;            PlaySoundData(jumpSound);&#10;        }&#10;        &#10;        public void PlayCollectSound()&#10;        {&#10;            PlaySoundData(collectSound);&#10;        }&#10;&#10;        private void PlayDeathSound()&#10;        {&#10;            PlaySoundData(deathSound);&#10;        }&#10;        &#10;        public void PlayCollectSoundAtPosition(Vector3 position)&#10;        {&#10;            PlaySoundDataAtPosition(collectSound, position);&#10;        }&#10;        &#10;        #endregion&#10;        &#10;        #region Private Audio Helpers&#10;        &#10;        private void PlaySoundData(SoundData soundData)&#10;        {&#10;            if (soundData?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(&#10;                    soundData.clip, &#10;                    soundData.GetRandomizedVolume(), &#10;                    soundData.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;        &#10;        private void PlaySoundDataAtPosition(SoundData soundData, Vector3 position)&#10;        {&#10;            if (soundData?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySoundAtPosition(&#10;                    soundData.clip, &#10;                    position,&#10;                    soundData.GetRandomizedVolume(), &#10;                    soundData.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;        &#10;        #endregion&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Services/HealthBonusService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Services/HealthBonusService.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections;&#10;using Collectables.Score;&#10;using Health.Interfaces;&#10;using Player.Components;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Service responsible for calculating and awarding bonus points based on remaining health&#10;    /// &lt;/summary&gt;&#10;    public class HealthBonusService : MonoBehaviour&#10;    {&#10;        [Header(&quot;Bonus Settings&quot;)]&#10;        [SerializeField] private int pointsPerHp = 100;&#10;        [SerializeField] private float drainDelay = 0.2f;&#10;        [SerializeField] private float drainInterval = 0.1f;&#10;        &#10;        [Header(&quot;Audio&quot;)]&#10;        [SerializeField] private AudioClip bonusDrainSfx;&#10;        &#10;        private IScoreService _scoreService;&#10;        private PlayerHealthController _healthController;&#10;        private IHealthView _healthView;&#10;        private AudioSource _audioSource;&#10;        &#10;        [Inject]&#10;        public void Construct(IScoreService scoreService)&#10;        {&#10;            _scoreService = scoreService;&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (!_audioSource)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;            &#10;            _healthController = GetComponent&lt;PlayerHealthController&gt;();&#10;        }&#10;        private void Start()&#10;        {&#10;            _healthView = _healthController?.HealthView;&#10;            &#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Calculate and award bonus points for remaining health&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;onComplete&quot;&gt;Callback when bonus calculation is complete&lt;/param&gt;&#10;        public void CalculateHealthBonus(System.Action onComplete = null)&#10;        {&#10;            if (_healthController == null)&#10;            {&#10;                Debug.LogWarning(&quot;[HealthBonusService] No PlayerHealthController found&quot;);&#10;                onComplete?.Invoke();&#10;                return;&#10;            }&#10;            &#10;            int remainingHp = _healthController.CurrentHp;&#10;            &#10;            if (remainingHp &lt;= 0)&#10;            {&#10;                Debug.Log(&quot;[HealthBonusService] No remaining HP for bonus&quot;);&#10;                onComplete?.Invoke();&#10;                return;&#10;            }&#10;            &#10;            Debug.Log($&quot;[HealthBonusService] Starting health bonus calculation: {remainingHp} HP remaining&quot;);&#10;            StartCoroutine(DrainHealthForBonus(remainingHp, onComplete));&#10;        }&#10;        &#10;        private IEnumerator DrainHealthForBonus(int remainingHp, System.Action onComplete)&#10;        {&#10;            // Wait before starting the drain&#10;            yield return new WaitForSeconds(drainDelay);&#10;            &#10;            // Drain each HP point individually&#10;            for (int i = 0; i &lt; remainingHp; i++)&#10;            {&#10;                // Award points for this HP&#10;                _scoreService?.AddScore(pointsPerHp);&#10;                &#10;                // Calculate remaining health after draining this HP point&#10;                int healthAfterDrain = remainingHp - (i + 1);&#10;                &#10;                // Update health display (visual only)&#10;                _healthView?.UpdateDisplay(healthAfterDrain, _healthController.MaxHp);&#10;&#10;                // Play drain sound effect&#10;                if (bonusDrainSfx &amp;&amp; _audioSource)&#10;                {&#10;                    _audioSource.PlayOneShot(bonusDrainSfx);&#10;                }&#10;                &#10;                &#10;                // Wait before next drain&#10;                yield return new WaitForSeconds(drainInterval);&#10;            }&#10;&#10;            onComplete?.Invoke();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using Collectables.Score;&#10;using Health.Interfaces;&#10;using Player.Components;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Service responsible for calculating and awarding bonus points based on remaining health&#10;    /// Now uses the SOLID audio system&#10;    /// &lt;/summary&gt;&#10;    public class HealthBonusService : MonoBehaviour&#10;    {&#10;        [Header(&quot;Bonus Settings&quot;)]&#10;        [SerializeField] private int pointsPerHp = 100;&#10;        [SerializeField] private float drainDelay = 0.2f;&#10;        [SerializeField] private float drainInterval = 0.1f;&#10;        &#10;        [Header(&quot;Audio&quot;)]&#10;        [SerializeField] private SoundData bonusDrainSound;&#10;        &#10;        private IScoreService _scoreService;&#10;        private PlayerHealthController _healthController;&#10;        private IHealthView _healthView;&#10;        private IAudioService _audioService;&#10;        &#10;        [Inject]&#10;        public void Construct(IScoreService scoreService, IAudioService audioService)&#10;        {&#10;            _scoreService = scoreService;&#10;            _audioService = audioService;&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            _healthController = GetComponent&lt;PlayerHealthController&gt;();&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            _healthView = _healthController?.HealthView;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Calculate and award bonus points for remaining health&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;onComplete&quot;&gt;Callback when bonus calculation is complete&lt;/param&gt;&#10;        public void CalculateHealthBonus(System.Action onComplete = null)&#10;        {&#10;            if (_healthController == null)&#10;            {&#10;                Debug.LogWarning(&quot;[HealthBonusService] No PlayerHealthController found&quot;);&#10;                onComplete?.Invoke();&#10;                return;&#10;            }&#10;            &#10;            int remainingHp = _healthController.CurrentHp;&#10;            &#10;            if (remainingHp &lt;= 0)&#10;            {&#10;                Debug.Log(&quot;[HealthBonusService] No remaining HP for bonus&quot;);&#10;                onComplete?.Invoke();&#10;                return;&#10;            }&#10;            &#10;            Debug.Log($&quot;[HealthBonusService] Starting health bonus calculation: {remainingHp} HP remaining&quot;);&#10;            StartCoroutine(DrainHealthForBonus(remainingHp, onComplete));&#10;        }&#10;        &#10;        private IEnumerator DrainHealthForBonus(int remainingHp, System.Action onComplete)&#10;        {&#10;            // Wait before starting the drain&#10;            yield return new WaitForSeconds(drainDelay);&#10;            &#10;            // Drain each HP point individually&#10;            for (int i = 0; i &lt; remainingHp; i++)&#10;            {&#10;                // Award points for this HP&#10;                _scoreService?.AddScore(pointsPerHp);&#10;                &#10;                // Calculate remaining health after draining this HP point&#10;                int healthAfterDrain = remainingHp - (i + 1);&#10;                &#10;                // Update health display (visual only)&#10;                _healthView?.UpdateDisplay(healthAfterDrain, _healthController.MaxHp);&#10;&#10;                // Play drain sound effect using new audio system&#10;                if (bonusDrainSound?.clip &amp;&amp; _audioService != null)&#10;                {&#10;                    _audioService.PlaySound(&#10;                        bonusDrainSound.clip,&#10;                        bonusDrainSound.GetRandomizedVolume(),&#10;                        bonusDrainSound.GetRandomizedPitch()&#10;                    );&#10;                }&#10;                &#10;                // Wait before next drain&#10;                yield return new WaitForSeconds(drainInterval);&#10;            }&#10;            &#10;            Debug.Log($&quot;[HealthBonusService] Health bonus calculation complete. Awarded {remainingHp * pointsPerHp} bonus points&quot;);&#10;            onComplete?.Invoke();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameLifetimeScope.cs" />
              <option name="updatedContent" value="using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace StartGame&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     VContainer lifetime scope for Start Game screen&#10;    /// &lt;/summary&gt;&#10;    public class StartGameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[StartGameLifetimeScope] Configuring start game DI container...&quot;);&#10;&#10;            // Register core services needed for start screen&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ISceneLoadService, SceneLoadService&gt;(Lifetime.Singleton);&#10;&#10;            // Register core game management components&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;&#10;            // Register start game specific components&#10;            builder.RegisterComponentInHierarchy&lt;StartGameListener&gt;();&#10;&#10;            Debug.Log(&quot;[StartGameLifetimeScope] Start game DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>