<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/DI/GameLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/DI/GameLifetimeScope.cs" />
              <option name="originalContent" value="using Collectables.Score;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using Player.Interfaces;&#10;using Player.Services;&#10;using Player.UI;&#10;using Pooling;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;using Weapons.Models;&#10;using Weapons.Services;&#10;&#10;namespace Core.DI&#10;{&#10;    public class GameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Awake()&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Awake called.&quot;);&#10;            AddToAutoInject&lt;FireballWeapon&gt;();&#10;            base.Awake();&#10;        }&#10;&#10;        private void AddToAutoInject&lt;T&gt;() where T : Component&#10;        {&#10;&#10;            var components = FindObjectsByType&lt;T&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;&#10;            foreach (T comp in components)&#10;            {&#10;                autoInjectGameObjects.Add(comp.gameObject);&#10;            }&#10;        }&#10;&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Configuring DI container...&quot;);&#10;&#10;            // Register Core Services&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;&#10;            // Register EventBus as IEventPublisher as well (since EventBus implements IEventPublisher)&#10;            builder.Register&lt;IEventPublisher&gt;(resolver =&gt; resolver.Resolve&lt;IEventBus&gt;(), Lifetime.Singleton);&#10;&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IScoreService, ScoreService&gt;(Lifetime.Singleton);&#10;            builder.RegisterComponentInHierarchy&lt;SceneLoadService&gt;().As&lt;ISceneLoadService&gt;();&#10;&#10;&#10;            // Register Player Services&#10;            builder.Register&lt;IPlayerLivesService&gt;(resolver&#10;                =&gt; new PlayerLivesService(&#10;                    resolver.Resolve&lt;GameDataCoordinator&gt;()&#10;                ), Lifetime.Singleton);&#10;&#10;&#10;            // Game Management&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;EndLevelZone&gt;();&#10;            // Pooling System&#10;            builder.RegisterComponentInHierarchy&lt;PoolManager&gt;().As&lt;IPoolService&gt;();&#10;&#10;            // Weapons&#10;            builder.RegisterComponentInHierarchy&lt;AxeWeapon&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;WeaponManagerService&gt;();&#10;&#10;            // Health&#10;            builder.RegisterComponentInHierarchy&lt;PlayerHealthController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerLivesUIController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerAnimationController&gt;();&#10;&#10;            // Score System&#10;            builder.RegisterComponentInHierarchy&lt;ScoreController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PopupTextService&gt;();&#10;&#10;&#10;            Debug.Log(&quot;[GameLifetimeScope] DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Collectables.Score;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using Player.Interfaces;&#10;using Player.Services;&#10;using Player.UI;&#10;using Pooling;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;using Weapons.Models;&#10;using Weapons.Services;&#10;&#10;namespace Core.DI&#10;{&#10;    public class GameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Awake()&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Awake called.&quot;);&#10;            AddToAutoInject&lt;FireballWeapon&gt;();&#10;            base.Awake();&#10;        }&#10;&#10;        private void AddToAutoInject&lt;T&gt;() where T : Component&#10;        {&#10;&#10;            var components = FindObjectsByType&lt;T&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;&#10;            foreach (T comp in components)&#10;            {&#10;                autoInjectGameObjects.Add(comp.gameObject);&#10;            }&#10;        }&#10;&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Configuring DI container...&quot;);&#10;&#10;            // Register Core Services&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;&#10;            // Register EventBus as IEventPublisher as well (since EventBus implements IEventPublisher)&#10;            builder.Register&lt;IEventPublisher&gt;(resolver =&gt; resolver.Resolve&lt;IEventBus&gt;(), Lifetime.Singleton);&#10;&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IScoreService, ScoreService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ILevelDiscoveryService, LevelDiscoveryService&gt;(Lifetime.Singleton);&#10;            builder.RegisterComponentInHierarchy&lt;SceneLoadService&gt;().As&lt;ISceneLoadService&gt;();&#10;&#10;&#10;            // Register Player Services&#10;            builder.Register&lt;IPlayerLivesService&gt;(resolver&#10;                =&gt; new PlayerLivesService(&#10;                    resolver.Resolve&lt;GameDataCoordinator&gt;()&#10;                ), Lifetime.Singleton);&#10;&#10;&#10;            // Game Management&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;EndLevelZone&gt;();&#10;            // Pooling System&#10;            builder.RegisterComponentInHierarchy&lt;PoolManager&gt;().As&lt;IPoolService&gt;();&#10;&#10;            // Weapons&#10;            builder.RegisterComponentInHierarchy&lt;AxeWeapon&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;WeaponManagerService&gt;();&#10;&#10;            // Health&#10;            builder.RegisterComponentInHierarchy&lt;PlayerHealthController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerLivesUIController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerAnimationController&gt;();&#10;&#10;            // Score System&#10;            builder.RegisterComponentInHierarchy&lt;ScoreController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PopupTextService&gt;();&#10;&#10;&#10;            Debug.Log(&quot;[GameLifetimeScope] DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/GameFlowManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/GameFlowManager.cs" />
              <option name="originalContent" value="using System;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using EasyTransition;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameFlowManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Game Settings&quot;)]&#10;        [SerializeField] private float restartDelay = 2f;&#10;        &#10;        [Header(&quot;Victory Settings&quot;)]&#10;        [SerializeField] private string victorySceneName = &quot;YouWonScene&quot;;&#10;        [SerializeField] private float victoryTransitionDelay = 3f;&#10;        &#10;        [Header(&quot;Scene Transitions&quot;)]&#10;        [SerializeField] private TransitionSettings defaultTransition;&#10;&#10;        private string _currentLevelName = &quot;Unknown&quot;;&#10;        private float _levelStartTime;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private ISceneLoadService _sceneLoadService;&#10;&#10;        private GameState CurrentState { get; set; } = GameState.MainMenu;&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, GameDataCoordinator gameDataCoordinator, ISceneLoadService sceneLoadService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            _sceneLoadService = sceneLoadService;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            _currentLevelName = GetCurrentLevelName();&#10;            &#10;            // Only auto-start gameplay in actual level scenes&#10;            // Other scenes (Level Select, Start Menu, etc.) will manage their own states&#10;            if (ShouldAutoStartGameplay())&#10;            {&#10;                StartGameplay();&#10;            }&#10;        }&#10;&#10;        private static bool ShouldAutoStartGameplay()&#10;        {&#10;            // Only auto-start gameplay in actual level scenes&#10;            string sceneName = SceneManager.GetActiveScene().name;&#10;            return !sceneName.Equals(&quot;Level Select&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; &#10;                   !sceneName.Contains(&quot;Start&quot;) &amp;&amp;&#10;                   !sceneName.Equals(&quot;YouWonScene&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            UnsubscribeFromEvents();&#10;        }&#10;&#10;        private void StartGameplay()&#10;        {&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = _currentLevelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void StartLevel(string levelName)&#10;        {&#10;            _currentLevelName = levelName;&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = levelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void PauseGame()&#10;        {&#10;            if (CurrentState == GameState.Playing)&#10;                ChangeState(GameState.Paused);&#10;        }&#10;&#10;        public void ResumeGame()&#10;        {&#10;            if (CurrentState == GameState.Paused)&#10;                ChangeState(GameState.Playing);&#10;        }&#10;&#10;        public void RestartLevel()&#10;        {&#10;            string currentSceneName = SceneManager.GetActiveScene().name;&#10;            _sceneLoadService?.LoadLevel(currentSceneName);&#10;        }&#10;&#10;        public void HandlePlayerDeath(Vector3 deathPosition)&#10;        {&#10;            _eventBus?.Publish(new PlayerDeathEvent&#10;            {&#10;                DeathPosition = deathPosition,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void CompleteLevel(string currentLevelName)&#10;        {&#10;            float completionTime = Time.time - _levelStartTime;&#10;            &#10;            _eventBus?.Publish(new LevelCompletedEvent&#10;            {&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void RequestLevelLoad(string levelName, string sceneName)&#10;        {&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                SceneName = sceneName&#10;            });&#10;        }&#10;&#10;        public void SelectLevel(string levelName, int levelIndex)&#10;        {&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                LevelIndex = levelIndex&#10;            });&#10;        }&#10;&#10;        public void NavigateLevel(int previousIndex, int newIndex, Vector2 direction)&#10;        {&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = newIndex,&#10;                Direction = direction&#10;            });&#10;        }&#10;&#10;        public void NavigateToLevelSelection()&#10;        {&#10;            try&#10;            {&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to navigate to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void OnGameOver(GameOverEvent gameOverEvent)&#10;        {&#10;            ChangeState(GameState.GameOver);&#10;            RestartLevelAfterDelayAsync(restartDelay);&#10;        }&#10;&#10;        private async void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            ChangeState(GameState.Victory);&#10;&#10;            // First, check if the level was already completed&#10;            bool wasAlreadyCompleted = _gameDataCoordinator.IsLevelCompleted(levelEvent.LevelName);&#10;&#10;            // Now, update the progress (marks as complete, updates best time, etc.)&#10;            _gameDataCoordinator.UpdateLevelProgress(levelEvent.LevelName, true, levelEvent.CompletionTime);&#10;&#10;            // If it's the first time completing this level, unlock the next one&#10;            if (!wasAlreadyCompleted)&#10;            {&#10;                await UnlockNextLevelByIndex(levelEvent.LevelName);&#10;            }&#10;&#10;            if (await IsGameCompletedAsync())&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] All levels completed! Transitioning to YouWonScene...&quot;);&#10;                TransitionToVictorySceneAsync();&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] Level {levelEvent.LevelName} completed. Returning to level selection...&quot;);&#10;                ReturnToLevelSelectionAsync();&#10;            }&#10;        }&#10;&#10;        private async Task UnlockNextLevelByIndex(string completedLevelName)&#10;        {&#10;            Debug.Log($&quot;[GameFlowManager] UnlockNextLevelByIndex called for: {completedLevelName}&quot;);&#10;            &#10;            var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            if (allLevels == null || allLevels.Count == 0) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] No levels discovered for unlocking next level&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Found {allLevels.Count} levels total&quot;);&#10;            &#10;            var completedLevel = allLevels.FirstOrDefault(l =&gt; l.levelName == completedLevelName);&#10;            if (completedLevel == null) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] Could not find completed level: {completedLevelName}&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Completed level index: {completedLevel.levelIndex}&quot;);&#10;            int nextLevelIndex = completedLevel.levelIndex + 1;&#10;&#10;            if (nextLevelIndex &lt; allLevels.Count)&#10;            {&#10;                var nextLevel = allLevels.FirstOrDefault(l =&gt; l.levelIndex == nextLevelIndex);&#10;                if (nextLevel != null)&#10;                {&#10;                    bool isAlreadyUnlocked = _gameDataCoordinator.IsLevelUnlocked(nextLevel.levelName);&#10;                    Debug.Log($&quot;[GameFlowManager] Next level '{nextLevel.levelName}' (index {nextLevelIndex}) - Already unlocked: {isAlreadyUnlocked}&quot;);&#10;                    &#10;                    if (!isAlreadyUnlocked)&#10;                    {&#10;                        _gameDataCoordinator.UnlockLevel(nextLevel.levelName);&#10;                        Debug.Log($&quot;[GameFlowManager] Unlocked next level: {nextLevel.levelName}&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        Debug.Log($&quot;[GameFlowManager] Next level {nextLevel.levelName} was already unlocked&quot;);&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;[GameFlowManager] Could not find level with index {nextLevelIndex}&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] No more levels to unlock (completed level was the last one)&quot;);&#10;            }&#10;        }&#10;&#10;        private async Task&lt;bool&gt; IsGameCompletedAsync()&#10;        {&#10;            try&#10;            {&#10;                // Get all available levels through GameDataCoordinator&#10;                var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;                &#10;                if (allLevels == null || allLevels.Count == 0)&#10;                {&#10;                    Debug.LogWarning(&quot;[GameFlowManager] No levels found in discovery service&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Get completed levels using wrapper method&#10;                var completedLevels = _gameDataCoordinator?.GetCompletedLevels();&#10;                if (completedLevels == null) return false;&#10;&#10;                // Check if all levels are in the completed list&#10;                var completedCount = 0;&#10;                foreach (var level in allLevels)&#10;                {&#10;                    if (completedLevels.Contains(level.levelName))&#10;                    {&#10;                        completedCount++;&#10;                    }&#10;                }&#10;                &#10;                Debug.Log($&quot;[GameFlowManager] Game completion check: {completedCount}/{allLevels.Count} levels completed&quot;);&#10;                &#10;                if (completedCount &gt;= allLevels.Count)&#10;                {&#10;                    Debug.Log(&quot;[GameFlowManager] All levels completed!&quot;);&#10;                    return true;&#10;                }&#10;&#10;                var remainingLevels = allLevels.Where(l =&gt; !completedLevels.Contains(l.levelName)).Select(l =&gt; l.levelName);&#10;                Debug.Log($&quot;[GameFlowManager] Remaining levels: {string.Join(&quot;, &quot;, remainingLevels)}&quot;);&#10;                return false;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Error checking game completion: {e}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private async void TransitionToVictorySceneAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(victoryTransitionDelay * 1000));&#10;                &#10;                _eventBus?.Publish(new GameCompletedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    FinalLevelName = _currentLevelName&#10;                });&#10;                &#10;                _sceneLoadService?.LoadLevel(victorySceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to transition to victory scene: {e}&quot;);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;        }&#10;&#10;        private async void ReturnToLevelSelectionAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(2f * 1000));&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to return to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnPlayerLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            bool lostLife = livesEvent.PreviousLives &gt; livesEvent.CurrentLives;&#10;            bool isGameOver = livesEvent.CurrentLives == 0;&#10;&#10;            if (isGameOver)&#10;            {&#10;                ChangeState(GameState.GameOver);&#10;                _gameDataCoordinator?.ResetAllData();&#10;                _eventBus?.Publish(new GameOverEvent { Timestamp = Time.time });&#10;            }&#10;&#10;            if (lostLife)&#10;            {&#10;                _eventBus?.Publish(new PlayerDeathEvent&#10;                {&#10;                    DeathPosition = PlayerLocator.PlayerTransform.position,&#10;                    Timestamp = Time.time&#10;                });&#10;            }&#10;&#10;            if (isGameOver || lostLife)&#10;            {&#10;                Time.timeScale = 0.01f;&#10;                RestartLevelAfterDelayAsync(restartDelay);&#10;            }&#10;        }&#10;&#10;        private static async void RestartLevelAfterDelayAsync(float delay)&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(delay * 1000));&#10;                string currentSceneName = SceneManager.GetActiveScene().name;&#10;                SceneManager.LoadScene(currentSceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to restart level after delay: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ChangeState(GameState newState)&#10;        {&#10;            if (CurrentState == newState) return;&#10;&#10;            GameState oldState = CurrentState;&#10;            CurrentState = newState;&#10;&#10;            _eventBus?.Publish(new GameStateChangedEvent&#10;            {&#10;                PreviousState = oldState,&#10;                NewState = newState,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private string GetCurrentLevelName() =&gt; SceneManager.GetActiveScene().name;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using EasyTransition;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameFlowManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Game Settings&quot;)]&#10;        [SerializeField] private float restartDelay = 2f;&#10;        &#10;        [Header(&quot;Victory Settings&quot;)]&#10;        [SerializeField] private string victorySceneName = &quot;YouWonScene&quot;;&#10;        [SerializeField] private float victoryTransitionDelay = 3f;&#10;        &#10;        [Header(&quot;Scene Transitions&quot;)]&#10;        [SerializeField] private TransitionSettings defaultTransition;&#10;&#10;        private string _currentLevelName = &quot;Unknown&quot;;&#10;        private float _levelStartTime;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private ISceneLoadService _sceneLoadService;&#10;&#10;        private GameState CurrentState { get; set; } = GameState.MainMenu;&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, GameDataCoordinator gameDataCoordinator, ISceneLoadService sceneLoadService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            _sceneLoadService = sceneLoadService;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            _currentLevelName = GetCurrentLevelName();&#10;            &#10;            // Only auto-start gameplay in actual level scenes&#10;            // Other scenes (Level Select, Start Menu, etc.) will manage their own states&#10;            if (ShouldAutoStartGameplay())&#10;            {&#10;                StartGameplay();&#10;            }&#10;        }&#10;&#10;        private static bool ShouldAutoStartGameplay()&#10;        {&#10;            // Only auto-start gameplay in actual level scenes&#10;            string sceneName = SceneManager.GetActiveScene().name;&#10;            return !sceneName.Equals(&quot;Level Select&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; &#10;                   !sceneName.Contains(&quot;Start&quot;) &amp;&amp;&#10;                   !sceneName.Equals(&quot;YouWonScene&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            UnsubscribeFromEvents();&#10;        }&#10;&#10;        private void StartGameplay()&#10;        {&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = _currentLevelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void StartLevel(string levelName)&#10;        {&#10;            _currentLevelName = levelName;&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = levelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void PauseGame()&#10;        {&#10;            if (CurrentState == GameState.Playing)&#10;                ChangeState(GameState.Paused);&#10;        }&#10;&#10;        public void ResumeGame()&#10;        {&#10;            if (CurrentState == GameState.Paused)&#10;                ChangeState(GameState.Playing);&#10;        }&#10;&#10;        public void RestartLevel()&#10;        {&#10;            string currentSceneName = SceneManager.GetActiveScene().name;&#10;            _sceneLoadService?.LoadLevel(currentSceneName);&#10;        }&#10;&#10;        public void HandlePlayerDeath(Vector3 deathPosition)&#10;        {&#10;            _eventBus?.Publish(new PlayerDeathEvent&#10;            {&#10;                DeathPosition = deathPosition,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void CompleteLevel(string currentLevelName)&#10;        {&#10;            float completionTime = Time.time - _levelStartTime;&#10;            &#10;            _eventBus?.Publish(new LevelCompletedEvent&#10;            {&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void RequestLevelLoad(string levelName, string sceneName)&#10;        {&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                SceneName = sceneName&#10;            });&#10;        }&#10;&#10;        public void SelectLevel(string levelName, int levelIndex)&#10;        {&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                LevelIndex = levelIndex&#10;            });&#10;        }&#10;&#10;        public void NavigateLevel(int previousIndex, int newIndex, Vector2 direction)&#10;        {&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = newIndex,&#10;                Direction = direction&#10;            });&#10;        }&#10;&#10;        public void NavigateToLevelSelection()&#10;        {&#10;            try&#10;            {&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to navigate to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void OnGameOver(GameOverEvent gameOverEvent)&#10;        {&#10;            ChangeState(GameState.GameOver);&#10;            RestartLevelAfterDelayAsync(restartDelay);&#10;        }&#10;&#10;        private async void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            ChangeState(GameState.Victory);&#10;&#10;            // First, check if the level was already completed&#10;            bool wasAlreadyCompleted = _gameDataCoordinator.IsLevelCompleted(levelEvent.LevelName);&#10;&#10;            // Now, update the progress (marks as complete, updates best time, etc.)&#10;            _gameDataCoordinator.UpdateLevelProgress(levelEvent.LevelName, true, levelEvent.CompletionTime);&#10;&#10;            // If it's the first time completing this level, unlock the next one&#10;            if (!wasAlreadyCompleted)&#10;            {&#10;                await UnlockNextLevelByIndex(levelEvent.LevelName);&#10;            }&#10;&#10;            if (await IsGameCompletedAsync())&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] All levels completed! Transitioning to YouWonScene...&quot;);&#10;                TransitionToVictorySceneAsync();&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] Level {levelEvent.LevelName} completed. Returning to level selection...&quot;);&#10;                ReturnToLevelSelectionAsync();&#10;            }&#10;        }&#10;&#10;        private async Task UnlockNextLevelByIndex(string completedLevelName)&#10;        {&#10;            Debug.Log($&quot;[GameFlowManager] UnlockNextLevelByIndex called for: {completedLevelName}&quot;);&#10;            &#10;            var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            if (allLevels == null || allLevels.Count == 0) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] No levels discovered for unlocking next level&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Found {allLevels.Count} levels total&quot;);&#10;            &#10;            var completedLevel = allLevels.FirstOrDefault(l =&gt; l.levelName == completedLevelName);&#10;            if (completedLevel == null) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] Could not find completed level: {completedLevelName}&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Completed level index: {completedLevel.levelIndex}&quot;);&#10;            int nextLevelIndex = completedLevel.levelIndex + 1;&#10;&#10;            if (nextLevelIndex &lt; allLevels.Count)&#10;            {&#10;                var nextLevel = allLevels.FirstOrDefault(l =&gt; l.levelIndex == nextLevelIndex);&#10;                if (nextLevel != null)&#10;                {&#10;                    bool isAlreadyUnlocked = _gameDataCoordinator.IsLevelUnlocked(nextLevel.levelName);&#10;                    Debug.Log($&quot;[GameFlowManager] Next level '{nextLevel.levelName}' (index {nextLevelIndex}) - Already unlocked: {isAlreadyUnlocked}&quot;);&#10;                    &#10;                    if (!isAlreadyUnlocked)&#10;                    {&#10;                        _gameDataCoordinator.UnlockLevel(nextLevel.levelName);&#10;                        Debug.Log($&quot;[GameFlowManager] Unlocked next level: {nextLevel.levelName}&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        Debug.Log($&quot;[GameFlowManager] Next level {nextLevel.levelName} was already unlocked&quot;);&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;[GameFlowManager] Could not find level with index {nextLevelIndex}&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] No more levels to unlock (completed level was the last one)&quot;);&#10;            }&#10;        }&#10;&#10;        private async Task&lt;bool&gt; IsGameCompletedAsync()&#10;        {&#10;            try&#10;            {&#10;                // Get all available levels through GameDataCoordinator&#10;                var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;                &#10;                if (allLevels == null || allLevels.Count == 0)&#10;                {&#10;                    Debug.LogWarning(&quot;[GameFlowManager] No levels found in discovery service&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Get completed levels using wrapper method&#10;                var completedLevels = _gameDataCoordinator?.GetCompletedLevels();&#10;                if (completedLevels == null) return false;&#10;&#10;                // Check if all levels are in the completed list&#10;                var completedCount = 0;&#10;                foreach (var level in allLevels)&#10;                {&#10;                    if (completedLevels.Contains(level.levelName))&#10;                    {&#10;                        completedCount++;&#10;                    }&#10;                }&#10;                &#10;                Debug.Log($&quot;[GameFlowManager] Game completion check: {completedCount}/{allLevels.Count} levels completed&quot;);&#10;                &#10;                if (completedCount &gt;= allLevels.Count)&#10;                {&#10;                    Debug.Log(&quot;[GameFlowManager] All levels completed!&quot;);&#10;                    return true;&#10;                }&#10;&#10;                var remainingLevels = allLevels.Where(l =&gt; !completedLevels.Contains(l.levelName)).Select(l =&gt; l.levelName);&#10;                Debug.Log($&quot;[GameFlowManager] Remaining levels: {string.Join(&quot;, &quot;, remainingLevels)}&quot;);&#10;                return false;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Error checking game completion: {e}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private async void TransitionToVictorySceneAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(victoryTransitionDelay * 1000));&#10;                &#10;                _eventBus?.Publish(new GameCompletedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    FinalLevelName = _currentLevelName&#10;                });&#10;                &#10;                _sceneLoadService?.LoadLevel(victorySceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to transition to victory scene: {e}&quot;);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;        }&#10;&#10;        private async void ReturnToLevelSelectionAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(2f * 1000));&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to return to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnPlayerLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            bool lostLife = livesEvent.PreviousLives &gt; livesEvent.CurrentLives;&#10;            bool isGameOver = livesEvent.CurrentLives == 0;&#10;&#10;            if (isGameOver)&#10;            {&#10;                ChangeState(GameState.GameOver);&#10;                _gameDataCoordinator?.ResetAllData();&#10;                _eventBus?.Publish(new GameOverEvent { Timestamp = Time.time });&#10;            }&#10;&#10;            if (lostLife)&#10;            {&#10;                _eventBus?.Publish(new PlayerDeathEvent&#10;                {&#10;                    DeathPosition = PlayerLocator.PlayerTransform.position,&#10;                    Timestamp = Time.time&#10;                });&#10;            }&#10;&#10;            if (isGameOver || lostLife)&#10;            {&#10;                Time.timeScale = 0.01f;&#10;                RestartLevelAfterDelayAsync(restartDelay);&#10;            }&#10;        }&#10;&#10;        private async void RestartLevelAfterDelayAsync(float delay)&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(delay * 1000));&#10;                string currentSceneName = SceneManager.GetActiveScene().name;&#10;                _sceneLoadService?.LoadLevel(currentSceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to restart level after delay: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ChangeState(GameState newState)&#10;        {&#10;            if (CurrentState == newState) return;&#10;&#10;            GameState oldState = CurrentState;&#10;            CurrentState = newState;&#10;&#10;            _eventBus?.Publish(new GameStateChangedEvent&#10;            {&#10;                PreviousState = oldState,&#10;                NewState = newState,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private string GetCurrentLevelName() =&gt; SceneManager.GetActiveScene().name;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/DI/LevelSelectionLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/DI/LevelSelectionLifetimeScope.cs" />
              <option name="originalContent" value="using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace LevelSelection.DI&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     VContainer lifetime scope for Level Selection services&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Configuring level selection DI container...&quot;);&#10;&#10;            // Register core services that level selection depends on&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;&#10;            // Register core game management components&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;&#10;            // Register the new service-based architecture&#10;            builder.Register&lt;ILevelDiscoveryService, LevelDiscoveryService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;ILevelNavigationService, LevelNavigationService&gt;(Lifetime.Scoped);&#10;&#10;            // Register NEW focused services following SOLID principles&#10;            builder.Register&lt;ISelectorService, SelectorService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IInputFilterService, InputFilterService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IAudioFeedbackService, AudioFeedbackService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IItemSelectService, ItemSelectService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;ISceneLoadService, SceneLoadService&gt;(Lifetime.Scoped);&#10;&#10;            // Register the main controller&#10;            builder.RegisterComponentInHierarchy&lt;LevelSelectionController&gt;();&#10;&#10;            // Register supporting components that are still used&#10;            builder.RegisterComponentInHierarchy&lt;ItemSelectScreen&gt;();&#10;&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Level selection DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace LevelSelection.DI&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     VContainer lifetime scope for Level Selection services&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Configuring level selection DI container...&quot;);&#10;&#10;            // Register core services that level selection depends on&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;&#10;            // Register core game management components&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;&#10;            // Register the new service-based architecture&#10;            builder.Register&lt;ILevelDiscoveryService, LevelDiscoveryService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;ILevelNavigationService, LevelNavigationService&gt;(Lifetime.Scoped);&#10;&#10;            // Register NEW focused services following SOLID principles&#10;            builder.Register&lt;ISelectorService, SelectorService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IInputFilterService, InputFilterService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IAudioFeedbackService, AudioFeedbackService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IItemSelectService, ItemSelectService&gt;(Lifetime.Scoped);&#10;            builder.RegisterComponentInHierarchy&lt;SceneLoadService&gt;().As&lt;ISceneLoadService&gt;();&#10;&#10;            // Register the main controller&#10;            builder.RegisterComponentInHierarchy&lt;LevelSelectionController&gt;();&#10;&#10;            // Register supporting components that are still used&#10;            builder.RegisterComponentInHierarchy&lt;ItemSelectScreen&gt;();&#10;&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Level selection DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionController.cs" />
              <option name="originalContent" value="using System.Threading.Tasks;&#10;using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class LevelSelectionController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Configuration&quot;)] [SerializeField]&#10;        private bool autoActivateOnStart = true;&#10;&#10;        [Header(&quot;UI Components&quot;)] [SerializeField]&#10;        private GameObject selectorObject;&#10;&#10;        [SerializeField] private ItemSelectScreen itemSelectScreen;&#10;&#10;        [Header(&quot;Input Actions&quot;)] [SerializeField]&#10;        private InputActionReference navigateAction;&#10;&#10;        [SerializeField] private InputActionReference submitAction;&#10;&#10;        private IAudioFeedbackService _audioFeedbackService;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private GameFlowManager _gameFlowManager;&#10;        private IInputFilterService _inputFilterService;&#10;        private IItemSelectService _itemSelectService;&#10;        private ILevelNavigationService _navigationService;&#10;        private ISceneLoadService _sceneLoadService;&#10;        private ISelectorService _selectorService;&#10;&#10;        public bool IsActive { get; private set; }&#10;&#10;        private async void Start()&#10;        {&#10;            await InitializeAsync();&#10;&#10;            if (autoActivateOnStart)&#10;            {&#10;                Activate();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            _selectorService?.Update();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.Enable();&#10;                navigateAction.action.performed += OnNavigate;&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnSubmit;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.performed -= OnNavigate;&#10;                navigateAction.action.Disable();&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.performed -= OnSubmit;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            ILevelNavigationService navigationService,&#10;            IEventBus eventBus,&#10;            ISelectorService selectorService,&#10;            IInputFilterService inputFilterService,&#10;            IAudioFeedbackService audioFeedbackService,&#10;            IItemSelectService itemSelectService,&#10;            ISceneLoadService sceneLoadService,&#10;            GameFlowManager gameFlowManager,&#10;            GameDataCoordinator gameDataCoordinator)&#10;        {&#10;            _navigationService = navigationService;&#10;            _eventBus = eventBus;&#10;            _selectorService = selectorService;&#10;            _inputFilterService = inputFilterService;&#10;            _audioFeedbackService = audioFeedbackService;&#10;            _itemSelectService = itemSelectService;&#10;            _sceneLoadService = sceneLoadService;&#10;            _gameFlowManager = gameFlowManager;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private async Task InitializeAsync()&#10;        {&#10;            InitializeServices();&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                _gameFlowManager.PauseGame();&#10;            }&#10;&#10;            var levelData = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            await _navigationService.InitializeAsync(levelData);&#10;&#10;            // Configure navigation service with grid width (hardcoded since config removed)&#10;            _navigationService.SetGridWidth(4); // Default grid width&#10;        }&#10;&#10;        private void InitializeServices()&#10;        {&#10;            AudioSource audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (audioSource == null)&#10;            {&#10;                audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;&#10;            _selectorService.Initialize(selectorObject);&#10;            _inputFilterService.Initialize();&#10;            _audioFeedbackService.Initialize(audioSource);&#10;            _itemSelectService.Initialize(itemSelectScreen, _sceneLoadService);&#10;&#10;            _itemSelectService.OnStateChanged += OnItemSelectStateChanged;&#10;        }&#10;&#10;        private void OnItemSelectStateChanged(bool isActive)&#10;        {&#10;            _selectorService.SetVisible(!isActive);&#10;            _inputFilterService.SetEnabled(!isActive);&#10;        }&#10;&#10;        private void OnNavigate(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;&#10;            Vector2 direction = context.ReadValue&lt;Vector2&gt;();&#10;&#10;            if (_inputFilterService.ProcessNavigationInput(direction, out Vector2 filteredDirection))&#10;            {&#10;                _navigationService.NavigateInDirection(filteredDirection);&#10;            }&#10;        }&#10;&#10;        private void OnSubmit(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;            &#10;            // Prevent input during scene transitions&#10;            if (SceneTransitionManager.Instance &amp;&amp; SceneTransitionManager.Instance.IsTransitioning)&#10;            {&#10;                return;&#10;            }&#10;&#10;            _navigationService.SelectCurrentLevel();&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            _audioFeedbackService.PlayNavigationSound();&#10;            _selectorService.MoveToCurrentLevel(_navigationService);&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent selectionEvent)&#10;        {&#10;            LevelData levelData = _navigationService.CurrentLevel;&#10;            bool isUnlocked = _gameDataCoordinator?.IsLevelUnlocked(levelData?.levelName) ?? false;&#10;            &#10;            if (levelData != null &amp;&amp; !isUnlocked)&#10;            {&#10;                _audioFeedbackService.PlayLockedSound();&#10;                return;&#10;            }&#10;&#10;            _audioFeedbackService.PlaySelectionSound();&#10;&#10;            string sceneName = _sceneLoadService.GetSceneNameForLevel(levelData);&#10;            _itemSelectService.ShowItemSelect(selectionEvent.LevelName, sceneName);&#10;        }&#10;&#10;        private void OnLevelLoadRequested(LevelLoadRequestedEvent loadEvent)&#10;        {&#10;            _gameDataCoordinator?.UpdateCurrentLevel(loadEvent.LevelName);&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                // Use StartLevel with the correct level name when loading from level selection&#10;                _gameFlowManager.StartLevel(loadEvent.LevelName);&#10;            }&#10;&#10;            _sceneLoadService.LoadLevel(loadEvent.SceneName);&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            IsActive = true;&#10;            _navigationService?.Activate();&#10;&#10;            if (_navigationService?.CurrentIndex &gt;= 0)&#10;            {&#10;                _selectorService?.MoveToCurrentLevel(_navigationService);&#10;            }&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            IsActive = false;&#10;            _navigationService?.Deactivate();&#10;        }&#10;&#10;        public void SetCurrentLevel(int levelIndex)&#10;        {&#10;            _navigationService?.SetCurrentIndex(levelIndex);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Threading.Tasks;&#10;using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using EasyTransition;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    public class LevelSelectionController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Configuration&quot;)] [SerializeField]&#10;        private bool autoActivateOnStart = true;&#10;&#10;        [Header(&quot;UI Components&quot;)] [SerializeField]&#10;        private GameObject selectorObject;&#10;&#10;        [SerializeField] private ItemSelectScreen itemSelectScreen;&#10;&#10;        [Header(&quot;Input Actions&quot;)] [SerializeField]&#10;        private InputActionReference navigateAction;&#10;&#10;        [SerializeField] private InputActionReference submitAction;&#10;&#10;        private IAudioFeedbackService _audioFeedbackService;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private GameFlowManager _gameFlowManager;&#10;        private IInputFilterService _inputFilterService;&#10;        private IItemSelectService _itemSelectService;&#10;        private ILevelNavigationService _navigationService;&#10;        private ISceneLoadService _sceneLoadService;&#10;        private ISelectorService _selectorService;&#10;&#10;        public bool IsActive { get; private set; }&#10;&#10;        private async void Start()&#10;        {&#10;            await InitializeAsync();&#10;&#10;            if (autoActivateOnStart)&#10;            {&#10;                Activate();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            _selectorService?.Update();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.Enable();&#10;                navigateAction.action.performed += OnNavigate;&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnSubmit;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.performed -= OnNavigate;&#10;                navigateAction.action.Disable();&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.performed -= OnSubmit;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            ILevelNavigationService navigationService,&#10;            IEventBus eventBus,&#10;            ISelectorService selectorService,&#10;            IInputFilterService inputFilterService,&#10;            IAudioFeedbackService audioFeedbackService,&#10;            IItemSelectService itemSelectService,&#10;            ISceneLoadService sceneLoadService,&#10;            GameFlowManager gameFlowManager,&#10;            GameDataCoordinator gameDataCoordinator)&#10;        {&#10;            _navigationService = navigationService;&#10;            _eventBus = eventBus;&#10;            _selectorService = selectorService;&#10;            _inputFilterService = inputFilterService;&#10;            _audioFeedbackService = audioFeedbackService;&#10;            _itemSelectService = itemSelectService;&#10;            _sceneLoadService = sceneLoadService;&#10;            _gameFlowManager = gameFlowManager;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private async Task InitializeAsync()&#10;        {&#10;            InitializeServices();&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                _gameFlowManager.PauseGame();&#10;            }&#10;&#10;            var levelData = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            await _navigationService.InitializeAsync(levelData);&#10;&#10;            // Configure navigation service with grid width (hardcoded since config removed)&#10;            _navigationService.SetGridWidth(4); // Default grid width&#10;        }&#10;&#10;        private void InitializeServices()&#10;        {&#10;            AudioSource audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (audioSource == null)&#10;            {&#10;                audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;&#10;            _selectorService.Initialize(selectorObject);&#10;            _inputFilterService.Initialize();&#10;            _audioFeedbackService.Initialize(audioSource);&#10;            _itemSelectService.Initialize(itemSelectScreen, _sceneLoadService);&#10;&#10;            _itemSelectService.OnStateChanged += OnItemSelectStateChanged;&#10;        }&#10;&#10;        private void OnItemSelectStateChanged(bool isActive)&#10;        {&#10;            _selectorService.SetVisible(!isActive);&#10;            _inputFilterService.SetEnabled(!isActive);&#10;        }&#10;&#10;        private void OnNavigate(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;&#10;            Vector2 direction = context.ReadValue&lt;Vector2&gt;();&#10;&#10;            if (_inputFilterService.ProcessNavigationInput(direction, out Vector2 filteredDirection))&#10;            {&#10;                _navigationService.NavigateInDirection(filteredDirection);&#10;            }&#10;        }&#10;&#10;        private void OnSubmit(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;            &#10;            // Prevent input during scene transitions (using EasyTransitions)&#10;            if (TransitionManager.Instance() != null &amp;&amp; TransitionManager.Instance().runningTransition)&#10;            {&#10;                return;&#10;            }&#10;&#10;            _navigationService.SelectCurrentLevel();&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            _audioFeedbackService.PlayNavigationSound();&#10;            _selectorService.MoveToCurrentLevel(_navigationService);&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent selectionEvent)&#10;        {&#10;            LevelData levelData = _navigationService.CurrentLevel;&#10;            bool isUnlocked = _gameDataCoordinator?.IsLevelUnlocked(levelData?.levelName) ?? false;&#10;            &#10;            if (levelData != null &amp;&amp; !isUnlocked)&#10;            {&#10;                _audioFeedbackService.PlayLockedSound();&#10;                return;&#10;            }&#10;&#10;            _audioFeedbackService.PlaySelectionSound();&#10;&#10;            string sceneName = _sceneLoadService.GetSceneNameForLevel(levelData);&#10;            _itemSelectService.ShowItemSelect(selectionEvent.LevelName, sceneName);&#10;        }&#10;&#10;        private void OnLevelLoadRequested(LevelLoadRequestedEvent loadEvent)&#10;        {&#10;            _gameDataCoordinator?.UpdateCurrentLevel(loadEvent.LevelName);&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                // Use StartLevel with the correct level name when loading from level selection&#10;                _gameFlowManager.StartLevel(loadEvent.LevelName);&#10;            }&#10;&#10;            _sceneLoadService.LoadLevel(loadEvent.SceneName);&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            IsActive = true;&#10;            _navigationService?.Activate();&#10;&#10;            if (_navigationService?.CurrentIndex &gt;= 0)&#10;            {&#10;                _selectorService?.MoveToCurrentLevel(_navigationService);&#10;            }&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            IsActive = false;&#10;            _navigationService?.Deactivate();&#10;        }&#10;&#10;        public void SetCurrentLevel(int levelIndex)&#10;        {&#10;            _navigationService?.SetCurrentIndex(levelIndex);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/ISceneLoadService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/ISceneLoadService.cs" />
              <option name="originalContent" value="using EasyTransition;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for scene loading and transitions&#10;    /// &lt;/summary&gt;&#10;    public interface ISceneLoadService&#10;    {&#10;        void LoadLevel(string sceneName);&#10;        string GetSceneNameForLevel(LevelData levelData);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///     Scene loading service that uses EasyTransitions for smooth transitions&#10;    /// &lt;/summary&gt;&#10;    public class SceneLoadService : ISceneLoadService&#10;    {&#10;        private TransitionSettings _defaultTransition;&#10;        private const float DefaultTransitionDelay = 0f;&#10;&#10;        public SceneLoadService()&#10;        {&#10;        }&#10;&#10;        // Constructor with TransitionSettings (for manual instantiation)&#10;        public SceneLoadService(TransitionSettings transitionSettings)&#10;        {&#10;            _defaultTransition = transitionSettings;&#10;        }&#10;&#10;        public void Initialize(TransitionSettings transitionSettings)&#10;        {&#10;            _defaultTransition = transitionSettings;&#10;        }&#10;&#10;        public void LoadLevel(string sceneName)&#10;        {&#10;            if (string.IsNullOrEmpty(sceneName))&#10;            {&#10;                Debug.LogError(&quot;[SceneLoadService] Scene name is null or empty&quot;);&#10;                return;&#10;            }&#10;&#10;            try&#10;            {&#10;                // Use EasyTransitions if available, otherwise fallback to direct scene loading&#10;                if (_defaultTransition != null &amp;&amp; TransitionManager.Instance() != null)&#10;                {&#10;                    Debug.Log($&quot;[SceneLoadService] Loading scene with transition: {sceneName}&quot;);&#10;                    TransitionManager.Instance().Transition(sceneName, _defaultTransition, DefaultTransitionDelay);&#10;                }&#10;                else&#10;                {&#10;                    Debug.Log($&quot;[SceneLoadService] Loading scene directly (no transition): {sceneName}&quot;);&#10;                    SceneManager.LoadScene(sceneName);&#10;                }&#10;            }&#10;            catch (System.Exception e)&#10;            {&#10;                Debug.LogError($&quot;[SceneLoadService] Failed to load scene {sceneName}: {e}&quot;);&#10;                // Fallback to direct scene loading&#10;                SceneManager.LoadScene(sceneName);&#10;            }&#10;        }&#10;&#10;        public string GetSceneNameForLevel(LevelData levelData)&#10;        {&#10;            if (levelData == null)&#10;            {&#10;                Debug.LogWarning(&quot;[SceneLoadService] LevelData is null, cannot get scene name&quot;);&#10;                return string.Empty;&#10;            }&#10;&#10;            // Return the scene name from the level data&#10;            return !string.IsNullOrEmpty(levelData.sceneName) ? levelData.sceneName : levelData.levelName;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using EasyTransition;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for scene loading and transitions&#10;    /// &lt;/summary&gt;&#10;    public interface ISceneLoadService&#10;    {&#10;        void LoadLevel(string sceneName);&#10;        string GetSceneNameForLevel(LevelData levelData);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///     MonoBehaviour scene loading service that uses EasyTransitions for smooth transitions&#10;    ///     Should be placed on the same GameObject as the TransitionManager&#10;    /// &lt;/summary&gt;&#10;    public class SceneLoadService : MonoBehaviour, ISceneLoadService&#10;    {&#10;        [Header(&quot;Transition Settings&quot;)]&#10;        [SerializeField] private TransitionSettings defaultTransition;&#10;&#10;        private const float DefaultTransitionDelay = 0f;&#10;&#10;        public void LoadLevel(string sceneName)&#10;        {&#10;            if (string.IsNullOrEmpty(sceneName))&#10;            {&#10;                Debug.LogError(&quot;[SceneLoadService] Scene name is null or empty&quot;);&#10;                return;&#10;            }&#10;&#10;            try&#10;            {&#10;                // Use EasyTransitions if available, otherwise fallback to direct scene loading&#10;                if (defaultTransition != null &amp;&amp; TransitionManager.Instance() != null)&#10;                {&#10;                    Debug.Log($&quot;[SceneLoadService] Loading scene with transition: {sceneName}&quot;);&#10;                    TransitionManager.Instance().Transition(sceneName, defaultTransition, DefaultTransitionDelay);&#10;                }&#10;                else&#10;                {&#10;                    Debug.Log($&quot;[SceneLoadService] Loading scene directly (no transition): {sceneName}&quot;);&#10;                    SceneManager.LoadScene(sceneName);&#10;                }&#10;            }&#10;            catch (System.Exception e)&#10;            {&#10;                Debug.LogError($&quot;[SceneLoadService] Failed to load scene {sceneName}: {e}&quot;);&#10;                // Fallback to direct scene loading&#10;                SceneManager.LoadScene(sceneName);&#10;            }&#10;        }&#10;&#10;        public string GetSceneNameForLevel(LevelData levelData)&#10;        {&#10;            if (levelData == null)&#10;            {&#10;                Debug.LogWarning(&quot;[SceneLoadService] LevelData is null, cannot get scene name&quot;);&#10;                return string.Empty;&#10;            }&#10;&#10;            // Return the scene name from the level data&#10;            return !string.IsNullOrEmpty(levelData.sceneName) ? levelData.sceneName : levelData.levelName;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameLifetimeScope.cs" />
              <option name="updatedContent" value="using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace StartGame&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     VContainer lifetime scope for Start Game screen&#10;    /// &lt;/summary&gt;&#10;    public class StartGameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[StartGameLifetimeScope] Configuring start game DI container...&quot;);&#10;&#10;            // Register core services needed for start screen&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ISceneLoadService, SceneLoadService&gt;(Lifetime.Singleton);&#10;&#10;            // Register core game management components&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;&#10;            // Register start game specific components&#10;            builder.RegisterComponentInHierarchy&lt;StartGameListener&gt;();&#10;&#10;            Debug.Log(&quot;[StartGameLifetimeScope] Start game DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameListener.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameListener.cs" />
              <option name="originalContent" value="using System;&#10;using Core;&#10;using InputSystem;&#10;using UnityEngine;&#10;using UnityEngine.EventSystems;&#10;using UnityEngine.InputSystem;&#10;&#10;namespace StartGame&#10;{&#10;    public class StartGameListener : MonoBehaviour&#10;    {&#10;        [SerializeField] private GameFlowManager gameFlowManager;&#10;        private InputSystem_Actions _submitAction;&#10;        public void Start()&#10;        {&#10;            _submitAction = new InputSystem_Actions();&#10;            _submitAction.UI.Submit.performed += StartGame;&#10;            _submitAction.UI.Submit.Enable();&#10;        }&#10;&#10;        private void StartGame(InputAction.CallbackContext callbackContext) =&gt; gameFlowManager?.NavigateToLevelSelection();&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="using System;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using VContainer;&#10;&#10;namespace StartGame&#10;{&#10;    public class StartGameListener : MonoBehaviour&#10;    {&#10;        private InputSystem_Actions _submitAction;&#10;        private ISceneLoadService _sceneLoadService;&#10;&#10;        [Inject]&#10;        public void Construct(ISceneLoadService sceneLoadService)&#10;        {&#10;            _sceneLoadService = sceneLoadService;&#10;        }&#10;&#10;        public void Start()&#10;        {&#10;            _submitAction = new InputSystem_Actions();&#10;            _submitAction.UI.Submit.performed += StartGame;&#10;            _submitAction.UI.Submit.Enable();&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (_submitAction != null)&#10;            {&#10;                _submitAction.UI.Submit.performed -= StartGame;&#10;                _submitAction.Dispose();&#10;            }&#10;        }&#10;&#10;        private void StartGame(InputAction.CallbackContext callbackContext)&#10;        {&#10;            _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/StartGame/StartScreenLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/StartGame/StartScreenLifetimeScope.cs" />
              <option name="originalContent" value="using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using EasyTransition;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace StartGame&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     VContainer lifetime scope for Start Game screen&#10;    /// &lt;/summary&gt;&#10;    public class StartScreenLifetimeScope : LifetimeScope&#10;    {&#10;        [Header(&quot;Transition Settings&quot;)]&#10;        [SerializeField] private TransitionSettings defaultTransition;&#10;&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Configuring level selection DI container...&quot;);&#10;&#10;            // Register core services needed for start screen&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;&#10;            // Register SceneLoadService as a component in hierarchy&#10;            builder.RegisterComponentInHierarchy&lt;SceneLoadService&gt;().As&lt;ISceneLoadService&gt;();&#10;&#10;            // Register start game specific components&#10;            builder.RegisterComponentInHierarchy&lt;StartGameListener&gt;();&#10;&#10;            Debug.Log(&quot;[StartScreenLifetimeScope] Start screen DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using EasyTransition;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace StartGame&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     VContainer lifetime scope for Start Game screen&#10;    /// &lt;/summary&gt;&#10;    public class StartScreenLifetimeScope : LifetimeScope&#10;    {&#10;        [Header(&quot;Transition Settings&quot;)]&#10;        [SerializeField] private TransitionSettings defaultTransition;&#10;&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Configuring level selection DI container...&quot;);&#10;&#10;            // Register core services needed for start screen&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;&#10;            // Register SceneLoadService as a component in hierarchy&#10;            builder.RegisterComponentInHierarchy&lt;SceneLoadService&gt;().As&lt;ISceneLoadService&gt;();&#10;&#10;            // Register start game specific components&#10;            builder.RegisterComponentInHierarchy&lt;StartGameListener&gt;();&#10;&#10;            Debug.Log(&quot;[StartScreenLifetimeScope] Start screen DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>