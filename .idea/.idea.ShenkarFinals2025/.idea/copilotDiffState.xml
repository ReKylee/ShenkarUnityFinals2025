<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDeath.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDeath.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyDeath : MonoBehaviour&#10;    {&#10;        private IHealthEvents _simpleHealthController;&#10;        private void Start()&#10;        {&#10;            _simpleHealthController = GetComponent&lt;IHealthEvents&gt;();&#10;            _simpleHealthController.OnLivesEmpty += HandleDeath;&#10;            _simpleHealthController.OnLivesEmpty -= HandleDeath;&#10;            _simpleHealthController.OnLivesEmpty -= HandleDeath;&#10;            _simpleHealthController.OnLivesEmpty -= HandleDeath;&#10;            _simpleHealthController.OnLivesEmpty -= HandleDeath;&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyDeath : MonoBehaviour&#10;    {&#10;        private IHealthEvents _healthEvents;&#10;        private void Start()&#10;        {&#10;            _healthEvents = GetComponent&lt;IHealthEvents&gt;();&#10;            if (_healthEvents != null)&#10;                _healthEvents.OnDeath += HandleDeath;&#10;        }&#10;        private void OnDisable()&#10;        {&#10;            if (_healthEvents != null)&#10;                _healthEvents.OnDeath -= HandleDeath;&#10;        }&#10;        private void HandleDeath()&#10;        {&#10;            gameObject.SetActive(false);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Core/HealthComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Core/HealthComponent.cs" />
              <option name="originalContent" value="using System;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Core&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HealthComponent : MonoBehaviour, IHealth&#10;    {&#10;        [SerializeField] private int maxHp = 3;&#10;        private bool _isDead;&#10;&#10;        protected void Awake()&#10;        {&#10;            CurrentHp = maxHp;&#10;        }&#10;        public int MaxHp =&gt; maxHp;&#10;        public int CurrentHp { get; private set; }&#10;        public event Action&lt;int, int&gt; OnHealthChanged;&#10;        public event Action OnDeath;&#10;&#10;        public void Damage(int amount, GameObject source = null)&#10;        {&#10;            if (_isDead) return;&#10;            CurrentHp = Mathf.Max(0, CurrentHp - amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;            if (CurrentHp == 0)&#10;            {&#10;                _isDead = true;&#10;                OnDeath?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            if (_isDead) return;&#10;            CurrentHp = Mathf.Min(MaxHp, CurrentHp + amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Core&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HealthComponent : MonoBehaviour, IHealth&#10;    {&#10;        [SerializeField] private int maxHp = 3;&#10;        private bool _isDead;&#10;&#10;        protected void Awake()&#10;        {&#10;            CurrentHp = maxHp;&#10;        }&#10;        public int MaxHp =&gt; maxHp;&#10;        public int CurrentHp { get; private set; }&#10;        public event Action&lt;int, int&gt; OnHealthChanged;&#10;        public event Action OnDeath;&#10;&#10;        public virtual void Damage(int amount, GameObject source = null)&#10;        {&#10;            if (_isDead) return;&#10;            CurrentHp = Mathf.Max(0, CurrentHp - amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;            if (CurrentHp == 0)&#10;            {&#10;                _isDead = true;&#10;                OnDeath?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            if (_isDead) return;&#10;            CurrentHp = Mathf.Min(MaxHp, CurrentHp + amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Health.Interfaces;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class AlwaysAllowDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        public bool CanBeDamagedBy(GameObject damager) =&gt; true;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OnlyProjectileCanDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OnlyProjectileCanDamage.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class OnlyProjectileCanDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        [SerializeField] private LayerMask projectileTag = LayerMask.NameToLayer(&quot;&quot;);&#10;        public bool CanBeDamagedBy(GameObject damager) =&gt; damager.CompareTag(projectileTag);&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class OnlyProjectileCanDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        [SerializeField] private LayerMask projectileLayers = ~0;&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            return ((1 &lt;&lt; damager.layer) &amp; projectileLayers) != 0;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All layers by default&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target))&#10;                return;&#10;&#10;            int amount = _dealer?.GetDamageAmount() ?? 1;&#10;            damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using System.Linq;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class BidirectionalDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject other = collision.gameObject;&#10;            GameObject self = gameObject;&#10;&#10;            // 1. This object damages the other&#10;            TryDealDamage(self, other, _dealer, _damageConditions, targetLayers);&#10;&#10;            // 2. The other object damages this&#10;            var otherDealer = other.GetComponent&lt;IDamageDealer&gt;();&#10;            var otherConditions = other.GetComponent&lt;DamageConditionsComponent&gt;();&#10;            TryDealDamage(other, self, otherDealer, otherConditions, targetLayers);&#10;        }&#10;&#10;        private static void TryDealDamage(&#10;            GameObject dealerObj,&#10;            GameObject targetObj,&#10;            IDamageDealer dealer,&#10;            DamageConditionsComponent conditions,&#10;            LayerMask targetLayers)&#10;        {&#10;            if (dealer == null) return;&#10;            if (((1 &lt;&lt; targetObj.layer) &amp; targetLayers) == 0) return;&#10;            var damageable = targetObj.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (conditions &amp;&amp; !conditions.CanBeDamagedBy(targetObj)) return;&#10;            int amount = dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, dealerObj);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;// This script is now deprecated in favor of TakeDamageOnCollision for most use cases.&#10;// Please use TakeDamageOnCollision on all damageable objects instead." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            foreach (IDamageCondition cond in _conditions)&#10;            {&#10;                if (cond != null &amp;&amp; !cond.CanBeDamagedBy(damager))&#10;                    return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            return _conditions.All(cond =&gt; cond == null || cond.CanBeDamagedBy(damager));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodePropertyDrawer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodePropertyDrawer.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using Health.Damage;&#10;using UnityEditor;&#10;using UnityEngine;&#10;&#10;namespace Health.Editor&#10;{&#10;    [CustomPropertyDrawer(typeof(ConditionNode), true)]&#10;    public class ConditionNodePropertyDrawer : PropertyDrawer&#10;    {&#10;        private static readonly Type[] NodeTypes =&#10;            { typeof(ConditionLeaf), typeof(AndCondition), typeof(OrCondition), typeof(NotCondition) };&#10;&#10;        private static readonly string[] NodeTypeNames = { &quot;Leaf&quot;, &quot;AND&quot;, &quot;OR&quot;, &quot;NOT&quot; };&#10;        private static readonly string[] NodeTypeSymbols = { &quot;●&quot;, &quot;∧&quot;, &quot;∨&quot;, &quot;¬&quot; };&#10;&#10;        // Modern color palette&#10;        private static readonly Color CardColor = new(0.16f, 0.18f, 0.22f, 1f);&#10;        private static readonly Color HeaderColor = new(0.22f, 0.26f, 0.34f, 1f);&#10;        private static readonly Color AccentColor = new(0.36f, 0.78f, 0.93f, 1f);&#10;        private static readonly Color TextColor = new(0.92f, 0.96f, 1f, 1f);&#10;        private static readonly Color BorderColor = new(0.36f, 0.78f, 0.93f, 0.2f);&#10;&#10;        private static GUIStyle _cardStyle;&#10;        private static GUIStyle _headerStyle;&#10;        private static GUIStyle _symbolStyle;&#10;&#10;        private static GUIStyle CardStyle&#10;        {&#10;            get&#10;            {&#10;                if (_cardStyle == null)&#10;                {&#10;                    _cardStyle = new GUIStyle(GUI.skin.box)&#10;                    {&#10;                        margin = new RectOffset(0, 0, 0, 0),&#10;                        padding = new RectOffset(14, 14, 14, 14),&#10;                        border = new RectOffset(12, 12, 12, 12),&#10;                        normal = { background = MakeTex(2, 2, CardColor) }&#10;                    };&#10;                }&#10;                return _cardStyle;&#10;            }&#10;        }&#10;&#10;        private static GUIStyle HeaderStyle&#10;        {&#10;            get&#10;            {&#10;                if (_headerStyle == null)&#10;                {&#10;                    _headerStyle = new GUIStyle(GUI.skin.box)&#10;                    {&#10;                        padding = new RectOffset(10, 10, 6, 6),&#10;                        normal = { background = MakeTex(2, 2, HeaderColor) },&#10;                        alignment = TextAnchor.MiddleLeft,&#10;                        fontStyle = FontStyle.Bold,&#10;                        border = new RectOffset(8, 8, 8, 8)&#10;                    };&#10;                }&#10;                return _headerStyle;&#10;            }&#10;        }&#10;&#10;        private static GUIStyle SymbolStyle&#10;        {&#10;            get&#10;            {&#10;                if (_symbolStyle == null)&#10;                {&#10;                    _symbolStyle = new GUIStyle(EditorStyles.label)&#10;                    {&#10;                        alignment = TextAnchor.MiddleCenter,&#10;                        fontSize = 22,&#10;                        fontStyle = FontStyle.Bold,&#10;                        normal = { textColor = AccentColor }&#10;                    };&#10;                }&#10;                return _symbolStyle;&#10;            }&#10;        }&#10;&#10;        private static readonly GUIStyle AddButtonStyle = new(GUI.skin.button)&#10;        {&#10;            fontStyle = FontStyle.Bold,&#10;            normal = { textColor = TextColor },&#10;            alignment = TextAnchor.MiddleCenter&#10;        };&#10;&#10;        private static readonly GUIStyle DeleteButtonStyle = new(GUI.skin.button)&#10;        {&#10;            fixedWidth = 26,&#10;            fixedHeight = 22,&#10;            alignment = TextAnchor.MiddleCenter,&#10;            fontSize = 14,&#10;            normal = { textColor = Color.red }&#10;        };&#10;&#10;        private static GUIStyle SafeCardStyle =&gt; Event.current != null &amp;&amp; Event.current.type != EventType.Layout ? CardStyle : GUIStyle.none;&#10;        private static GUIStyle SafeHeaderStyle =&gt; Event.current != null &amp;&amp; Event.current.type != EventType.Layout ? HeaderStyle : GUIStyle.none;&#10;        private static GUIStyle SafeSymbolStyle =&gt; Event.current != null &amp;&amp; Event.current.type != EventType.Layout ? SymbolStyle : GUIStyle.none;&#10;&#10;        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)&#10;        {&#10;            if (property?.managedReferenceValue == null)&#10;                return;&#10;&#10;            EditorGUI.BeginProperty(position, label, property);&#10;            float y = position.y;&#10;            DrawNode(ref y, position.x, position.width, property, 0, true);&#10;            EditorGUI.EndProperty();&#10;        }&#10;&#10;        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)&#10;        {&#10;            if (property == null || property.managedReferenceValue == null)&#10;                return EditorGUIUtility.singleLineHeight + 8;&#10;&#10;            // Use a stack to avoid recursion and reduce allocations&#10;            float totalHeight = 0;&#10;            var stack = new Stack&lt;(SerializedProperty prop, int indent)&gt;();&#10;            stack.Push((property, 0));&#10;            while (stack.Count &gt; 0)&#10;            {&#10;                (SerializedProperty prop, int indent) = stack.Pop();&#10;                string nodeType = prop.managedReferenceFullTypename;&#10;                totalHeight += 32f; // headerHeight&#10;                if (nodeType.Contains(&quot;ConditionLeaf&quot;))&#10;                {&#10;                    SerializedProperty condProp = prop.FindPropertyRelative(&quot;conditionBehaviour&quot;);&#10;                    totalHeight += EditorGUI.GetPropertyHeight(condProp, true) + 6;&#10;                }&#10;                else if (nodeType.Contains(&quot;AndCondition&quot;) || nodeType.Contains(&quot;OrCondition&quot;))&#10;                {&#10;                    SerializedProperty childrenProp = prop.FindPropertyRelative(&quot;children&quot;);&#10;                    for (int i = 0; i &lt; childrenProp.arraySize; i++)&#10;                    {&#10;                        SerializedProperty childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                        if (childProp.managedReferenceValue != null)&#10;                            stack.Push((childProp, indent + 1));&#10;&#10;                        totalHeight += 4;&#10;                    }&#10;&#10;                    totalHeight += EditorGUIUtility.singleLineHeight + 10;&#10;                }&#10;                else if (nodeType.Contains(&quot;NotCondition&quot;))&#10;                {&#10;                    SerializedProperty childProp = prop.FindPropertyRelative(&quot;child&quot;);&#10;                    if (childProp.managedReferenceValue == null)&#10;                    {&#10;                        totalHeight += EditorGUIUtility.singleLineHeight + 10;&#10;                    }&#10;                    else&#10;                    {&#10;                        stack.Push((childProp, indent + 1));&#10;                        totalHeight += 4;&#10;                    }&#10;                }&#10;&#10;                totalHeight += 6;&#10;            }&#10;&#10;            return totalHeight;&#10;        }&#10;&#10;        private void DrawNode(ref float y, float x, float width, SerializedProperty property, int indent,&#10;            bool isRoot = false)&#10;        {&#10;            string nodeType = property.managedReferenceFullTypename;&#10;            int typeIdx = Array.FindIndex(NodeTypes, t =&gt; nodeType != null &amp;&amp; nodeType.Contains(t.Name));&#10;            if (typeIdx &lt; 0) typeIdx = 0;&#10;            const float cardPad = 8f;&#10;            const float headerHeight = 32f;&#10;            const float symbolSize = 28f;&#10;            const float spacing = 8f;&#10;            float cardWidth = width - indent * 24 - cardPad * 2;&#10;            float cardX = x + indent * 24 + cardPad;&#10;            float lineHeight = EditorGUIUtility.singleLineHeight;&#10;            // Card background&#10;            float cardHeight = GetNodeHeight(property, indent);&#10;            GUI.Box(new Rect(cardX, y, cardWidth, cardHeight), GUIContent.none, SafeCardStyle);&#10;            // Border&#10;            Color prevColor = GUI.color;&#10;            GUI.color = BorderColor;&#10;            GUI.DrawTexture(new Rect(cardX, y, cardWidth, cardHeight), Texture2D.whiteTexture, ScaleMode.StretchToFill, false);&#10;            GUI.color = prevColor;&#10;            // Header&#10;            Rect headerRect = new(cardX, y, cardWidth, headerHeight);&#10;            GUI.Box(headerRect, GUIContent.none, SafeHeaderStyle);&#10;            // Symbol&#10;            Rect symbolRect = new(cardX + 6, y + 2, symbolSize, symbolSize);&#10;            EditorGUI.LabelField(symbolRect, NodeTypeSymbols[typeIdx], SafeSymbolStyle);&#10;            // Type dropdown&#10;            Rect dropdownRect = new(cardX + symbolSize + spacing, y + 6, 80, lineHeight);&#10;            int newTypeIdx = EditorGUI.Popup(dropdownRect, typeIdx, NodeTypeNames);&#10;            if (newTypeIdx != typeIdx)&#10;            {&#10;                object newNode = Activator.CreateInstance(NodeTypes[newTypeIdx]);&#10;                // --- Preserve children/child when switching node types ---&#10;                SerializedProperty oldChildren = property.FindPropertyRelative(&quot;children&quot;);&#10;                SerializedProperty oldChild = property.FindPropertyRelative(&quot;child&quot;);&#10;                // AND/OR &lt;-&gt; AND/OR: keep all children&#10;                if ((NodeTypeNames[typeIdx] == &quot;AND&quot; || NodeTypeNames[typeIdx] == &quot;OR&quot;) &amp;&amp;&#10;                    (NodeTypeNames[newTypeIdx] == &quot;AND&quot; || NodeTypeNames[newTypeIdx] == &quot;OR&quot;))&#10;                {&#10;                    var list = new List&lt;ConditionNode&gt;();&#10;                    if (oldChildren != null)&#10;                    {&#10;                        for (int i = 0; i &lt; oldChildren.arraySize; i++)&#10;                        {&#10;                            var childProp = oldChildren.GetArrayElementAtIndex(i);&#10;                            if (childProp.managedReferenceValue != null)&#10;                                list.Add((ConditionNode)childProp.managedReferenceValue);&#10;                        }&#10;                    }&#10;                    ((dynamic)newNode).children = list;&#10;                }&#10;                // AND/OR -&gt; NOT: keep first child&#10;                else if ((NodeTypeNames[newTypeIdx] == &quot;NOT&quot;) &amp;&amp; (NodeTypeNames[typeIdx] == &quot;AND&quot; || NodeTypeNames[typeIdx] == &quot;OR&quot;))&#10;                {&#10;                    ConditionNode first = null;&#10;                    if (oldChildren != null)&#10;                    {&#10;                        for (int i = 0; i &lt; oldChildren.arraySize; i++)&#10;                        {&#10;                            var childProp = oldChildren.GetArrayElementAtIndex(i);&#10;                            if (childProp.managedReferenceValue != null)&#10;                            {&#10;                                first = (ConditionNode)childProp.managedReferenceValue;&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                    ((NotCondition)newNode).child = first ?? new ConditionLeaf();&#10;                }&#10;                // NOT -&gt; AND/OR: wrap child in list&#10;                else if ((NodeTypeNames[typeIdx] == &quot;NOT&quot;) &amp;&amp; (NodeTypeNames[newTypeIdx] == &quot;AND&quot; || NodeTypeNames[newTypeIdx] == &quot;OR&quot;))&#10;                {&#10;                    var list = new List&lt;ConditionNode&gt;();&#10;                    if (oldChild != null &amp;&amp; oldChild.managedReferenceValue != null)&#10;                        list.Add((ConditionNode)oldChild.managedReferenceValue);&#10;                    ((dynamic)newNode).children = list;&#10;                }&#10;                // NOT -&gt; NOT: keep child&#10;                else if (NodeTypeNames[newTypeIdx] == &quot;NOT&quot; &amp;&amp; NodeTypeNames[typeIdx] == &quot;NOT&quot;)&#10;                {&#10;                    ((NotCondition)newNode).child = (oldChild != null &amp;&amp; oldChild.managedReferenceValue != null)&#10;                        ? (ConditionNode)oldChild.managedReferenceValue&#10;                        : new ConditionLeaf();&#10;                }&#10;                // LEAF: always new&#10;                property.managedReferenceValue = newNode;&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                GUI.FocusControl(null);&#10;                return;&#10;            }&#10;            // Delete button (not for root)&#10;            if (!isRoot)&#10;            {&#10;                Rect delRect = new(cardX + cardWidth - 32, y + 4, 26, 22);&#10;                if (GUI.Button(delRect, &quot;✕&quot;, DeleteButtonStyle))&#10;                {&#10;                    property.managedReferenceValue = null;&#10;                    property.serializedObject.ApplyModifiedProperties();&#10;                    property.serializedObject.Update();&#10;                    GUI.FocusControl(null);&#10;                    return;&#10;                }&#10;            }&#10;            y += headerHeight;&#10;            // Draw node content&#10;            if (nodeType.Contains(&quot;ConditionLeaf&quot;))&#10;            {&#10;                SerializedProperty condProp = property.FindPropertyRelative(&quot;conditionBehaviour&quot;);&#10;                float condHeight = EditorGUI.GetPropertyHeight(condProp, true);&#10;                EditorGUI.PropertyField(new Rect(cardX + 12, y, cardWidth - 24, condHeight), condProp,&#10;                    new GUIContent(&quot;Condition Behaviour&quot;), true);&#10;                y += condHeight + 6;&#10;            }&#10;            else if (nodeType.Contains(&quot;AndCondition&quot;) || nodeType.Contains(&quot;OrCondition&quot;))&#10;            {&#10;                SerializedProperty childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;                // Draw children&#10;                for (int i = 0; i &lt; childrenProp.arraySize; i++)&#10;                {&#10;                    SerializedProperty childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                    if (childProp.managedReferenceValue == null) continue;&#10;                    DrawNode(ref y, x, width, childProp, indent + 1);&#10;                    y += 4;&#10;                }&#10;                // Add child button&#10;                Rect addRect = new(cardX + 12, y, cardWidth - 24, lineHeight + 4);&#10;                GUI.backgroundColor = AccentColor;&#10;                if (GUI.Button(addRect, &quot;+ Add Child Node&quot;, AddButtonStyle))&#10;                {&#10;                    childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                    SerializedProperty newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                    newChild.managedReferenceValue = new ConditionLeaf();&#10;                    property.serializedObject.ApplyModifiedProperties();&#10;                    property.serializedObject.Update();&#10;                    GUI.FocusControl(null);&#10;                }&#10;                GUI.backgroundColor = Color.white;&#10;                y += lineHeight + 10;&#10;            }&#10;            else if (nodeType.Contains(&quot;NotCondition&quot;))&#10;            {&#10;                SerializedProperty childProp = property.FindPropertyRelative(&quot;child&quot;);&#10;                if (childProp.managedReferenceValue == null)&#10;                {&#10;                    Rect addRect = new(cardX + 12, y, cardWidth - 24, lineHeight + 4);&#10;                    if (GUI.Button(addRect, &quot;+ Add Child Node&quot;, AddButtonStyle))&#10;                    {&#10;                        childProp.managedReferenceValue = new ConditionLeaf();&#10;                        property.serializedObject.ApplyModifiedProperties();&#10;                        property.serializedObject.Update();&#10;                        GUI.FocusControl(null);&#10;                    }&#10;                    y += lineHeight + 10;&#10;                }&#10;                else&#10;                {&#10;                    DrawNode(ref y, x, width, childProp, indent + 1);&#10;                    y += 4;&#10;                }&#10;            }&#10;            y += 6;&#10;        }&#10;&#10;        // Optimized, non-recursive node height calculation&#10;        private float GetNodeHeight(SerializedProperty property, int indent)&#10;        {&#10;            float totalHeight = 0;&#10;            var stack = new Stack&lt;(SerializedProperty prop, int indent)&gt;();&#10;            stack.Push((property, indent));&#10;            while (stack.Count &gt; 0)&#10;            {&#10;                (SerializedProperty prop, _) = stack.Pop();&#10;                string nodeType = prop.managedReferenceFullTypename;&#10;                totalHeight += 32f; // headerHeight&#10;                if (nodeType.Contains(&quot;ConditionLeaf&quot;))&#10;                {&#10;                    SerializedProperty condProp = prop.FindPropertyRelative(&quot;conditionBehaviour&quot;);&#10;                    totalHeight += EditorGUI.GetPropertyHeight(condProp, true) + 6;&#10;                }&#10;                else if (nodeType.Contains(&quot;AndCondition&quot;) || nodeType.Contains(&quot;OrCondition&quot;))&#10;                {&#10;                    SerializedProperty childrenProp = prop.FindPropertyRelative(&quot;children&quot;);&#10;                    for (int i = 0; i &lt; childrenProp.arraySize; i++)&#10;                    {&#10;                        SerializedProperty childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                        if (childProp.managedReferenceValue != null)&#10;                            stack.Push((childProp, indent + 1));&#10;&#10;                        totalHeight += 4;&#10;                    }&#10;&#10;                    totalHeight += EditorGUIUtility.singleLineHeight + 10;&#10;                }&#10;                else if (nodeType.Contains(&quot;NotCondition&quot;))&#10;                {&#10;                    SerializedProperty childProp = prop.FindPropertyRelative(&quot;child&quot;);&#10;                    if (childProp.managedReferenceValue == null)&#10;                    {&#10;                        totalHeight += EditorGUIUtility.singleLineHeight + 10;&#10;                    }&#10;                    else&#10;                    {&#10;                        stack.Push((childProp, indent + 1));&#10;                        totalHeight += 4;&#10;                    }&#10;                }&#10;&#10;                totalHeight += 6;&#10;            }&#10;&#10;            return totalHeight;&#10;        }&#10;&#10;        private static Texture2D MakeTex(int width, int height, Color col)&#10;        {&#10;            var pix = new Color[width * height];&#10;            for (int i = 0; i &lt; pix.Length; ++i)&#10;                pix[i] = col;&#10;&#10;            Texture2D result = new(width, height);&#10;            result.SetPixels(pix);&#10;            result.Apply();&#10;            return result;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using Health.Damage;&#10;using UnityEditor;&#10;using UnityEngine;&#10;&#10;namespace Health.Editor&#10;{&#10;    [CustomPropertyDrawer(typeof(ConditionNode), true)]&#10;    public class ConditionNodePropertyDrawer : PropertyDrawer&#10;    {&#10;        private static readonly Type[] NodeTypes =&#10;            { typeof(ConditionLeaf), typeof(AndCondition), typeof(OrCondition), typeof(NotCondition) };&#10;&#10;        private static readonly string[] NodeTypeNames = { &quot;Leaf&quot;, &quot;AND&quot;, &quot;OR&quot;, &quot;NOT&quot; };&#10;        private static readonly string[] NodeTypeSymbols = { &quot;●&quot;, &quot;∧&quot;, &quot;∨&quot;, &quot;¬&quot; };&#10;&#10;        // Modern color palette&#10;        private static readonly Color CardColor = new(0.16f, 0.18f, 0.22f, 1f);&#10;        private static readonly Color HeaderColor = new(0.22f, 0.26f, 0.34f, 1f);&#10;        private static readonly Color AccentColor = new(0.36f, 0.78f, 0.93f, 1f);&#10;        private static readonly Color TextColor = new(0.92f, 0.96f, 1f, 1f);&#10;        private static readonly Color BorderColor = new(0.36f, 0.78f, 0.93f, 0.2f);&#10;&#10;        private static GUIStyle _cardStyle;&#10;        private static GUIStyle _headerStyle;&#10;        private static GUIStyle _symbolStyle;&#10;&#10;        private static GUIStyle CardStyle&#10;        {&#10;            get&#10;            {&#10;                if (_cardStyle == null)&#10;                {&#10;                    _cardStyle = new GUIStyle(GUI.skin.box)&#10;                    {&#10;                        margin = new RectOffset(0, 0, 0, 0),&#10;                        padding = new RectOffset(14, 14, 14, 14),&#10;                        border = new RectOffset(12, 12, 12, 12),&#10;                        normal = { background = MakeTex(2, 2, CardColor) }&#10;                    };&#10;                }&#10;                return _cardStyle;&#10;            }&#10;        }&#10;&#10;        private static GUIStyle HeaderStyle&#10;        {&#10;            get&#10;            {&#10;                if (_headerStyle == null)&#10;                {&#10;                    _headerStyle = new GUIStyle(GUI.skin.box)&#10;                    {&#10;                        padding = new RectOffset(10, 10, 6, 6),&#10;                        normal = { background = MakeTex(2, 2, HeaderColor) },&#10;                        alignment = TextAnchor.MiddleLeft,&#10;                        fontStyle = FontStyle.Bold,&#10;                        border = new RectOffset(8, 8, 8, 8)&#10;                    };&#10;                }&#10;                return _headerStyle;&#10;            }&#10;        }&#10;&#10;        private static GUIStyle SymbolStyle&#10;        {&#10;            get&#10;            {&#10;                if (_symbolStyle == null)&#10;                {&#10;                    _symbolStyle = new GUIStyle(EditorStyles.label)&#10;                    {&#10;                        alignment = TextAnchor.MiddleCenter,&#10;                        fontSize = 22,&#10;                        fontStyle = FontStyle.Bold,&#10;                        normal = { textColor = AccentColor }&#10;                    };&#10;                }&#10;                return _symbolStyle;&#10;            }&#10;        }&#10;&#10;        private static readonly GUIStyle AddButtonStyle = new(GUI.skin.button)&#10;        {&#10;            fontStyle = FontStyle.Bold,&#10;            normal = { textColor = TextColor },&#10;            alignment = TextAnchor.MiddleCenter&#10;        };&#10;&#10;        private static readonly GUIStyle DeleteButtonStyle = new(GUI.skin.button)&#10;        {&#10;            fixedWidth = 26,&#10;            fixedHeight = 22,&#10;            alignment = TextAnchor.MiddleCenter,&#10;            fontSize = 14,&#10;            normal = { textColor = Color.red }&#10;        };&#10;&#10;        private static GUIStyle SafeCardStyle =&gt; Event.current != null &amp;&amp; Event.current.type != EventType.Layout ? CardStyle : GUIStyle.none;&#10;        private static GUIStyle SafeHeaderStyle =&gt; Event.current != null &amp;&amp; Event.current.type != EventType.Layout ? HeaderStyle : GUIStyle.none;&#10;        private static GUIStyle SafeSymbolStyle =&gt; Event.current != null &amp;&amp; Event.current.type != EventType.Layout ? SymbolStyle : GUIStyle.none;&#10;&#10;        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)&#10;        {&#10;            if (property?.managedReferenceValue == null)&#10;                return;&#10;&#10;            EditorGUI.BeginProperty(position, label, property);&#10;            float y = position.y;&#10;            DrawNode(ref y, position.x, position.width, property, 0, true);&#10;            EditorGUI.EndProperty();&#10;        }&#10;&#10;        public override float GetPropertyHeight(SerializedProperty property, GUIContent label)&#10;        {&#10;            if (property == null || property.managedReferenceValue == null)&#10;                return EditorGUIUtility.singleLineHeight + 8;&#10;&#10;            // Use a stack to avoid recursion and reduce allocations&#10;            float totalHeight = 0;&#10;            var stack = new Stack&lt;(SerializedProperty prop, int indent)&gt;();&#10;            stack.Push((property, 0));&#10;            while (stack.Count &gt; 0)&#10;            {&#10;                (SerializedProperty prop, int indent) = stack.Pop();&#10;                string nodeType = prop.managedReferenceFullTypename;&#10;                totalHeight += 32f; // headerHeight&#10;                if (nodeType.Contains(&quot;ConditionLeaf&quot;))&#10;                {&#10;                    SerializedProperty condProp = prop.FindPropertyRelative(&quot;conditionBehaviour&quot;);&#10;                    totalHeight += EditorGUI.GetPropertyHeight(condProp, true) + 6;&#10;                }&#10;                else if (nodeType.Contains(&quot;AndCondition&quot;) || nodeType.Contains(&quot;OrCondition&quot;))&#10;                {&#10;                    SerializedProperty childrenProp = prop.FindPropertyRelative(&quot;children&quot;);&#10;                    for (int i = 0; i &lt; childrenProp.arraySize; i++)&#10;                    {&#10;                        SerializedProperty childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                        if (childProp.managedReferenceValue != null)&#10;                            stack.Push((childProp, indent + 1));&#10;&#10;                        totalHeight += 4;&#10;                    }&#10;&#10;                    totalHeight += EditorGUIUtility.singleLineHeight + 10;&#10;                }&#10;                else if (nodeType.Contains(&quot;NotCondition&quot;))&#10;                {&#10;                    SerializedProperty childProp = prop.FindPropertyRelative(&quot;child&quot;);&#10;                    if (childProp.managedReferenceValue == null)&#10;                    {&#10;                        totalHeight += EditorGUIUtility.singleLineHeight + 10;&#10;                    }&#10;                    else&#10;                    {&#10;                        stack.Push((childProp, indent + 1));&#10;                        totalHeight += 4;&#10;                    }&#10;                }&#10;&#10;                totalHeight += 6;&#10;            }&#10;&#10;            return totalHeight;&#10;        }&#10;&#10;        private void DrawNode(ref float y, float x, float width, SerializedProperty property, int indent,&#10;            bool isRoot = false)&#10;        {&#10;            string nodeType = property.managedReferenceFullTypename;&#10;            int typeIdx = Array.FindIndex(NodeTypes, t =&gt; nodeType != null &amp;&amp; nodeType.Contains(t.Name));&#10;            if (typeIdx &lt; 0) typeIdx = 0;&#10;            const float cardPad = 8f;&#10;            const float headerHeight = 32f;&#10;            const float symbolSize = 28f;&#10;            const float spacing = 8f;&#10;            float cardWidth = width - indent * 24 - cardPad * 2;&#10;            float cardX = x + indent * 24 + cardPad;&#10;            float lineHeight = EditorGUIUtility.singleLineHeight;&#10;            // Card background&#10;            float cardHeight = GetNodeHeight(property, indent);&#10;            GUI.Box(new Rect(cardX, y, cardWidth, cardHeight), GUIContent.none, SafeCardStyle);&#10;            // True border (2px)&#10;            if (Event.current != null &amp;&amp; Event.current.type != EventType.Layout)&#10;            {&#10;                Color prevColor = GUI.color;&#10;                GUI.color = BorderColor;&#10;                float borderWidth = 2f;&#10;                // Top&#10;                GUI.DrawTexture(new Rect(cardX, y, cardWidth, borderWidth), Texture2D.whiteTexture);&#10;                // Bottom&#10;                GUI.DrawTexture(new Rect(cardX, y + cardHeight - borderWidth, cardWidth, borderWidth), Texture2D.whiteTexture);&#10;                // Left&#10;                GUI.DrawTexture(new Rect(cardX, y, borderWidth, cardHeight), Texture2D.whiteTexture);&#10;                // Right&#10;                GUI.DrawTexture(new Rect(cardX + cardWidth - borderWidth, y, borderWidth, cardHeight), Texture2D.whiteTexture);&#10;                GUI.color = prevColor;&#10;            }&#10;            // Header&#10;            Rect headerRect = new(cardX, y, cardWidth, headerHeight);&#10;            GUI.Box(headerRect, GUIContent.none, SafeHeaderStyle);&#10;            // Symbol&#10;            Rect symbolRect = new(cardX + 6, y + 2, symbolSize, symbolSize);&#10;            EditorGUI.LabelField(symbolRect, NodeTypeSymbols[typeIdx], SafeSymbolStyle);&#10;            // Type dropdown&#10;            Rect dropdownRect = new(cardX + symbolSize + spacing, y + 6, 80, lineHeight);&#10;            int newTypeIdx = EditorGUI.Popup(dropdownRect, typeIdx, NodeTypeNames);&#10;            if (newTypeIdx != typeIdx)&#10;            {&#10;                object newNode = Activator.CreateInstance(NodeTypes[newTypeIdx]);&#10;                // --- Preserve children/child when switching node types ---&#10;                SerializedProperty oldChildren = property.FindPropertyRelative(&quot;children&quot;);&#10;                SerializedProperty oldChild = property.FindPropertyRelative(&quot;child&quot;);&#10;                // AND/OR &lt;-&gt; AND/OR: keep all children&#10;                if ((NodeTypeNames[typeIdx] == &quot;AND&quot; || NodeTypeNames[typeIdx] == &quot;OR&quot;) &amp;&amp;&#10;                    (NodeTypeNames[newTypeIdx] == &quot;AND&quot; || NodeTypeNames[newTypeIdx] == &quot;OR&quot;))&#10;                {&#10;                    var list = new List&lt;ConditionNode&gt;();&#10;                    if (oldChildren != null)&#10;                    {&#10;                        for (int i = 0; i &lt; oldChildren.arraySize; i++)&#10;                        {&#10;                            var childProp = oldChildren.GetArrayElementAtIndex(i);&#10;                            if (childProp.managedReferenceValue != null)&#10;                                list.Add((ConditionNode)childProp.managedReferenceValue);&#10;                        }&#10;                    }&#10;                    ((dynamic)newNode).children = list;&#10;                }&#10;                // AND/OR -&gt; NOT: keep first child&#10;                else if ((NodeTypeNames[newTypeIdx] == &quot;NOT&quot;) &amp;&amp; (NodeTypeNames[typeIdx] == &quot;AND&quot; || NodeTypeNames[typeIdx] == &quot;OR&quot;))&#10;                {&#10;                    ConditionNode first = null;&#10;                    if (oldChildren != null)&#10;                    {&#10;                        for (int i = 0; i &lt; oldChildren.arraySize; i++)&#10;                        {&#10;                            var childProp = oldChildren.GetArrayElementAtIndex(i);&#10;                            if (childProp.managedReferenceValue != null)&#10;                            {&#10;                                first = (ConditionNode)childProp.managedReferenceValue;&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                    ((NotCondition)newNode).child = first ?? new ConditionLeaf();&#10;                }&#10;                // NOT -&gt; AND/OR: wrap child in list&#10;                else if ((NodeTypeNames[typeIdx] == &quot;NOT&quot;) &amp;&amp; (NodeTypeNames[newTypeIdx] == &quot;AND&quot; || NodeTypeNames[newTypeIdx] == &quot;OR&quot;))&#10;                {&#10;                    var list = new List&lt;ConditionNode&gt;();&#10;                    if (oldChild != null &amp;&amp; oldChild.managedReferenceValue != null)&#10;                        list.Add((ConditionNode)oldChild.managedReferenceValue);&#10;                    ((dynamic)newNode).children = list;&#10;                }&#10;                // NOT -&gt; NOT: keep child&#10;                else if (NodeTypeNames[newTypeIdx] == &quot;NOT&quot; &amp;&amp; NodeTypeNames[typeIdx] == &quot;NOT&quot;)&#10;                {&#10;                    ((NotCondition)newNode).child = (oldChild != null &amp;&amp; oldChild.managedReferenceValue != null)&#10;                        ? (ConditionNode)oldChild.managedReferenceValue&#10;                        : new ConditionLeaf();&#10;                }&#10;                // LEAF: always new&#10;                property.managedReferenceValue = newNode;&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                GUI.FocusControl(null);&#10;                return;&#10;            }&#10;            // Delete button (not for root)&#10;            if (!isRoot)&#10;            {&#10;                Rect delRect = new(cardX + cardWidth - 32, y + 4, 26, 22);&#10;                if (GUI.Button(delRect, &quot;✕&quot;, DeleteButtonStyle))&#10;                {&#10;                    property.managedReferenceValue = null;&#10;                    property.serializedObject.ApplyModifiedProperties();&#10;                    property.serializedObject.Update();&#10;                    GUI.FocusControl(null);&#10;                    return;&#10;                }&#10;            }&#10;            y += headerHeight;&#10;            // Draw node content&#10;            if (nodeType.Contains(&quot;ConditionLeaf&quot;))&#10;            {&#10;                SerializedProperty condProp = property.FindPropertyRelative(&quot;conditionBehaviour&quot;);&#10;                float condHeight = EditorGUI.GetPropertyHeight(condProp, true);&#10;                EditorGUI.PropertyField(new Rect(cardX + 12, y, cardWidth - 24, condHeight), condProp,&#10;                    new GUIContent(&quot;Condition Behaviour&quot;), true);&#10;                y += condHeight + 6;&#10;            }&#10;            else if (nodeType.Contains(&quot;AndCondition&quot;) || nodeType.Contains(&quot;OrCondition&quot;))&#10;            {&#10;                SerializedProperty childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;                // Draw children&#10;                for (int i = 0; i &lt; childrenProp.arraySize; i++)&#10;                {&#10;                    SerializedProperty childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                    if (childProp.managedReferenceValue == null) continue;&#10;                    DrawNode(ref y, x, width, childProp, indent + 1);&#10;                    y += 4;&#10;                }&#10;                // Add child button&#10;                Rect addRect = new(cardX + 12, y, cardWidth - 24, lineHeight + 4);&#10;                GUI.backgroundColor = AccentColor;&#10;                if (GUI.Button(addRect, &quot;+ Add Child Node&quot;, AddButtonStyle))&#10;                {&#10;                    childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                    SerializedProperty newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                    newChild.managedReferenceValue = new ConditionLeaf();&#10;                    property.serializedObject.ApplyModifiedProperties();&#10;                    property.serializedObject.Update();&#10;                    GUI.FocusControl(null);&#10;                }&#10;                GUI.backgroundColor = Color.white;&#10;                y += lineHeight + 10;&#10;            }&#10;            else if (nodeType.Contains(&quot;NotCondition&quot;))&#10;            {&#10;                SerializedProperty childProp = property.FindPropertyRelative(&quot;child&quot;);&#10;                if (childProp.managedReferenceValue == null)&#10;                {&#10;                    Rect addRect = new(cardX + 12, y, cardWidth - 24, lineHeight + 4);&#10;                    if (GUI.Button(addRect, &quot;+ Add Child Node&quot;, AddButtonStyle))&#10;                    {&#10;                        childProp.managedReferenceValue = new ConditionLeaf();&#10;                        property.serializedObject.ApplyModifiedProperties();&#10;                        property.serializedObject.Update();&#10;                        GUI.FocusControl(null);&#10;                    }&#10;                    y += lineHeight + 10;&#10;                }&#10;                else&#10;                {&#10;                    DrawNode(ref y, x, width, childProp, indent + 1);&#10;                    y += 4;&#10;                }&#10;            }&#10;            y += 6;&#10;        }&#10;&#10;        // Optimized, non-recursive node height calculation&#10;        private float GetNodeHeight(SerializedProperty property, int indent)&#10;        {&#10;            float totalHeight = 0;&#10;            var stack = new Stack&lt;(SerializedProperty prop, int indent)&gt;();&#10;            stack.Push((property, indent));&#10;            while (stack.Count &gt; 0)&#10;            {&#10;                (SerializedProperty prop, _) = stack.Pop();&#10;                string nodeType = prop.managedReferenceFullTypename;&#10;                totalHeight += 32f; // headerHeight&#10;                if (nodeType.Contains(&quot;ConditionLeaf&quot;))&#10;                {&#10;                    SerializedProperty condProp = prop.FindPropertyRelative(&quot;conditionBehaviour&quot;);&#10;                    totalHeight += EditorGUI.GetPropertyHeight(condProp, true) + 6;&#10;                }&#10;                else if (nodeType.Contains(&quot;AndCondition&quot;) || nodeType.Contains(&quot;OrCondition&quot;))&#10;                {&#10;                    SerializedProperty childrenProp = prop.FindPropertyRelative(&quot;children&quot;);&#10;                    for (int i = 0; i &lt; childrenProp.arraySize; i++)&#10;                    {&#10;                        SerializedProperty childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                        if (childProp.managedReferenceValue != null)&#10;                            stack.Push((childProp, indent + 1));&#10;&#10;                        totalHeight += 4;&#10;                    }&#10;&#10;                    totalHeight += EditorGUIUtility.singleLineHeight + 10;&#10;                }&#10;                else if (nodeType.Contains(&quot;NotCondition&quot;))&#10;                {&#10;                    SerializedProperty childProp = prop.FindPropertyRelative(&quot;child&quot;);&#10;                    if (childProp.managedReferenceValue == null)&#10;                    {&#10;                        totalHeight += EditorGUIUtility.singleLineHeight + 10;&#10;                    }&#10;                    else&#10;                    {&#10;                        stack.Push((childProp, indent + 1));&#10;                        totalHeight += 4;&#10;                    }&#10;                }&#10;&#10;                totalHeight += 6;&#10;            }&#10;&#10;            return totalHeight;&#10;        }&#10;&#10;        private static Texture2D MakeTex(int width, int height, Color col)&#10;        {&#10;            var pix = new Color[width * height];&#10;            for (int i = 0; i &lt; pix.Length; ++i)&#10;                pix[i] = col;&#10;&#10;            Texture2D result = new(width, height);&#10;            result.SetPixels(pix);&#10;            result.Apply();&#10;            return result;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs" />
              <option name="originalContent" value="using Health.Damage;&#10;using UnityEditor;&#10;using UnityEngine;&#10;&#10;[CustomPropertyDrawer(typeof(ConditionLeaf))]&#10;public class ConditionLeafPropertyDrawer : ConditionNodePropertyDrawer {}&#10;&#10;[CustomPropertyDrawer(typeof(AndCondition))]&#10;public class AndConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;AND Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(OrCondition))]&#10;public class OrConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;OR Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(NotCondition))]&#10;public class NotConditionPropertyDrawer : ConditionNodePropertyDrawer {}&#10;" />
              <option name="updatedContent" value="// All custom property drawers for node types are now handled by ConditionNodePropertyDrawer.&#10;// This file is no longer needed and can be deleted, or you can leave it empty." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Invincibility/InvincibilityComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Invincibility/InvincibilityComponent.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Invincibility&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class InvincibilityComponent : MonoBehaviour, IInvincibility&#10;    {&#10;        public bool IsInvincible { get; private set; }&#10;        public void SetInvincible(bool value)&#10;        {&#10;            IsInvincible = value;&#10;        }&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Invincibility&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class InvincibilityComponent : MonoBehaviour, IInvincibility, IDamageDealer&#10;    {&#10;        public bool IsInvincible { get; private set; }&#10;        public void SetInvincible(bool value)&#10;        {&#10;            IsInvincible = value;&#10;        }&#10;&#10;        public int GetDamageAmount() =&gt; IsInvincible ? 9999 : 0;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/README.md" />
              <option name="updatedContent" value="// Health/README.md&#10;&#10;# Health System Setup Guide&#10;&#10;## Folder Structure&#10;- `Core/` – Health logic&#10;- `Interfaces/` – All interfaces&#10;- `Shield/` – Shield logic&#10;- `Invincibility/` – Invincibility logic&#10;- `Damage/` – Damage logic and conditions&#10;&#10;## How to Compose Entities in Unity Editor&#10;&#10;### Player (Basic)&#10;- Add `HealthComponent` (Core)&#10;&#10;### Player with Shield&#10;- Add `HealthComponent` (Core)&#10;- Add `ShieldComponent` (Shield)&#10;&#10;### Player with Invincibility&#10;- Add `HealthComponent` (Core)&#10;- Add `InvincibilityComponent` (Invincibility)&#10;- Connect to your `IPowerUp` system to toggle invincibility&#10;&#10;### Enemy&#10;- Add `HealthComponent` (Core)&#10;&#10;### Hazard (Standard)&#10;- Add `HazardComponent` (Damage)&#10;- Add `DamageDealerComponent` (Damage)&#10;- Add a damage condition (e.g., `AlwaysAllowDamage`, `OnlyInvincibleCanDamage`, `OnlyShieldedCanDamage`) as needed&#10;- Assign the condition(s) to the `HazardComponent`'s `damageConditions` array in the Inspector&#10;&#10;### Custom Damage Conditions&#10;- Create a new MonoBehaviour implementing `IDamageCondition`&#10;- Add it to the hazard GameObject&#10;- Assign it in the `HazardComponent`&#10;&#10;## Extending&#10;- To add new damage conditions, create a new script implementing `IDamageCondition` and add it in the Editor. No need to modify existing code.&#10;&#10;## Events&#10;- Use UnityEvents or C# events on components for custom reactions (e.g., OnDeath, OnShieldBroken)&#10;&#10;## Cleanup&#10;- Remove old scripts like `ShieldActiveDisappearHazard`, `OnlyInvincibilityDamageController`, etc. after migration.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// When enabled, instantly kills any damageable object the player collides with.&#10;    /// Should be enabled only when the player is invincible.&#10;    /// &lt;/summary&gt;&#10;    [DisallowMultipleComponent]&#10;    public class PlayerInvincibleDamageDealer : MonoBehaviour, IDamageDealer&#10;    {&#10;        [SerializeField] private int damageAmount = 9999; // &quot;Kill&quot; value&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All by default&#10;&#10;        public int GetDamageAmount() =&gt; damageAmount;&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if (((1 &lt;&lt; collision.gameObject.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            var damageable = collision.gameObject.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable != null)&#10;            {&#10;                damageable.Damage(damageAmount, gameObject);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/AxeWeapon.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/AxeWeapon.cs" />
              <option name="originalContent" value="using System;&#10;using Projectiles;&#10;using UnityEngine;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class AxeWeapon : MonoBehaviour, IUseableWeapon&#10;    {&#10;        [SerializeField] private GameObject axe;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.5f;&#10;        [SerializeField] private AxePool axePool;&#10;        private float _nextFireTime;&#10;&#10;        [NonSerialized] private Rigidbody2D _throwerRb;&#10;&#10;        public bool IsEquipped { get; private set; }&#10;&#10;        private void Awake()&#10;        {&#10;            _throwerRb = GetComponentInParent&lt;Rigidbody2D&gt;();&#10;        }&#10;        public WeaponType WeaponType =&gt; WeaponType.Axe;&#10;        public void Shoot()&#10;        {&#10;            // Check if weapon is equipped&#10;            if (!IsEquipped)&#10;            {&#10;                return;&#10;            }&#10;&#10;            // Check cooldown&#10;            if (Time.time &lt; _nextFireTime)&#10;            {&#10;                return;&#10;            }&#10;&#10;            // Check axe prefab&#10;            if (!axe)&#10;            {&#10;                return;&#10;            }&#10;&#10;            GameObject curAxe = axePool.Get();&#10;            Vector3 spawnPosition = spawnPoint ? spawnPoint.position : transform.position;&#10;            curAxe.transform.position = spawnPosition;&#10;            curAxe.transform.rotation = Quaternion.identity;&#10;&#10;            if (curAxe.TryGetComponent(out ProjectileAxe scAxe))&#10;            {&#10;                curAxe.layer = gameObject.layer;&#10;&#10;                float direction = transform.parent?.localScale.x ?? 1;&#10;                scAxe.Direction = direction;&#10;                scAxe.ThrowerVelocityX = _throwerRb.linearVelocityX;&#10;&#10;                scAxe.Fire();&#10;&#10;                // Set cooldown&#10;                _nextFireTime = Time.time + cooldownTime;&#10;            }&#10;        }&#10;&#10;        public void Equip()&#10;        {&#10;            IsEquipped = true;&#10;        }&#10;&#10;        public void UnEquip()&#10;        {&#10;            IsEquipped = false;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using Projectiles;&#10;using UnityEngine;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class AxeWeapon : MonoBehaviour, IUseableWeapon&#10;    {&#10;        [SerializeField] private GameObject axe;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.5f;&#10;        [SerializeField] private AxePool axePool;&#10;        private float _nextFireTime;&#10;&#10;        [NonSerialized] private Rigidbody2D _throwerRb;&#10;&#10;        public bool IsEquipped { get; private set; }&#10;&#10;        private void Awake()&#10;        {&#10;            _throwerRb = GetComponentInParent&lt;Rigidbody2D&gt;();&#10;        }&#10;        public WeaponType WeaponType =&gt; WeaponType.Axe;&#10;        public void Shoot()&#10;        {&#10;            // Check if weapon is equipped&#10;            if (!IsEquipped)&#10;            {&#10;                return;&#10;            }&#10;&#10;            // Check cooldown&#10;            if (Time.time &lt; _nextFireTime)&#10;            {&#10;                return;&#10;            }&#10;&#10;            // Check axe prefab&#10;            if (!axe)&#10;            {&#10;                return;&#10;            }&#10;&#10;            GameObject curAxe = axePool.Get();&#10;            Vector3 spawnPosition = spawnPoint ? spawnPoint.position : transform.position;&#10;            curAxe.transform.position = spawnPosition;&#10;            curAxe.transform.rotation = Quaternion.identity;&#10;&#10;            if (curAxe.TryGetComponent(out ProjectileAxe scAxe))&#10;            {&#10;                curAxe.layer = gameObject.layer;&#10;&#10;                float direction = transform.parent?.localScale.x ?? 1;&#10;                scAxe.Direction = direction;&#10;                scAxe.ThrowerVelocityX = _throwerRb.linearVelocityX;&#10;&#10;                scAxe.Fire();&#10;&#10;                // Set cooldown&#10;                _nextFireTime = Time.time + cooldownTime;&#10;            }&#10;        }&#10;&#10;        public void Equip()&#10;        {&#10;            IsEquipped = true;&#10;        }&#10;&#10;        public void UnEquip()&#10;        {&#10;            IsEquipped = false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/BoomerangWeapon.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/BoomerangWeapon.cs" />
              <option name="originalContent" value="using System;&#10;using Projectiles;&#10;using UnityEngine;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class BoomerangWeapon : MonoBehaviour, IAmmoWeapon&#10;    {&#10;        [SerializeField] private GameObject boomerang;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.3f;&#10;&#10;        private float _nextFireTime;&#10;&#10;        private GameObject _pooledBoomerang;&#10;        private ProjectileBoomerang _pooledProjectile;&#10;        private Transform _returnToTransform;&#10;&#10;        private void Start()&#10;        {&#10;            _returnToTransform = transform.parent;&#10;&#10;            if (!boomerang)&#10;                return;&#10;&#10;            Transform spawnParent = spawnPoint ? spawnPoint : transform;&#10;            _pooledBoomerang = Instantiate(boomerang, spawnParent.position, Quaternion.identity, spawnParent);&#10;            _pooledProjectile = _pooledBoomerang.GetComponent&lt;ProjectileBoomerang&gt;();&#10;            _pooledBoomerang.SetActive(false);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (_pooledProjectile)&#10;                _pooledProjectile.OnBoomerangReturned -= OnBoomerangReturned;&#10;&#10;            if (_pooledBoomerang)&#10;                Destroy(_pooledBoomerang);&#10;        }&#10;        public WeaponType WeaponType =&gt; WeaponType.Boomerang;&#10;&#10;        public int CurrentAmmo { get; private set; } = 1;&#10;        public int MaxAmmo =&gt; 1;&#10;        public bool HasAmmo =&gt; CurrentAmmo &gt; 0;&#10;&#10;        public void SetAmmo(int ammo)&#10;        {&#10;            int old = CurrentAmmo;&#10;            CurrentAmmo = Mathf.Clamp(ammo, 0, MaxAmmo);&#10;            if (old != CurrentAmmo)&#10;                OnAmmoChanged?.Invoke(CurrentAmmo);&#10;        }&#10;&#10;        public void Shoot()&#10;        {&#10;            if (Time.time &lt; _nextFireTime || !HasAmmo || !_pooledBoomerang || _pooledBoomerang.activeSelf)&#10;                return;&#10;&#10;            _pooledBoomerang.transform.SetPositionAndRotation(&#10;                spawnPoint ? spawnPoint.position : transform.position,&#10;                Quaternion.identity&#10;            );&#10;&#10;            _pooledBoomerang.layer = gameObject.layer;&#10;&#10;            SetAmmo(0);&#10;&#10;            float dir = transform.parent?.localScale.x ?? 1;&#10;            _pooledProjectile.Direction = dir;&#10;            _pooledProjectile.PlayerTransform = _returnToTransform;&#10;            _pooledProjectile.OnBoomerangReturned += OnBoomerangReturned;&#10;&#10;            _pooledBoomerang.SetActive(true);&#10;            _pooledProjectile.Fire();&#10;&#10;            _nextFireTime = Time.time + cooldownTime;&#10;        }&#10;&#10;        public void Reload()&#10;        {&#10;            SetAmmo(1);&#10;        }&#10;        public event Action&lt;int&gt; OnAmmoChanged;&#10;&#10;        private void OnBoomerangReturned()&#10;        {&#10;            _pooledProjectile.OnBoomerangReturned -= OnBoomerangReturned;&#10;            _pooledBoomerang.SetActive(false);&#10;            SetAmmo(1);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using Projectiles;&#10;using UnityEngine;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class BoomerangWeapon : MonoBehaviour, IAmmoWeapon&#10;    {&#10;        [SerializeField] private GameObject boomerang;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.3f;&#10;&#10;        private float _nextFireTime;&#10;&#10;        private GameObject _pooledBoomerang;&#10;        private ProjectileBoomerang _pooledProjectile;&#10;        private Transform _returnToTransform;&#10;&#10;        private void Start()&#10;        {&#10;            _returnToTransform = transform.parent;&#10;&#10;            if (!boomerang)&#10;                return;&#10;&#10;            Transform spawnParent = spawnPoint ? spawnPoint : transform;&#10;            _pooledBoomerang = Instantiate(boomerang, spawnParent.position, Quaternion.identity, spawnParent);&#10;            _pooledProjectile = _pooledBoomerang.GetComponent&lt;ProjectileBoomerang&gt;();&#10;            _pooledBoomerang.SetActive(false);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (_pooledProjectile)&#10;                _pooledProjectile.OnBoomerangReturned -= OnBoomerangReturned;&#10;&#10;            if (_pooledBoomerang)&#10;                Destroy(_pooledBoomerang);&#10;        }&#10;        public WeaponType WeaponType =&gt; WeaponType.Boomerang;&#10;&#10;        public int CurrentAmmo { get; private set; } = 1;&#10;        public int MaxAmmo =&gt; 1;&#10;        public bool HasAmmo =&gt; CurrentAmmo &gt; 0;&#10;&#10;        public void SetAmmo(int ammo)&#10;        {&#10;            int old = CurrentAmmo;&#10;            CurrentAmmo = Mathf.Clamp(ammo, 0, MaxAmmo);&#10;            if (old != CurrentAmmo)&#10;                OnAmmoChanged?.Invoke(CurrentAmmo);&#10;        }&#10;&#10;        public void Shoot()&#10;        {&#10;            if (Time.time &lt; _nextFireTime || !HasAmmo || !_pooledBoomerang || _pooledBoomerang.activeSelf)&#10;                return;&#10;&#10;            _pooledBoomerang.transform.SetPositionAndRotation(&#10;                spawnPoint ? spawnPoint.position : transform.position,&#10;                Quaternion.identity&#10;            );&#10;&#10;            _pooledBoomerang.layer = gameObject.layer;&#10;&#10;            SetAmmo(0);&#10;&#10;            float dir = transform.parent?.localScale.x ?? 1;&#10;            _pooledProjectile.Direction = dir;&#10;            _pooledProjectile.PlayerTransform = _returnToTransform;&#10;            _pooledProjectile.OnBoomerangReturned += OnBoomerangReturned;&#10;&#10;            _pooledBoomerang.SetActive(true);&#10;            _pooledProjectile.Fire();&#10;&#10;            _nextFireTime = Time.time + cooldownTime;&#10;        }&#10;&#10;        public void Reload()&#10;        {&#10;            SetAmmo(1);&#10;        }&#10;        public event Action&lt;int&gt; OnAmmoChanged;&#10;&#10;        private void OnBoomerangReturned()&#10;        {&#10;            _pooledProjectile.OnBoomerangReturned -= OnBoomerangReturned;&#10;            _pooledBoomerang.SetActive(false);&#10;            SetAmmo(1);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/FireballWeapon.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/FireballWeapon.cs" />
              <option name="originalContent" value="using Projectiles;&#10;using UnityEngine;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class FireballWeapon : MonoBehaviour, IUseableWeapon&#10;    {&#10;        [SerializeField] private WeaponType weaponType = WeaponType.Fireball;&#10;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.3f;&#10;        [SerializeField] private FireballPool fireballPool;&#10;&#10;        private float _nextFireTime;&#10;&#10;        public bool IsEquipped { get; private set; }&#10;        public WeaponType WeaponType =&gt; weaponType;&#10;&#10;        public void Shoot()&#10;        {&#10;            // Check if weapon is equipped&#10;            if (!IsEquipped)&#10;                return;&#10;&#10;            // Check cooldown&#10;            if (Time.time &lt; _nextFireTime)&#10;                return;&#10;&#10;            GameObject curFireball = fireballPool.Get();&#10;            Vector3 spawnPosition = spawnPoint ? spawnPoint.position : transform.position;&#10;            curFireball.transform.position = spawnPosition;&#10;            curFireball.transform.rotation = Quaternion.identity;&#10;&#10;            if (curFireball.TryGetComponent(out ProjectileFireball scFireball))&#10;            {&#10;                curFireball.layer = gameObject.layer;&#10;                float direction = transform.parent?.localScale.x ?? 1;&#10;                scFireball.Direction = direction;&#10;                scFireball.Fire();&#10;&#10;                // Set cooldown&#10;                _nextFireTime = Time.time + cooldownTime;&#10;            }&#10;        }&#10;&#10;        public void Equip()&#10;        {&#10;            IsEquipped = true;&#10;        }&#10;&#10;        public void UnEquip()&#10;        {&#10;            IsEquipped = false;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Projectiles;&#10;using UnityEngine;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class FireballWeapon : MonoBehaviour, IUseableWeapon&#10;    {&#10;        [SerializeField] private WeaponType weaponType = WeaponType.Fireball;&#10;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.3f;&#10;        [SerializeField] private FireballPool fireballPool;&#10;&#10;        private float _nextFireTime;&#10;&#10;        public bool IsEquipped { get; private set; }&#10;        public WeaponType WeaponType =&gt; weaponType;&#10;&#10;        public void Shoot()&#10;        {&#10;            // Check if weapon is equipped&#10;            if (!IsEquipped)&#10;                return;&#10;&#10;            // Check cooldown&#10;            if (Time.time &lt; _nextFireTime)&#10;                return;&#10;&#10;            GameObject curFireball = fireballPool.Get();&#10;            Vector3 spawnPosition = spawnPoint ? spawnPoint.position : transform.position;&#10;            curFireball.transform.position = spawnPosition;&#10;            curFireball.transform.rotation = Quaternion.identity;&#10;&#10;            if (curFireball.TryGetComponent(out ProjectileFireball scFireball))&#10;            {&#10;                curFireball.layer = gameObject.layer;&#10;                float direction = transform.parent?.localScale.x ?? 1;&#10;                scFireball.Direction = direction;&#10;                scFireball.Fire();&#10;&#10;                // Set cooldown&#10;                _nextFireTime = Time.time + cooldownTime;&#10;            }&#10;        }&#10;&#10;        public void Equip()&#10;        {&#10;            IsEquipped = true;&#10;        }&#10;&#10;        public void UnEquip()&#10;        {&#10;            IsEquipped = false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>