<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Editor/SpriteMergerEditor.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Editor/SpriteMergerEditor.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.IO;&#10;using System.Linq;&#10;using UnityEditor;&#10;using UnityEditor.SceneManagement;&#10;using UnityEditor.U2D.Sprites;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using Object = UnityEngine.Object;&#10;&#10;// REQUIRED: The &quot;2D Sprite&quot; package must be installed via the Package Manager for this to compile.&#10;&#10;namespace Editor&#10;{&#10;    public class SpriteMergerEditor : EditorWindow&#10;    {&#10;&#10;        // Undo tracking&#10;        private static readonly string UndoGroupName = &quot;Sprite Atlas Merge&quot;;&#10;        private static readonly Dictionary&lt;Object, Object&gt; OriginalReferences = new();&#10;        [SerializeField] private List&lt;string&gt; createdAssetPaths = new();&#10;        [SerializeField] private string outputFileName = &quot;MergedSpriteAtlas&quot;;&#10;        private readonly List&lt;Sprite&gt; _spritesToMerge = new();&#10;        private FilterMode _filterMode = FilterMode.Point;&#10;        private bool _makeBackup = true;&#10;        private int _maxAtlasSize = 4096;&#10;        private int _padding = 2;&#10;        private Vector2 _scrollPosition;&#10;        private TextureFormat _textureFormat = TextureFormat.RGBA32;&#10;        private bool _updatePrefabs = true;&#10;        private bool _updateScenes = true;&#10;        private bool _updateScriptableObjects = true;&#10;&#10;        private void OnGUI()&#10;        {&#10;            GUILayout.Label(&quot;Sprite Atlas Merger&quot;, EditorStyles.boldLabel);&#10;            EditorGUILayout.HelpBox(&#10;                &quot;Merge multiple sprite sheets into a single atlas and update ALL project references automatically.&quot;,&#10;                MessageType.Info);&#10;&#10;            EditorGUILayout.HelpBox(&quot;IMPORTANT: This tool requires the '2D Sprite' package. Make backups before use!&quot;,&#10;                MessageType.Warning);&#10;&#10;            DrawSpriteList();&#10;            DrawOutputSettings();&#10;            DrawUpdateOptions();&#10;            DrawMergeButton();&#10;        }&#10;&#10;        [MenuItem(&quot;Tools/Sprite Atlas Merger&quot;)]&#10;        public static void ShowWindow()&#10;        {&#10;            GetWindow&lt;SpriteMergerEditor&gt;(&quot;Atlas Merger&quot;);&#10;        }&#10;&#10;        private void DrawSpriteList()&#10;        {&#10;            EditorGUILayout.BeginVertical(EditorStyles.helpBox);&#10;            GUILayout.Label($&quot;Sprites to Merge ({_spritesToMerge.Count})&quot;, EditorStyles.centeredGreyMiniLabel);&#10;&#10;            // Drag and drop area&#10;            Rect dropArea = GUILayoutUtility.GetRect(0.0f, 60.0f, GUILayout.ExpandWidth(true));&#10;            GUI.Box(dropArea, &quot;Drag &amp; Drop Sprites or Textures Here\n(Individual sprites or entire sprite sheets)&quot;,&#10;                EditorStyles.helpBox);&#10;&#10;            ProcessDragAndDrop(dropArea);&#10;&#10;            // Sprite list with scroll view&#10;            _scrollPosition = EditorGUILayout.BeginScrollView(_scrollPosition, GUILayout.Height(200));&#10;            for (int i = _spritesToMerge.Count - 1; i &gt;= 0; i--)&#10;            {&#10;                if (_spritesToMerge[i] == null)&#10;                {&#10;                    _spritesToMerge.RemoveAt(i);&#10;                    continue;&#10;                }&#10;&#10;                EditorGUILayout.BeginHorizontal();&#10;                _spritesToMerge[i] = (Sprite)EditorGUILayout.ObjectField(_spritesToMerge[i], typeof(Sprite), false);&#10;&#10;                // Show source texture info&#10;                if (_spritesToMerge[i] != null)&#10;                {&#10;                    GUILayout.Label($&quot;[{_spritesToMerge[i].texture.name}]&quot;, EditorStyles.miniLabel,&#10;                        GUILayout.Width(100));&#10;                }&#10;&#10;                if (GUILayout.Button(&quot;Remove&quot;, GUILayout.Width(60)))&#10;                {&#10;                    _spritesToMerge.RemoveAt(i);&#10;                }&#10;&#10;                EditorGUILayout.EndHorizontal();&#10;            }&#10;&#10;            EditorGUILayout.EndScrollView();&#10;&#10;            // Control buttons&#10;            EditorGUILayout.BeginHorizontal();&#10;            if (GUILayout.Button(&quot;Add Selected from Project&quot;))&#10;            {&#10;                AddSelectedSprites();&#10;            }&#10;&#10;            if (GUILayout.Button(&quot;Add All from Folders&quot;))&#10;            {&#10;                AddSpritesFromSelectedFolders();&#10;            }&#10;&#10;            if (GUILayout.Button(&quot;Clear All&quot;))&#10;            {&#10;                _spritesToMerge.Clear();&#10;            }&#10;&#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawOutputSettings()&#10;        {&#10;            EditorGUILayout.BeginVertical(EditorStyles.helpBox);&#10;            GUILayout.Label(&quot;Atlas Settings&quot;, EditorStyles.centeredGreyMiniLabel);&#10;&#10;            outputFileName = EditorGUILayout.TextField(&quot;Output File Name&quot;, outputFileName);&#10;            _padding = EditorGUILayout.IntSlider(&quot;Padding&quot;, _padding, 0, 10);&#10;            _maxAtlasSize = EditorGUILayout.IntPopup(&quot;Max Atlas Size&quot;, _maxAtlasSize,&#10;                new[] { &quot;1024&quot;, &quot;2048&quot;, &quot;4096&quot;, &quot;8192&quot; },&#10;                new[] { 1024, 2048, 4096, 8192 });&#10;&#10;            _filterMode = (FilterMode)EditorGUILayout.EnumPopup(&quot;Filter Mode&quot;, _filterMode);&#10;            _textureFormat = (TextureFormat)EditorGUILayout.EnumPopup(&quot;Texture Format&quot;, _textureFormat);&#10;&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawUpdateOptions()&#10;        {&#10;            EditorGUILayout.BeginVertical(EditorStyles.helpBox);&#10;            GUILayout.Label(&quot;Reference Update Options&quot;, EditorStyles.centeredGreyMiniLabel);&#10;&#10;            EditorGUILayout.BeginHorizontal();&#10;            _updateScenes = EditorGUILayout.Toggle(_updateScenes, GUILayout.Width(20));&#10;            GUILayout.Label(&quot;Update Scene References&quot;, GUILayout.ExpandWidth(true));&#10;            EditorGUILayout.EndHorizontal();&#10;&#10;            EditorGUILayout.BeginHorizontal();&#10;            _updatePrefabs = EditorGUILayout.Toggle(_updatePrefabs, GUILayout.Width(20));&#10;            GUILayout.Label(&quot;Update Prefab References&quot;, GUILayout.ExpandWidth(true));&#10;            EditorGUILayout.EndHorizontal();&#10;&#10;            EditorGUILayout.BeginHorizontal();&#10;            _updateScriptableObjects = EditorGUILayout.Toggle(_updateScriptableObjects, GUILayout.Width(20));&#10;            GUILayout.Label(&quot;Update ScriptableObject References&quot;, GUILayout.ExpandWidth(true));&#10;            EditorGUILayout.EndHorizontal();&#10;&#10;            EditorGUILayout.BeginHorizontal();&#10;            _makeBackup = EditorGUILayout.Toggle(_makeBackup, GUILayout.Width(20));&#10;            GUILayout.Label(&quot;Create Backup Before Merge&quot;, GUILayout.ExpandWidth(true));&#10;            EditorGUILayout.EndHorizontal();&#10;&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawMergeButton()&#10;        {&#10;            GUI.backgroundColor = new Color(0.5f, 1f, 0.5f);&#10;            if (GUILayout.Button(&quot;Create Atlas and Update All References&quot;, GUILayout.Height(50)))&#10;            {&#10;                if (ValidateInput())&#10;                {&#10;                    if (_makeBackup &amp;&amp; !CreateBackup())&#10;                    {&#10;                        EditorUtility.DisplayDialog(&quot;Backup Failed&quot;, &quot;Could not create backup. Operation cancelled.&quot;,&#10;                            &quot;OK&quot;);&#10;&#10;                        return;&#10;                    }&#10;&#10;                    MergeSpritesIntoAtlas();&#10;                }&#10;            }&#10;&#10;            GUI.backgroundColor = Color.white;&#10;        }&#10;&#10;        private bool ValidateInput()&#10;        {&#10;            if (_spritesToMerge.Count &lt; 2)&#10;            {&#10;                EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Please select at least two sprites to merge.&quot;, &quot;OK&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (string.IsNullOrEmpty(outputFileName))&#10;            {&#10;                EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Please provide an output file name.&quot;, &quot;OK&quot;);&#10;                return false;&#10;            }&#10;&#10;            // Check for duplicate sprite names&#10;            var duplicates = _spritesToMerge.Where(s =&gt; s != null)&#10;                .GroupBy(s =&gt; s.name)&#10;                .Where(g =&gt; g.Count() &gt; 1)&#10;                .Select(g =&gt; g.Key)&#10;                .ToList();&#10;&#10;            if (duplicates.Count &gt; 0)&#10;            {&#10;                string duplicateNames = string.Join(&quot;, &quot;, duplicates);&#10;                if (!EditorUtility.DisplayDialog(&quot;Duplicate Names Found&quot;,&#10;                        $&quot;Found duplicate sprite names: {duplicateNames}\n\nThis may cause reference update issues. Continue anyway?&quot;,&#10;                        &quot;Yes&quot;, &quot;Cancel&quot;))&#10;                {&#10;                    return false;&#10;                }&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        private bool CreateBackup()&#10;        {&#10;            try&#10;            {&#10;                string backupFolder = &quot;Assets/SpriteAtlasBackup_&quot; + DateTime.Now.ToString(&quot;yyyyMMdd_HHmmss&quot;);&#10;                Directory.CreateDirectory(backupFolder);&#10;&#10;                // Backup original textures&#10;                var originalTextures = _spritesToMerge.Where(s =&gt; s != null)&#10;                    .Select(s =&gt; s.texture)&#10;                    .Distinct();&#10;&#10;                foreach (Texture2D texture in originalTextures)&#10;                {&#10;                    string originalPath = AssetDatabase.GetAssetPath(texture);&#10;                    if (!string.IsNullOrEmpty(originalPath))&#10;                    {&#10;                        string backupPath = Path.Combine(backupFolder, Path.GetFileName(originalPath));&#10;                        AssetDatabase.CopyAsset(originalPath, backupPath);&#10;                    }&#10;                }&#10;&#10;                AssetDatabase.Refresh();&#10;                Debug.Log($&quot;Backup created at: {backupFolder}&quot;);&#10;                return true;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to create backup: {e.Message}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private void ProcessDragAndDrop(Rect dropArea)&#10;        {&#10;            Event evt = Event.current;&#10;            if (evt.type == EventType.DragUpdated || evt.type == EventType.DragPerform)&#10;            {&#10;                if (!dropArea.Contains(evt.mousePosition)) return;&#10;&#10;                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;&#10;&#10;                if (evt.type == EventType.DragPerform)&#10;                {&#10;                    DragAndDrop.AcceptDrag();&#10;                    foreach (Object draggedObject in DragAndDrop.objectReferences)&#10;                    {&#10;                        AddObjectToSpriteList(draggedObject);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void AddObjectToSpriteList(Object obj)&#10;        {&#10;            if (obj == null) return;&#10;&#10;            if (obj is Sprite sprite)&#10;            {&#10;                if (!_spritesToMerge.Contains(sprite))&#10;                    _spritesToMerge.Add(sprite);&#10;            }&#10;            else if (obj is Texture2D texture)&#10;            {&#10;                // Add all sprites from this texture&#10;                string path = AssetDatabase.GetAssetPath(texture);&#10;                if (!string.IsNullOrEmpty(path))&#10;                {&#10;                    var spritesInTexture = AssetDatabase.LoadAllAssetsAtPath(path).OfType&lt;Sprite&gt;();&#10;                    foreach (Sprite s in spritesInTexture)&#10;                    {&#10;                        if (s != null &amp;&amp; !_spritesToMerge.Contains(s))&#10;                            _spritesToMerge.Add(s);&#10;                    }&#10;                }&#10;            }&#10;            else if (obj is DefaultAsset)&#10;            {&#10;                // Handle folder selection&#10;                string path = AssetDatabase.GetAssetPath(obj);&#10;                if (Directory.Exists(path))&#10;                {&#10;                    AddSpritesFromFolder(path);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void AddSelectedSprites()&#10;        {&#10;            foreach (Object obj in Selection.objects)&#10;            {&#10;                AddObjectToSpriteList(obj);&#10;            }&#10;        }&#10;&#10;        private void AddSpritesFromSelectedFolders()&#10;        {&#10;            foreach (Object obj in Selection.objects)&#10;            {&#10;                if (obj is DefaultAsset)&#10;                {&#10;                    string path = AssetDatabase.GetAssetPath(obj);&#10;                    if (Directory.Exists(path))&#10;                    {&#10;                        AddSpritesFromFolder(path);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void AddSpritesFromFolder(string folderPath)&#10;        {&#10;            string[] guids = AssetDatabase.FindAssets(&quot;t:Sprite&quot;, new[] { folderPath });&#10;            foreach (string guid in guids)&#10;            {&#10;                string path = AssetDatabase.GUIDToAssetPath(guid);&#10;                Sprite sprite = AssetDatabase.LoadAssetAtPath&lt;Sprite&gt;(path);&#10;                if (sprite != null &amp;&amp; !_spritesToMerge.Contains(sprite))&#10;                {&#10;                    _spritesToMerge.Add(sprite);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void MergeSpritesIntoAtlas()&#10;        {&#10;            string outputPath = EditorUtility.SaveFilePanelInProject(&quot;Save Atlas Texture&quot;, outputFileName, &quot;png&quot;,&#10;                &quot;Save the merged atlas texture&quot;);&#10;&#10;            if (string.IsNullOrEmpty(outputPath)) return;&#10;&#10;            // Begin Undo group&#10;            Undo.IncrementCurrentGroup();&#10;            Undo.SetCurrentGroupName(UndoGroupName);&#10;            createdAssetPaths.Clear();&#10;            OriginalReferences.Clear();&#10;&#10;            EditorUtility.DisplayProgressBar(&quot;Creating Atlas&quot;, &quot;Preparing sprites...&quot;, 0f);&#10;&#10;            try&#10;            {&#10;                var validSprites = _spritesToMerge.Where(s =&gt; s != null &amp;&amp; s.texture != null).ToList();&#10;                if (validSprites.Count == 0)&#10;                {&#10;                    EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;No valid sprites found to merge.&quot;, &quot;OK&quot;);&#10;                    return;&#10;                }&#10;&#10;                // Create atlas texture&#10;                Texture2D atlas = CreateAtlasTexture(validSprites);&#10;                if (atlas == null)&#10;                {&#10;                    EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Failed to create atlas texture.&quot;, &quot;OK&quot;);&#10;                    return;&#10;                }&#10;&#10;                // Save atlas to disk&#10;                byte[] bytes = atlas.EncodeToPNG();&#10;                File.WriteAllBytes(outputPath, bytes);&#10;                AssetDatabase.Refresh();&#10;&#10;                // Track created asset for undo&#10;                createdAssetPaths.Add(outputPath);&#10;                RegisterCreatedAssetForUndo(outputPath);&#10;&#10;                EditorUtility.DisplayProgressBar(&quot;Creating Atlas&quot;, &quot;Configuring texture importer...&quot;, 0.5f);&#10;&#10;                // Configure texture importer&#10;                if (!ConfigureAtlasImporter(outputPath, validSprites, atlas))&#10;                {&#10;                    EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Failed to configure atlas importer.&quot;, &quot;OK&quot;);&#10;                    return;&#10;                }&#10;&#10;                EditorUtility.DisplayProgressBar(&quot;Creating Atlas&quot;, &quot;Updating references...&quot;, 0.7f);&#10;&#10;                // Update all references&#10;                UpdateAllProjectReferences(validSprites, outputPath);&#10;&#10;                // Collapse undo group&#10;                Undo.CollapseUndoOperations(Undo.GetCurrentGroup());&#10;                Debug.Log(&quot;Atlas merge completed. Use Ctrl+Z to undo all changes made by this operation.&quot;);&#10;&#10;                EditorUtility.DisplayDialog(&quot;Success&quot;,&#10;                    &quot;Atlas created successfully!\n&quot; +&#10;                    $&quot;• Merged {validSprites.Count} sprites\n&quot; +&#10;                    $&quot;• Atlas size: {atlas.width}x{atlas.height}\n&quot; +&#10;                    &quot;• All project references updated&quot; +&#10;                    &quot;• Use Ctrl+Z to undo if needed&quot;, &quot;OK&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                // Revert undo group on error&#10;                Undo.RevertAllInCurrentGroup();&#10;&#10;                EditorUtility.DisplayDialog(&quot;Error&quot;, $&quot;Failed to create atlas: {e.Message}&quot;, &quot;OK&quot;);&#10;                Debug.LogError($&quot;Atlas creation failed: {e}&quot;);&#10;            }&#10;            finally&#10;            {&#10;                EditorUtility.ClearProgressBar();&#10;            }&#10;        }&#10;&#10;        private Texture2D CreateAtlasTexture(List&lt;Sprite&gt; sprites)&#10;        {&#10;            // Group sprites by their source texture to handle sprite sheets properly&#10;            var textureGroups = sprites.GroupBy(s =&gt; s.texture).ToList();&#10;            var textureRects = new List&lt;Texture2D&gt;();&#10;&#10;            // Create individual textures for each sprite&#10;            for (int groupIndex = 0; groupIndex &lt; textureGroups.Count(); groupIndex++)&#10;            {&#10;                var group = textureGroups[groupIndex];&#10;                Texture2D sourceTexture = GetReadableTexture(group.Key);&#10;&#10;                foreach (Sprite sprite in group)&#10;                {&#10;                    // Extract sprite region from source texture&#10;                    Texture2D spriteTexture = ExtractSpriteTexture(sourceTexture, sprite);&#10;                    if (spriteTexture)&#10;                    {&#10;                        textureRects.Add(spriteTexture);&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (textureRects.Count == 0) return null;&#10;&#10;            // Pack textures into atlas&#10;            Texture2D atlas = new(1, 1, _textureFormat, false)&#10;            {&#10;                filterMode = _filterMode&#10;            };&#10;&#10;            atlas.PackTextures(textureRects.ToArray(), _padding, _maxAtlasSize, false);&#10;&#10;            return atlas;&#10;        }&#10;&#10;        private Texture2D ExtractSpriteTexture(Texture2D sourceTexture, Sprite sprite)&#10;        {&#10;&#10;            Rect textureRect = sprite.textureRect;&#10;            int width = Mathf.FloorToInt(textureRect.width);&#10;            int height = Mathf.FloorToInt(textureRect.height);&#10;&#10;            if (width &lt;= 0 || height &lt;= 0) return null;&#10;&#10;            Texture2D spriteTexture = new(width, height, _textureFormat, false)&#10;            {&#10;                name = sprite.name&#10;            };&#10;&#10;            // Copy pixels from source texture&#10;            var pixels = sourceTexture.GetPixels(&#10;                Mathf.FloorToInt(textureRect.x),&#10;                Mathf.FloorToInt(textureRect.y),&#10;                width,&#10;                height&#10;            );&#10;&#10;            spriteTexture.SetPixels(pixels);&#10;            spriteTexture.Apply();&#10;&#10;            return spriteTexture;&#10;        }&#10;&#10;        private Texture2D GetReadableTexture(Texture2D texture)&#10;        {&#10;            if (texture == null) return null;&#10;&#10;            string path = AssetDatabase.GetAssetPath(texture);&#10;            TextureImporter importer = AssetImporter.GetAtPath(path) as TextureImporter;&#10;&#10;            if (importer == null)&#10;            {&#10;                throw new InvalidOperationException($&quot;Could not get TextureImporter for {texture.name}&quot;);&#10;            }&#10;&#10;            // If already readable, create a copy&#10;            if (importer.isReadable)&#10;            {&#10;                Texture2D copy = new(texture.width, texture.height, texture.format, texture.mipmapCount &gt; 1);&#10;                copy.name = texture.name;&#10;                Graphics.CopyTexture(texture, copy);&#10;                return copy;&#10;            }&#10;&#10;            // Create readable version using RenderTexture&#10;            RenderTexture rt = RenderTexture.GetTemporary(texture.width, texture.height, 0, RenderTextureFormat.Default,&#10;                RenderTextureReadWrite.Linear);&#10;&#10;            Graphics.Blit(texture, rt);&#10;            RenderTexture previous = RenderTexture.active;&#10;            RenderTexture.active = rt;&#10;&#10;            Texture2D readableTexture = new(texture.width, texture.height);&#10;            readableTexture.name = texture.name;&#10;            readableTexture.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);&#10;            readableTexture.Apply();&#10;&#10;            RenderTexture.active = previous;&#10;            RenderTexture.ReleaseTemporary(rt);&#10;&#10;            return readableTexture;&#10;        }&#10;&#10;        private bool ConfigureAtlasImporter(string atlasPath, List&lt;Sprite&gt; originalSprites, Texture2D atlas)&#10;        {&#10;            TextureImporter importer = AssetImporter.GetAtPath(atlasPath) as TextureImporter;&#10;            if (!importer) return false;&#10;&#10;            importer.textureType = TextureImporterType.Sprite;&#10;            importer.spriteImportMode = SpriteImportMode.Multiple;&#10;            importer.filterMode = _filterMode;&#10;            importer.textureCompression = TextureImporterCompression.Uncompressed; // For better quality&#10;&#10;            // Create sprite rectangles&#10;            var spriteRects = new List&lt;SpriteRect&gt;();&#10;&#10;            // Recreate the packing to get correct rectangles&#10;&#10;            Texture2D tempAtlas = new(1, 1);&#10;            var packedRects = tempAtlas.PackTextures(originalSprites&#10;                .Select(sprite =&gt; new { sprite, sourceTexture = GetReadableTexture(sprite.texture) })&#10;                .Select(t =&gt; ExtractSpriteTexture(t.sourceTexture, t.sprite))&#10;                .Where(spriteTexture =&gt; spriteTexture is not null).ToArray(), _padding, _maxAtlasSize, false);&#10;&#10;            for (int i = 0; i &lt; originalSprites.Count &amp;&amp; i &lt; packedRects.Length; i++)&#10;            {&#10;                Sprite sprite = originalSprites[i];&#10;                Rect packedRect = packedRects[i];&#10;&#10;                SpriteRect spriteRect = new()&#10;                {&#10;                    name = sprite.name,&#10;                    rect = new Rect(&#10;                        packedRect.x * atlas.width,&#10;                        packedRect.y * atlas.height,&#10;                        packedRect.width * atlas.width,&#10;                        packedRect.height * atlas.height&#10;                    ),&#10;                    pivot = sprite.textureRect.size == Vector2.zero&#10;                        ? new Vector2(0.5f, 0.5f)&#10;                        : sprite.pivot / sprite.textureRect.size,&#10;                    border = sprite.border,&#10;                    alignment = SpriteAlignment.Custom&#10;                };&#10;&#10;                spriteRects.Add(spriteRect);&#10;            }&#10;&#10;            // Apply sprite rectangles&#10;            SpriteDataProviderFactories factories = new();&#10;            factories.Init();&#10;            ISpriteEditorDataProvider dataProvider = factories.GetSpriteEditorDataProviderFromObject(importer);&#10;            if (dataProvider == null)&#10;            {&#10;                Debug.LogError(&#10;                    &quot;Failed to get SpriteEditorDataProvider from importer. The atlas asset may not be fully imported yet.&quot;);&#10;&#10;                return false;&#10;            }&#10;&#10;            dataProvider.InitSpriteEditorDataProvider();&#10;            dataProvider.SetSpriteRects(spriteRects.ToArray());&#10;            dataProvider.Apply();&#10;&#10;            EditorUtility.SetDirty(importer);&#10;            importer.SaveAndReimport();&#10;&#10;            if (originalSprites.Count &gt; 0 &amp;&amp; originalSprites[0] &amp;&amp; originalSprites[0].texture)&#10;            {&#10;                string srcPath = AssetDatabase.GetAssetPath(originalSprites[0].texture);&#10;                TextureImporter srcImporter = AssetImporter.GetAtPath(srcPath) as TextureImporter;&#10;                if (srcImporter)&#10;                {&#10;                    importer.sRGBTexture = srcImporter.sRGBTexture;&#10;                    importer.mipmapEnabled = srcImporter.mipmapEnabled;&#10;                    importer.filterMode = srcImporter.filterMode;&#10;                    importer.anisoLevel = srcImporter.anisoLevel;&#10;                    importer.wrapMode = srcImporter.wrapMode;&#10;                    importer.npotScale = srcImporter.npotScale;&#10;                    importer.alphaIsTransparency = srcImporter.alphaIsTransparency;&#10;                    importer.compressionQuality = srcImporter.compressionQuality;&#10;                    importer.textureCompression = srcImporter.textureCompression;&#10;                    importer.isReadable = srcImporter.isReadable;&#10;                    importer.maxTextureSize = srcImporter.maxTextureSize;&#10;                    importer.spritePixelsPerUnit = srcImporter.spritePixelsPerUnit;&#10;                }&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        private void UpdateAllProjectReferences(List&lt;Sprite&gt; originalSprites, string atlasPath)&#10;        {&#10;            // Create mapping from old sprites to new sprites&#10;            var spriteMap = CreateSpriteMapping(originalSprites, atlasPath);&#10;            if (spriteMap.Count == 0)&#10;            {&#10;                Debug.LogWarning(&quot;No sprite mapping created. References will not be updated.&quot;);&#10;                return;&#10;            }&#10;&#10;            int totalUpdated = 0;&#10;            string[] allAssetPaths = AssetDatabase.GetAllAssetPaths()&#10;                .Where(path =&gt; path.StartsWith(&quot;Assets/&quot;))&#10;                .ToArray();&#10;&#10;            for (int i = 0; i &lt; allAssetPaths.Length; i++)&#10;            {&#10;                string path = allAssetPaths[i];&#10;&#10;                if (EditorUtility.DisplayCancelableProgressBar(&quot;Updating References&quot;,&#10;                        $&quot;Processing: {Path.GetFileName(path)}&quot;, (float)i / allAssetPaths.Length))&#10;                {&#10;                    break;&#10;                }&#10;&#10;                if (_updateScenes &amp;&amp; path.EndsWith(&quot;.unity&quot;))&#10;                {&#10;                    totalUpdated += UpdateSceneReferences(path, spriteMap);&#10;                }&#10;                else if (_updatePrefabs &amp;&amp; path.EndsWith(&quot;.prefab&quot;))&#10;                {&#10;                    totalUpdated += UpdateAssetReferences(path, spriteMap);&#10;                }&#10;                else if (_updateScriptableObjects &amp;&amp; path.EndsWith(&quot;.asset&quot;))&#10;                {&#10;                    totalUpdated += UpdateAssetReferences(path, spriteMap);&#10;                }&#10;            }&#10;&#10;            AssetDatabase.SaveAssets();&#10;            Debug.Log($&quot;Successfully updated {totalUpdated} sprite references across the project.&quot;);&#10;        }&#10;&#10;        private Dictionary&lt;int, Sprite&gt; CreateSpriteMapping(List&lt;Sprite&gt; originalSprites, string atlasPath)&#10;        {&#10;            var mapping = new Dictionary&lt;int, Sprite&gt;();&#10;            var newSprites = AssetDatabase.LoadAllAssetsAtPath(atlasPath).OfType&lt;Sprite&gt;().ToList();&#10;&#10;            foreach (Sprite originalSprite in originalSprites)&#10;            {&#10;                if (originalSprite == null) continue;&#10;&#10;                Sprite newSprite = newSprites.FirstOrDefault(s =&gt; s != null &amp;&amp; s.name == originalSprite.name);&#10;                if (newSprite != null)&#10;                {&#10;                    mapping[originalSprite.GetInstanceID()] = newSprite;&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;Could not find matching sprite '{originalSprite.name}' in new atlas.&quot;);&#10;                }&#10;            }&#10;&#10;            return mapping;&#10;        }&#10;&#10;        private int UpdateSceneReferences(string scenePath, Dictionary&lt;int, Sprite&gt; spriteMap)&#10;        {&#10;            int count = 0;&#10;            Scene scene = EditorSceneManager.OpenScene(scenePath, OpenSceneMode.Additive);&#10;            if (!scene.IsValid()) return 0;&#10;&#10;            bool sceneModified = false;&#10;&#10;            foreach (GameObject rootGo in scene.GetRootGameObjects())&#10;            {&#10;                if (WillGameObjectBeModified(rootGo, spriteMap))&#10;                {&#10;                    Undo.RegisterCompleteObjectUndo(rootGo, UndoGroupName);&#10;                }&#10;            }&#10;&#10;            foreach (GameObject rootGo in scene.GetRootGameObjects())&#10;            {&#10;                count += UpdateGameObjectReferences(rootGo, spriteMap, ref sceneModified);&#10;            }&#10;&#10;            if (sceneModified)&#10;            {&#10;                EditorSceneManager.SaveScene(scene);&#10;                Debug.Log($&quot;Updated {count} references in scene: {scene.name}&quot;);&#10;            }&#10;&#10;            EditorSceneManager.CloseScene(scene, false);&#10;            return count;&#10;        }&#10;&#10;        private int UpdateGameObjectReferences(GameObject go, Dictionary&lt;int, Sprite&gt; spriteMap, ref bool modified)&#10;        {&#10;            int count = 0;&#10;&#10;            foreach (Component component in go.GetComponentsInChildren&lt;Component&gt;(true))&#10;            {&#10;                if (!component) continue;&#10;&#10;                // Register component for undo before modification&#10;                bool componentWillBeModified = WillComponentBeModified(component, spriteMap);&#10;                if (componentWillBeModified)&#10;                {&#10;                    Undo.RecordObject(component, UndoGroupName);&#10;                }&#10;&#10;                SerializedObject so = new(component);&#10;                SerializedProperty prop = so.GetIterator();&#10;&#10;                while (prop.NextVisible(true))&#10;                {&#10;                    if (prop.propertyType == SerializedPropertyType.ObjectReference &amp;&amp;&#10;                        prop.objectReferenceValue is Sprite oldSprite &amp;&amp;&#10;                        oldSprite != null &amp;&amp;&#10;                        spriteMap.TryGetValue(oldSprite.GetInstanceID(), out Sprite newSprite))&#10;                    {&#10;                        // Store original reference for potential undo&#10;                        if (!OriginalReferences.ContainsKey(component))&#10;                        {&#10;                            OriginalReferences[component] = oldSprite;&#10;                        }&#10;&#10;                        prop.objectReferenceValue = newSprite;&#10;                        modified = true;&#10;                        count++;&#10;                    }&#10;                }&#10;&#10;                if (so.hasModifiedProperties)&#10;                {&#10;                    so.ApplyModifiedProperties();&#10;                    if (componentWillBeModified)&#10;                    {&#10;                        EditorUtility.SetDirty(component);&#10;                    }&#10;                }&#10;            }&#10;&#10;            return count;&#10;        }&#10;&#10;        private int UpdateAssetReferences(string assetPath, Dictionary&lt;int, Sprite&gt; spriteMap)&#10;        {&#10;            int count = 0;&#10;            var assets = AssetDatabase.LoadAllAssetsAtPath(assetPath);&#10;&#10;            foreach (Object asset in assets)&#10;            {&#10;                if (!asset || asset is Texture2D || asset is Sprite) continue;&#10;&#10;                // Check if this asset will be modified and register for undo&#10;                bool assetWillBeModified = WillAssetBeModified(asset, spriteMap);&#10;                if (assetWillBeModified)&#10;                {&#10;                    Undo.RecordObject(asset, UndoGroupName);&#10;                }&#10;&#10;                SerializedObject so = new(asset);&#10;                SerializedProperty prop = so.GetIterator();&#10;                bool assetModified = false;&#10;&#10;                while (prop.NextVisible(true))&#10;                {&#10;                    if (prop.propertyType == SerializedPropertyType.ObjectReference &amp;&amp;&#10;                        prop.objectReferenceValue is Sprite oldSprite &amp;&amp;&#10;                        oldSprite != null &amp;&amp;&#10;                        spriteMap.TryGetValue(oldSprite.GetInstanceID(), out Sprite newSprite))&#10;                    {&#10;                        // Store original reference for potential undo&#10;                        if (!OriginalReferences.ContainsKey(asset))&#10;                        {&#10;                            OriginalReferences[asset] = oldSprite;&#10;                        }&#10;&#10;                        prop.objectReferenceValue = newSprite;&#10;                        assetModified = true;&#10;                        count++;&#10;                    }&#10;                }&#10;&#10;                if (assetModified)&#10;                {&#10;                    so.ApplyModifiedProperties();&#10;                    if (assetWillBeModified)&#10;                    {&#10;                        EditorUtility.SetDirty(asset);&#10;                    }&#10;                }&#10;            }&#10;&#10;            return count;&#10;        }&#10;&#10;        #region Undo Support Methods&#10;&#10;        private void RegisterCreatedAssetForUndo(string assetPath)&#10;        {&#10;            // Custom undo operation for created assets&#10;            Undo.RegisterCreatedObjectUndo(AssetDatabase.LoadAssetAtPath&lt;Object&gt;(assetPath), UndoGroupName);&#10;        }&#10;&#10;        private bool WillGameObjectBeModified(GameObject go, Dictionary&lt;int, Sprite&gt; spriteMap)&#10;        {&#10;            foreach (Component component in go.GetComponentsInChildren&lt;Component&gt;(true))&#10;            {&#10;                if (component != null &amp;&amp; WillComponentBeModified(component, spriteMap))&#10;                {&#10;                    return true;&#10;                }&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        private bool WillComponentBeModified(Component component, Dictionary&lt;int, Sprite&gt; spriteMap)&#10;        {&#10;            if (component == null) return false;&#10;&#10;            SerializedObject so = new(component);&#10;            SerializedProperty prop = so.GetIterator();&#10;&#10;            while (prop.NextVisible(true))&#10;            {&#10;                if (prop.propertyType == SerializedPropertyType.ObjectReference &amp;&amp;&#10;                    prop.objectReferenceValue is Sprite sprite &amp;&amp;&#10;                    sprite != null &amp;&amp;&#10;                    spriteMap.ContainsKey(sprite.GetInstanceID()))&#10;                {&#10;                    return true;&#10;                }&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        private bool WillAssetBeModified(Object asset, Dictionary&lt;int, Sprite&gt; spriteMap)&#10;        {&#10;            if (asset == null || asset is Texture2D || asset is Sprite) return false;&#10;&#10;            SerializedObject so = new(asset);&#10;            SerializedProperty prop = so.GetIterator();&#10;&#10;            while (prop.NextVisible(true))&#10;            {&#10;                if (prop.propertyType == SerializedPropertyType.ObjectReference &amp;&amp;&#10;                    prop.objectReferenceValue is Sprite sprite &amp;&amp;&#10;                    sprite != null &amp;&amp;&#10;                    spriteMap.ContainsKey(sprite.GetInstanceID()))&#10;                {&#10;                    return true;&#10;                }&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        // Custom undo callback for cleaning up created assets&#10;        [Serializable]&#10;        public class AtlasMergeUndoOperation : ScriptableObject&#10;        {&#10;            public List&lt;string&gt; createdAssetPaths = new();&#10;&#10;            private void OnEnable()&#10;            {&#10;                Undo.undoRedoPerformed += OnUndoRedo;&#10;            }&#10;&#10;            private void OnDisable()&#10;            {&#10;                Undo.undoRedoPerformed -= OnUndoRedo;&#10;            }&#10;&#10;            private void OnUndoRedo()&#10;            {&#10;                // Clean up created assets when undoing&#10;                foreach (string path in createdAssetPaths)&#10;                {&#10;                    if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path))&#10;                    {&#10;                        AssetDatabase.DeleteAsset(path);&#10;                    }&#10;                }&#10;&#10;                AssetDatabase.Refresh();&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.IO;&#10;using System.Linq;&#10;using UnityEditor;&#10;using UnityEditor.SceneManagement;&#10;using UnityEditor.U2D.Sprites;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using Object = UnityEngine.Object;&#10;&#10;// REQUIRED: The &quot;2D Sprite&quot; package must be installed via the Package Manager for this to compile.&#10;&#10;namespace Editor&#10;{&#10;    public class SpriteMergerEditor : EditorWindow&#10;    {&#10;&#10;        // Undo tracking&#10;        private static readonly string UndoGroupName = &quot;Sprite Atlas Merge&quot;;&#10;        private static readonly Dictionary&lt;Object, Object&gt; OriginalReferences = new();&#10;        [SerializeField] private List&lt;string&gt; createdAssetPaths = new();&#10;        [SerializeField] private string outputFileName = &quot;MergedSpriteAtlas&quot;;&#10;        private readonly List&lt;Sprite&gt; _spritesToMerge = new();&#10;        private FilterMode _filterMode = FilterMode.Point;&#10;        private bool _makeBackup = true;&#10;        private int _maxAtlasSize = 4096;&#10;        private int _padding = 2;&#10;        private Vector2 _scrollPosition;&#10;        private TextureFormat _textureFormat = TextureFormat.RGBA32;&#10;        private bool _updatePrefabs = true;&#10;        private bool _updateScenes = true;&#10;        private bool _updateScriptableObjects = true;&#10;&#10;        private void OnGUI()&#10;        {&#10;            GUILayout.Label(&quot;Sprite Atlas Merger&quot;, EditorStyles.boldLabel);&#10;            EditorGUILayout.HelpBox(&#10;                &quot;Merge multiple sprite sheets into a single atlas and update ALL project references automatically.&quot;,&#10;                MessageType.Info);&#10;&#10;            EditorGUILayout.HelpBox(&quot;IMPORTANT: This tool requires the '2D Sprite' package. Make backups before use!&quot;,&#10;                MessageType.Warning);&#10;&#10;            DrawSpriteList();&#10;            DrawOutputSettings();&#10;            DrawUpdateOptions();&#10;            DrawMergeButton();&#10;        }&#10;&#10;        [MenuItem(&quot;Tools/Sprite Atlas Merger&quot;)]&#10;        public static void ShowWindow()&#10;        {&#10;            GetWindow&lt;SpriteMergerEditor&gt;(&quot;Atlas Merger&quot;);&#10;        }&#10;&#10;        private void DrawSpriteList()&#10;        {&#10;            EditorGUILayout.BeginVertical(EditorStyles.helpBox);&#10;            GUILayout.Label($&quot;Sprites to Merge ({_spritesToMerge.Count})&quot;, EditorStyles.centeredGreyMiniLabel);&#10;&#10;            // Drag and drop area&#10;            Rect dropArea = GUILayoutUtility.GetRect(0.0f, 60.0f, GUILayout.ExpandWidth(true));&#10;            GUI.Box(dropArea, &quot;Drag &amp; Drop Sprites or Textures Here\n(Individual sprites or entire sprite sheets)&quot;,&#10;                EditorStyles.helpBox);&#10;&#10;            ProcessDragAndDrop(dropArea);&#10;&#10;            // Sprite list with scroll view&#10;            _scrollPosition = EditorGUILayout.BeginScrollView(_scrollPosition, GUILayout.Height(200));&#10;            for (int i = _spritesToMerge.Count - 1; i &gt;= 0; i--)&#10;            {&#10;                if (_spritesToMerge[i] == null)&#10;                {&#10;                    _spritesToMerge.RemoveAt(i);&#10;                    continue;&#10;                }&#10;&#10;                EditorGUILayout.BeginHorizontal();&#10;                _spritesToMerge[i] = (Sprite)EditorGUILayout.ObjectField(_spritesToMerge[i], typeof(Sprite), false);&#10;&#10;                // Show source texture info&#10;                if (_spritesToMerge[i] != null)&#10;                {&#10;                    GUILayout.Label($&quot;[{_spritesToMerge[i].texture.name}]&quot;, EditorStyles.miniLabel,&#10;                        GUILayout.Width(100));&#10;                }&#10;&#10;                if (GUILayout.Button(&quot;Remove&quot;, GUILayout.Width(60)))&#10;                {&#10;                    _spritesToMerge.RemoveAt(i);&#10;                }&#10;&#10;                EditorGUILayout.EndHorizontal();&#10;            }&#10;&#10;            EditorGUILayout.EndScrollView();&#10;&#10;            // Control buttons&#10;            EditorGUILayout.BeginHorizontal();&#10;            if (GUILayout.Button(&quot;Add Selected from Project&quot;))&#10;            {&#10;                AddSelectedSprites();&#10;            }&#10;&#10;            if (GUILayout.Button(&quot;Add All from Folders&quot;))&#10;            {&#10;                AddSpritesFromSelectedFolders();&#10;            }&#10;&#10;            if (GUILayout.Button(&quot;Clear All&quot;))&#10;            {&#10;                _spritesToMerge.Clear();&#10;            }&#10;&#10;            EditorGUILayout.EndHorizontal();&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawOutputSettings()&#10;        {&#10;            EditorGUILayout.BeginVertical(EditorStyles.helpBox);&#10;            GUILayout.Label(&quot;Atlas Settings&quot;, EditorStyles.centeredGreyMiniLabel);&#10;&#10;            outputFileName = EditorGUILayout.TextField(&quot;Output File Name&quot;, outputFileName);&#10;            _padding = EditorGUILayout.IntSlider(&quot;Padding&quot;, _padding, 0, 10);&#10;            _maxAtlasSize = EditorGUILayout.IntPopup(&quot;Max Atlas Size&quot;, _maxAtlasSize,&#10;                new[] { &quot;1024&quot;, &quot;2048&quot;, &quot;4096&quot;, &quot;8192&quot; },&#10;                new[] { 1024, 2048, 4096, 8192 });&#10;&#10;            _filterMode = (FilterMode)EditorGUILayout.EnumPopup(&quot;Filter Mode&quot;, _filterMode);&#10;            _textureFormat = (TextureFormat)EditorGUILayout.EnumPopup(&quot;Texture Format&quot;, _textureFormat);&#10;&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawUpdateOptions()&#10;        {&#10;            EditorGUILayout.BeginVertical(EditorStyles.helpBox);&#10;            GUILayout.Label(&quot;Reference Update Options&quot;, EditorStyles.centeredGreyMiniLabel);&#10;&#10;            EditorGUILayout.BeginHorizontal();&#10;            _updateScenes = EditorGUILayout.Toggle(_updateScenes, GUILayout.Width(20));&#10;            GUILayout.Label(&quot;Update Scene References&quot;, GUILayout.ExpandWidth(true));&#10;            EditorGUILayout.EndHorizontal();&#10;&#10;            EditorGUILayout.BeginHorizontal();&#10;            _updatePrefabs = EditorGUILayout.Toggle(_updatePrefabs, GUILayout.Width(20));&#10;            GUILayout.Label(&quot;Update Prefab References&quot;, GUILayout.ExpandWidth(true));&#10;            EditorGUILayout.EndHorizontal();&#10;&#10;            EditorGUILayout.BeginHorizontal();&#10;            _updateScriptableObjects = EditorGUILayout.Toggle(_updateScriptableObjects, GUILayout.Width(20));&#10;            GUILayout.Label(&quot;Update ScriptableObject References&quot;, GUILayout.ExpandWidth(true));&#10;            EditorGUILayout.EndHorizontal();&#10;&#10;            EditorGUILayout.BeginHorizontal();&#10;            _makeBackup = EditorGUILayout.Toggle(_makeBackup, GUILayout.Width(20));&#10;            GUILayout.Label(&quot;Create Backup Before Merge&quot;, GUILayout.ExpandWidth(true));&#10;            EditorGUILayout.EndHorizontal();&#10;&#10;            EditorGUILayout.EndVertical();&#10;        }&#10;&#10;        private void DrawMergeButton()&#10;        {&#10;            GUI.backgroundColor = new Color(0.5f, 1f, 0.5f);&#10;            if (GUILayout.Button(&quot;Create Atlas and Update All References&quot;, GUILayout.Height(50)))&#10;            {&#10;                if (ValidateInput())&#10;                {&#10;                    if (_makeBackup &amp;&amp; !CreateBackup())&#10;                    {&#10;                        EditorUtility.DisplayDialog(&quot;Backup Failed&quot;, &quot;Could not create backup. Operation cancelled.&quot;,&#10;                            &quot;OK&quot;);&#10;&#10;                        return;&#10;                    }&#10;&#10;                    MergeSpritesIntoAtlas();&#10;                }&#10;            }&#10;&#10;            GUI.backgroundColor = Color.white;&#10;        }&#10;&#10;        private bool ValidateInput()&#10;        {&#10;            if (_spritesToMerge.Count &lt; 2)&#10;            {&#10;                EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Please select at least two sprites to merge.&quot;, &quot;OK&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (string.IsNullOrEmpty(outputFileName))&#10;            {&#10;                EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Please provide an output file name.&quot;, &quot;OK&quot;);&#10;                return false;&#10;            }&#10;&#10;            // Check for duplicate sprite names&#10;            var duplicates = _spritesToMerge.Where(s =&gt; s != null)&#10;                .GroupBy(s =&gt; s.name)&#10;                .Where(g =&gt; g.Count() &gt; 1)&#10;                .Select(g =&gt; g.Key)&#10;                .ToList();&#10;&#10;            if (duplicates.Count &gt; 0)&#10;            {&#10;                string duplicateNames = string.Join(&quot;, &quot;, duplicates);&#10;                if (!EditorUtility.DisplayDialog(&quot;Duplicate Names Found&quot;,&#10;                        $&quot;Found duplicate sprite names: {duplicateNames}\n\nThis may cause reference update issues. Continue anyway?&quot;,&#10;                        &quot;Yes&quot;, &quot;Cancel&quot;))&#10;                {&#10;                    return false;&#10;                }&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        private bool CreateBackup()&#10;        {&#10;            try&#10;            {&#10;                string backupFolder = &quot;Assets/SpriteAtlasBackup_&quot; + DateTime.Now.ToString(&quot;yyyyMMdd_HHmmss&quot;);&#10;                Directory.CreateDirectory(backupFolder);&#10;&#10;                // Backup original textures&#10;                var originalTextures = _spritesToMerge.Where(s =&gt; s != null)&#10;                    .Select(s =&gt; s.texture)&#10;                    .Distinct();&#10;&#10;                foreach (Texture2D texture in originalTextures)&#10;                {&#10;                    string originalPath = AssetDatabase.GetAssetPath(texture);&#10;                    if (!string.IsNullOrEmpty(originalPath))&#10;                    {&#10;                        string backupPath = Path.Combine(backupFolder, Path.GetFileName(originalPath));&#10;                        AssetDatabase.CopyAsset(originalPath, backupPath);&#10;                    }&#10;                }&#10;&#10;                AssetDatabase.Refresh();&#10;                Debug.Log($&quot;Backup created at: {backupFolder}&quot;);&#10;                return true;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to create backup: {e.Message}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private void ProcessDragAndDrop(Rect dropArea)&#10;        {&#10;            Event evt = Event.current;&#10;            if (evt.type == EventType.DragUpdated || evt.type == EventType.DragPerform)&#10;            {&#10;                if (!dropArea.Contains(evt.mousePosition)) return;&#10;&#10;                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;&#10;&#10;                if (evt.type == EventType.DragPerform)&#10;                {&#10;                    DragAndDrop.AcceptDrag();&#10;                    foreach (Object draggedObject in DragAndDrop.objectReferences)&#10;                    {&#10;                        AddObjectToSpriteList(draggedObject);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void AddObjectToSpriteList(Object obj)&#10;        {&#10;            if (obj == null) return;&#10;&#10;            if (obj is Sprite sprite)&#10;            {&#10;                if (!_spritesToMerge.Contains(sprite))&#10;                    _spritesToMerge.Add(sprite);&#10;            }&#10;            else if (obj is Texture2D texture)&#10;            {&#10;                // Add all sprites from this texture&#10;                string path = AssetDatabase.GetAssetPath(texture);&#10;                if (!string.IsNullOrEmpty(path))&#10;                {&#10;                    var spritesInTexture = AssetDatabase.LoadAllAssetsAtPath(path).OfType&lt;Sprite&gt;();&#10;                    foreach (Sprite s in spritesInTexture)&#10;                    {&#10;                        if (s != null &amp;&amp; !_spritesToMerge.Contains(s))&#10;                            _spritesToMerge.Add(s);&#10;                    }&#10;                }&#10;            }&#10;            else if (obj is DefaultAsset)&#10;            {&#10;                // Handle folder selection&#10;                string path = AssetDatabase.GetAssetPath(obj);&#10;                if (Directory.Exists(path))&#10;                {&#10;                    AddSpritesFromFolder(path);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void AddSelectedSprites()&#10;        {&#10;            foreach (Object obj in Selection.objects)&#10;            {&#10;                AddObjectToSpriteList(obj);&#10;            }&#10;        }&#10;&#10;        private void AddSpritesFromSelectedFolders()&#10;        {&#10;            foreach (Object obj in Selection.objects)&#10;            {&#10;                if (obj is DefaultAsset)&#10;                {&#10;                    string path = AssetDatabase.GetAssetPath(obj);&#10;                    if (Directory.Exists(path))&#10;                    {&#10;                        AddSpritesFromFolder(path);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void AddSpritesFromFolder(string folderPath)&#10;        {&#10;            string[] guids = AssetDatabase.FindAssets(&quot;t:Sprite&quot;, new[] { folderPath });&#10;            foreach (string guid in guids)&#10;            {&#10;                string path = AssetDatabase.GUIDToAssetPath(guid);&#10;                Sprite sprite = AssetDatabase.LoadAssetAtPath&lt;Sprite&gt;(path);&#10;                if (sprite != null &amp;&amp; !_spritesToMerge.Contains(sprite))&#10;                {&#10;                    _spritesToMerge.Add(sprite);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void MergeSpritesIntoAtlas()&#10;        {&#10;            string outputPath = EditorUtility.SaveFilePanelInProject(&quot;Save Atlas Texture&quot;, outputFileName, &quot;png&quot;,&#10;                &quot;Save the merged atlas texture&quot;);&#10;&#10;            if (string.IsNullOrEmpty(outputPath)) return;&#10;&#10;            // Begin Undo group&#10;            Undo.IncrementCurrentGroup();&#10;            Undo.SetCurrentGroupName(UndoGroupName);&#10;            createdAssetPaths.Clear();&#10;            OriginalReferences.Clear();&#10;&#10;            EditorUtility.DisplayProgressBar(&quot;Creating Atlas&quot;, &quot;Preparing sprites...&quot;, 0f);&#10;&#10;            try&#10;            {&#10;                var validSprites = _spritesToMerge.Where(s =&gt; s != null &amp;&amp; s.texture != null).ToList();&#10;                if (validSprites.Count == 0)&#10;                {&#10;                    EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;No valid sprites found to merge.&quot;, &quot;OK&quot;);&#10;                    return;&#10;                }&#10;&#10;                // Create atlas texture&#10;                Texture2D atlas = CreateAtlasTexture(validSprites);&#10;                if (atlas == null)&#10;                {&#10;                    EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Failed to create atlas texture.&quot;, &quot;OK&quot;);&#10;                    return;&#10;                }&#10;&#10;                // Save atlas to disk&#10;                byte[] bytes = atlas.EncodeToPNG();&#10;                File.WriteAllBytes(outputPath, bytes);&#10;                AssetDatabase.Refresh();&#10;&#10;                // Track created asset for undo&#10;                createdAssetPaths.Add(outputPath);&#10;                RegisterCreatedAssetForUndo(outputPath);&#10;&#10;                EditorUtility.DisplayProgressBar(&quot;Creating Atlas&quot;, &quot;Configuring texture importer...&quot;, 0.5f);&#10;&#10;                // Configure texture importer&#10;                if (!ConfigureAtlasImporter(outputPath, validSprites, atlas))&#10;                {&#10;                    EditorUtility.DisplayDialog(&quot;Error&quot;, &quot;Failed to configure atlas importer.&quot;, &quot;OK&quot;);&#10;                    return;&#10;                }&#10;&#10;                EditorUtility.DisplayProgressBar(&quot;Creating Atlas&quot;, &quot;Updating references...&quot;, 0.7f);&#10;&#10;                // Update all references&#10;                UpdateAllProjectReferences(validSprites, outputPath);&#10;&#10;                // Collapse undo group&#10;                Undo.CollapseUndoOperations(Undo.GetCurrentGroup());&#10;                Debug.Log(&quot;Atlas merge completed. Use Ctrl+Z to undo all changes made by this operation.&quot;);&#10;&#10;                EditorUtility.DisplayDialog(&quot;Success&quot;,&#10;                    &quot;Atlas created successfully!\n&quot; +&#10;                    $&quot;• Merged {validSprites.Count} sprites\n&quot; +&#10;                    $&quot;• Atlas size: {atlas.width}x{atlas.height}\n&quot; +&#10;                    &quot;• All project references updated&quot; +&#10;                    &quot;• Use Ctrl+Z to undo if needed&quot;, &quot;OK&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                // Revert undo group on error&#10;                Undo.RevertAllInCurrentGroup();&#10;&#10;                EditorUtility.DisplayDialog(&quot;Error&quot;, $&quot;Failed to create atlas: {e.Message}&quot;, &quot;OK&quot;);&#10;                Debug.LogError($&quot;Atlas creation failed: {e}&quot;);&#10;            }&#10;            finally&#10;            {&#10;                EditorUtility.ClearProgressBar();&#10;            }&#10;        }&#10;&#10;        private Texture2D CreateAtlasTexture(List&lt;Sprite&gt; sprites)&#10;        {&#10;            // Group sprites by their source texture to handle sprite sheets properly&#10;            var textureGroups = sprites.GroupBy(s =&gt; s.texture).ToList();&#10;            var textureRects = new List&lt;Texture2D&gt;();&#10;&#10;            // Create individual textures for each sprite&#10;            for (int groupIndex = 0; groupIndex &lt; textureGroups.Count(); groupIndex++)&#10;            {&#10;                var group = textureGroups[groupIndex];&#10;                Texture2D sourceTexture = GetReadableTexture(group.Key);&#10;&#10;                foreach (Sprite sprite in group)&#10;                {&#10;                    // Extract sprite region from source texture&#10;                    Texture2D spriteTexture = ExtractSpriteTexture(sourceTexture, sprite);&#10;                    if (spriteTexture)&#10;                    {&#10;                        textureRects.Add(spriteTexture);&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (textureRects.Count == 0) return null;&#10;&#10;            // Pack textures into atlas&#10;            Texture2D atlas = new(1, 1, _textureFormat, false)&#10;            {&#10;                filterMode = _filterMode&#10;            };&#10;&#10;            atlas.PackTextures(textureRects.ToArray(), _padding, _maxAtlasSize, false);&#10;&#10;            return atlas;&#10;        }&#10;&#10;        private Texture2D ExtractSpriteTexture(Texture2D sourceTexture, Sprite sprite)&#10;        {&#10;&#10;            Rect textureRect = sprite.textureRect;&#10;            int width = Mathf.FloorToInt(textureRect.width);&#10;            int height = Mathf.FloorToInt(textureRect.height);&#10;&#10;            if (width &lt;= 0 || height &lt;= 0) return null;&#10;&#10;            Texture2D spriteTexture = new(width, height, _textureFormat, false)&#10;            {&#10;                name = sprite.name&#10;            };&#10;&#10;            // Copy pixels from source texture&#10;            var pixels = sourceTexture.GetPixels(&#10;                Mathf.FloorToInt(textureRect.x),&#10;                Mathf.FloorToInt(textureRect.y),&#10;                width,&#10;                height&#10;            );&#10;&#10;            spriteTexture.SetPixels(pixels);&#10;            spriteTexture.Apply();&#10;&#10;            return spriteTexture;&#10;        }&#10;&#10;        private Texture2D GetReadableTexture(Texture2D texture)&#10;        {&#10;            if (texture == null) return null;&#10;&#10;            string path = AssetDatabase.GetAssetPath(texture);&#10;            TextureImporter importer = AssetImporter.GetAtPath(path) as TextureImporter;&#10;&#10;            if (importer == null)&#10;            {&#10;                throw new InvalidOperationException($&quot;Could not get TextureImporter for {texture.name}&quot;);&#10;            }&#10;&#10;            // If already readable, create a copy&#10;            if (importer.isReadable)&#10;            {&#10;                Texture2D copy = new(texture.width, texture.height, texture.format, texture.mipmapCount &gt; 1);&#10;                copy.name = texture.name;&#10;                Graphics.CopyTexture(texture, copy);&#10;                return copy;&#10;            }&#10;&#10;            // Create readable version using RenderTexture&#10;            RenderTexture rt = RenderTexture.GetTemporary(texture.width, texture.height, 0, RenderTextureFormat.Default,&#10;                RenderTextureReadWrite.Linear);&#10;&#10;            Graphics.Blit(texture, rt);&#10;            RenderTexture previous = RenderTexture.active;&#10;            RenderTexture.active = rt;&#10;&#10;            Texture2D readableTexture = new(texture.width, texture.height);&#10;            readableTexture.name = texture.name;&#10;            readableTexture.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);&#10;            readableTexture.Apply();&#10;&#10;            RenderTexture.active = previous;&#10;            RenderTexture.ReleaseTemporary(rt);&#10;&#10;            return readableTexture;&#10;        }&#10;&#10;        private bool ConfigureAtlasImporter(string atlasPath, List&lt;Sprite&gt; originalSprites, Texture2D atlas)&#10;        {&#10;            TextureImporter importer = AssetImporter.GetAtPath(atlasPath) as TextureImporter;&#10;            if (!importer) return false;&#10;&#10;            importer.textureType = TextureImporterType.Sprite;&#10;            importer.spriteImportMode = SpriteImportMode.Multiple;&#10;            importer.filterMode = _filterMode;&#10;            importer.textureCompression = TextureImporterCompression.Uncompressed; // For better quality&#10;&#10;            // Create sprite rectangles&#10;            var spriteRects = new List&lt;SpriteRect&gt;();&#10;&#10;            // Recreate the packing to get correct rectangles&#10;&#10;            Texture2D tempAtlas = new(1, 1);&#10;            var packedRects = tempAtlas.PackTextures(originalSprites&#10;                .Select(sprite =&gt; new { sprite, sourceTexture = GetReadableTexture(sprite.texture) })&#10;                .Select(t =&gt; ExtractSpriteTexture(t.sourceTexture, t.sprite))&#10;                .Where(spriteTexture =&gt; spriteTexture is not null).ToArray(), _padding, _maxAtlasSize, false);&#10;&#10;            for (int i = 0; i &lt; originalSprites.Count &amp;&amp; i &lt; packedRects.Length; i++)&#10;            {&#10;                Sprite sprite = originalSprites[i];&#10;                Rect packedRect = packedRects[i];&#10;&#10;                SpriteRect spriteRect = new()&#10;                {&#10;                    name = sprite.name,&#10;                    rect = new Rect(&#10;                        packedRect.x * atlas.width,&#10;                        packedRect.y * atlas.height,&#10;                        packedRect.width * atlas.width,&#10;                        packedRect.height * atlas.height&#10;                    ),&#10;                    pivot = sprite.textureRect.size == Vector2.zero&#10;                        ? new Vector2(0.5f, 0.5f)&#10;                        : sprite.pivot / sprite.textureRect.size,&#10;                    border = sprite.border,&#10;                    alignment = SpriteAlignment.Custom&#10;                };&#10;&#10;                spriteRects.Add(spriteRect);&#10;            }&#10;&#10;            // Apply sprite rectangles&#10;            SpriteDataProviderFactories factories = new();&#10;            factories.Init();&#10;            ISpriteEditorDataProvider dataProvider = factories.GetSpriteEditorDataProviderFromObject(importer);&#10;            if (dataProvider == null)&#10;            {&#10;                Debug.LogError(&#10;                    &quot;Failed to get SpriteEditorDataProvider from importer. The atlas asset may not be fully imported yet.&quot;);&#10;&#10;                return false;&#10;            }&#10;&#10;            dataProvider.InitSpriteEditorDataProvider();&#10;            dataProvider.SetSpriteRects(spriteRects.ToArray());&#10;            dataProvider.Apply();&#10;&#10;            EditorUtility.SetDirty(importer);&#10;            importer.SaveAndReimport();&#10;&#10;            if (originalSprites.Count &gt; 0 &amp;&amp; originalSprites[0] &amp;&amp; originalSprites[0].texture)&#10;            {&#10;                string srcPath = AssetDatabase.GetAssetPath(originalSprites[0].texture);&#10;                TextureImporter srcImporter = AssetImporter.GetAtPath(srcPath) as TextureImporter;&#10;                if (srcImporter)&#10;                {&#10;                    importer.sRGBTexture = srcImporter.sRGBTexture;&#10;                    importer.mipmapEnabled = srcImporter.mipmapEnabled;&#10;                    importer.filterMode = srcImporter.filterMode;&#10;                    importer.anisoLevel = srcImporter.anisoLevel;&#10;                    importer.wrapMode = srcImporter.wrapMode;&#10;                    importer.npotScale = srcImporter.npotScale;&#10;                    importer.alphaIsTransparency = srcImporter.alphaIsTransparency;&#10;                    importer.compressionQuality = srcImporter.compressionQuality;&#10;                    importer.textureCompression = srcImporter.textureCompression;&#10;                    importer.isReadable = srcImporter.isReadable;&#10;                    importer.maxTextureSize = srcImporter.maxTextureSize;&#10;                    importer.spritePixelsPerUnit = srcImporter.spritePixelsPerUnit;&#10;                }&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        private void UpdateAllProjectReferences(List&lt;Sprite&gt; originalSprites, string atlasPath)&#10;        {&#10;            // Create mapping from old sprites to new sprites&#10;            var spriteMap = CreateSpriteMapping(originalSprites, atlasPath);&#10;            if (spriteMap.Count == 0)&#10;            {&#10;                Debug.LogWarning(&quot;No sprite mapping created. References will not be updated.&quot;);&#10;                return;&#10;            }&#10;&#10;            int totalUpdated = 0;&#10;            string[] allAssetPaths = AssetDatabase.GetAllAssetPaths()&#10;                .Where(path =&gt; path.StartsWith(&quot;Assets/&quot;))&#10;                .ToArray();&#10;&#10;            for (int i = 0; i &lt; allAssetPaths.Length; i++)&#10;            {&#10;                string path = allAssetPaths[i];&#10;&#10;                if (EditorUtility.DisplayCancelableProgressBar(&quot;Updating References&quot;,&#10;                        $&quot;Processing: {Path.GetFileName(path)}&quot;, (float)i / allAssetPaths.Length))&#10;                {&#10;                    break;&#10;                }&#10;&#10;                if (_updateScenes &amp;&amp; path.EndsWith(&quot;.unity&quot;))&#10;                {&#10;                    totalUpdated += UpdateSceneReferences(path, spriteMap);&#10;                }&#10;                else if (_updatePrefabs &amp;&amp; path.EndsWith(&quot;.prefab&quot;))&#10;                {&#10;                    totalUpdated += UpdateAssetReferences(path, spriteMap);&#10;                }&#10;                else if (_updateScriptableObjects &amp;&amp; path.EndsWith(&quot;.asset&quot;))&#10;                {&#10;                    totalUpdated += UpdateAssetReferences(path, spriteMap);&#10;                }&#10;            }&#10;&#10;            AssetDatabase.SaveAssets();&#10;            Debug.Log($&quot;Successfully updated {totalUpdated} sprite references across the project.&quot;);&#10;        }&#10;&#10;        private Dictionary&lt;int, Sprite&gt; CreateSpriteMapping(List&lt;Sprite&gt; originalSprites, string atlasPath)&#10;        {&#10;            var mapping = new Dictionary&lt;int, Sprite&gt;();&#10;            var newSprites = AssetDatabase.LoadAllAssetsAtPath(atlasPath).OfType&lt;Sprite&gt;().ToList();&#10;&#10;            foreach (Sprite originalSprite in originalSprites)&#10;            {&#10;                if (originalSprite == null) continue;&#10;&#10;                Sprite newSprite = newSprites.FirstOrDefault(s =&gt; s != null &amp;&amp; s.name == originalSprite.name);&#10;                if (newSprite != null)&#10;                {&#10;                    mapping[originalSprite.GetInstanceID()] = newSprite;&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;Could not find matching sprite '{originalSprite.name}' in new atlas.&quot;);&#10;                }&#10;            }&#10;&#10;            return mapping;&#10;        }&#10;&#10;        private int UpdateSceneReferences(string scenePath, Dictionary&lt;int, Sprite&gt; spriteMap)&#10;        {&#10;            int count = 0;&#10;            Scene scene = EditorSceneManager.OpenScene(scenePath, OpenSceneMode.Additive);&#10;            if (!scene.IsValid()) return 0;&#10;&#10;            bool sceneModified = false;&#10;&#10;            foreach (GameObject rootGo in scene.GetRootGameObjects())&#10;            {&#10;                if (WillGameObjectBeModified(rootGo, spriteMap))&#10;                {&#10;                    Undo.RegisterCompleteObjectUndo(rootGo, UndoGroupName);&#10;                }&#10;            }&#10;&#10;            foreach (GameObject rootGo in scene.GetRootGameObjects())&#10;            {&#10;                count += UpdateGameObjectReferences(rootGo, spriteMap, ref sceneModified);&#10;            }&#10;&#10;            if (sceneModified)&#10;            {&#10;                EditorSceneManager.SaveScene(scene);&#10;                Debug.Log($&quot;Updated {count} references in scene: {scene.name}&quot;);&#10;            }&#10;&#10;            EditorSceneManager.CloseScene(scene, false);&#10;            return count;&#10;        }&#10;&#10;        private int UpdateGameObjectReferences(GameObject go, Dictionary&lt;int, Sprite&gt; spriteMap, ref bool modified)&#10;        {&#10;            int count = 0;&#10;&#10;            foreach (Component component in go.GetComponentsInChildren&lt;Component&gt;(true))&#10;            {&#10;                if (!component) continue;&#10;&#10;                // Register component for undo before modification&#10;                bool componentWillBeModified = WillComponentBeModified(component, spriteMap);&#10;                if (componentWillBeModified)&#10;                {&#10;                    Undo.RecordObject(component, UndoGroupName);&#10;                }&#10;&#10;                SerializedObject so = new(component);&#10;                SerializedProperty prop = so.GetIterator();&#10;&#10;                while (prop.NextVisible(true))&#10;                {&#10;                    if (prop.propertyType == SerializedPropertyType.ObjectReference &amp;&amp;&#10;                        prop.objectReferenceValue is Sprite oldSprite &amp;&amp;&#10;                        oldSprite != null &amp;&amp;&#10;                        spriteMap.TryGetValue(oldSprite.GetInstanceID(), out Sprite newSprite))&#10;                    {&#10;                        // Store original reference for potential undo&#10;                        if (!OriginalReferences.ContainsKey(component))&#10;                        {&#10;                            OriginalReferences[component] = oldSprite;&#10;                        }&#10;&#10;                        prop.objectReferenceValue = newSprite;&#10;                        modified = true;&#10;                        count++;&#10;                    }&#10;                }&#10;&#10;                if (so.hasModifiedProperties)&#10;                {&#10;                    so.ApplyModifiedProperties();&#10;                    if (componentWillBeModified)&#10;                    {&#10;                        EditorUtility.SetDirty(component);&#10;                    }&#10;                }&#10;            }&#10;&#10;            return count;&#10;        }&#10;&#10;        private int UpdateAssetReferences(string assetPath, Dictionary&lt;int, Sprite&gt; spriteMap)&#10;        {&#10;            int count = 0;&#10;            var assets = AssetDatabase.LoadAllAssetsAtPath(assetPath);&#10;&#10;            foreach (Object asset in assets)&#10;            {&#10;                if (!asset || asset is Texture2D || asset is Sprite) continue;&#10;&#10;                // Check if this asset will be modified and register for undo&#10;                bool assetWillBeModified = WillAssetBeModified(asset, spriteMap);&#10;                if (assetWillBeModified)&#10;                {&#10;                    Undo.RecordObject(asset, UndoGroupName);&#10;                }&#10;&#10;                SerializedObject so = new(asset);&#10;                SerializedProperty prop = so.GetIterator();&#10;                bool assetModified = false;&#10;&#10;                if (prop.NextVisible(true))&#10;                {&#10;                    do&#10;                    {&#10;                        int updated = UpdateSpriteReferencesRecursive(prop, spriteMap, asset);&#10;                        if (updated &gt; 0) assetModified = true;&#10;                        count += updated;&#10;                    } while (prop.NextVisible(false));&#10;                }&#10;&#10;                if (assetModified)&#10;                {&#10;                    so.ApplyModifiedProperties();&#10;                    if (assetWillBeModified)&#10;                    {&#10;                        EditorUtility.SetDirty(asset);&#10;                    }&#10;                }&#10;            }&#10;&#10;            return count;&#10;        }&#10;&#10;        // Recursively update all Sprite references in a SerializedProperty&#10;        private int UpdateSpriteReferencesRecursive(SerializedProperty prop, Dictionary&lt;int, Sprite&gt; spriteMap, Object asset)&#10;        {&#10;            int count = 0;&#10;            if (prop.propertyType == SerializedPropertyType.ObjectReference &amp;&amp;&#10;                prop.objectReferenceValue is Sprite oldSprite &amp;&amp;&#10;                oldSprite != null &amp;&amp;&#10;                spriteMap.TryGetValue(oldSprite.GetInstanceID(), out Sprite newSprite))&#10;            {&#10;                if (!OriginalReferences.ContainsKey(asset))&#10;                {&#10;                    OriginalReferences[asset] = oldSprite;&#10;                }&#10;                prop.objectReferenceValue = newSprite;&#10;                count++;&#10;            }&#10;            // Recursively check children&#10;            if (prop.hasVisibleChildren)&#10;            {&#10;                SerializedProperty child = prop.Copy();&#10;                bool enterChildren = true;&#10;                while (child.NextVisible(enterChildren) &amp;&amp; child.propertyPath.StartsWith(prop.propertyPath))&#10;                {&#10;                    count += UpdateSpriteReferencesRecursive(child, spriteMap, asset);&#10;                    enterChildren = false;&#10;                }&#10;            }&#10;            return count;&#10;        }&#10;&#10;        #region Undo Support Methods&#10;&#10;        private void RegisterCreatedAssetForUndo(string assetPath)&#10;        {&#10;            // Custom undo operation for created assets&#10;            Undo.RegisterCreatedObjectUndo(AssetDatabase.LoadAssetAtPath&lt;Object&gt;(assetPath), UndoGroupName);&#10;        }&#10;&#10;        private bool WillGameObjectBeModified(GameObject go, Dictionary&lt;int, Sprite&gt; spriteMap)&#10;        {&#10;            foreach (Component component in go.GetComponentsInChildren&lt;Component&gt;(true))&#10;            {&#10;                if (component != null &amp;&amp; WillComponentBeModified(component, spriteMap))&#10;                {&#10;                    return true;&#10;                }&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        private bool WillComponentBeModified(Component component, Dictionary&lt;int, Sprite&gt; spriteMap)&#10;        {&#10;            if (component == null) return false;&#10;&#10;            SerializedObject so = new(component);&#10;            SerializedProperty prop = so.GetIterator();&#10;&#10;            while (prop.NextVisible(true))&#10;            {&#10;                if (prop.propertyType == SerializedPropertyType.ObjectReference &amp;&amp;&#10;                    prop.objectReferenceValue is Sprite sprite &amp;&amp;&#10;                    sprite != null &amp;&amp;&#10;                    spriteMap.ContainsKey(sprite.GetInstanceID()))&#10;                {&#10;                    return true;&#10;                }&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        private bool WillAssetBeModified(Object asset, Dictionary&lt;int, Sprite&gt; spriteMap)&#10;        {&#10;            if (asset == null || asset is Texture2D || asset is Sprite) return false;&#10;&#10;            SerializedObject so = new(asset);&#10;            SerializedProperty prop = so.GetIterator();&#10;&#10;            while (prop.NextVisible(true))&#10;            {&#10;                if (prop.propertyType == SerializedPropertyType.ObjectReference &amp;&amp;&#10;                    prop.objectReferenceValue is Sprite sprite &amp;&amp;&#10;                    sprite != null &amp;&amp;&#10;                    spriteMap.ContainsKey(sprite.GetInstanceID()))&#10;                {&#10;                    return true;&#10;                }&#10;            }&#10;&#10;            return false;&#10;        }&#10;&#10;        // Custom undo callback for cleaning up created assets&#10;        [Serializable]&#10;        public class AtlasMergeUndoOperation : ScriptableObject&#10;        {&#10;            public List&lt;string&gt; createdAssetPaths = new();&#10;&#10;            private void OnEnable()&#10;            {&#10;                Undo.undoRedoPerformed += OnUndoRedo;&#10;            }&#10;&#10;            private void OnDisable()&#10;            {&#10;                Undo.undoRedoPerformed -= OnUndoRedo;&#10;            }&#10;&#10;            private void OnUndoRedo()&#10;            {&#10;                // Clean up created assets when undoing&#10;                foreach (string path in createdAssetPaths)&#10;                {&#10;                    if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path))&#10;                    {&#10;                        AssetDatabase.DeleteAsset(path);&#10;                    }&#10;                }&#10;&#10;                AssetDatabase.Refresh();&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Health.Interfaces;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class AlwaysAllowDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        public bool CanBeDamagedBy(GameObject damager) =&gt; true;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All layers by default&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target))&#10;                return;&#10;&#10;            int amount = _dealer?.GetDamageAmount() ?? 1;&#10;            damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using System.Linq;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class BidirectionalDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject other = collision.gameObject;&#10;            GameObject self = gameObject;&#10;&#10;            // 1. This object damages the other&#10;            TryDealDamage(self, other, _dealer, _damageConditions, targetLayers);&#10;&#10;            // 2. The other object damages this&#10;            var otherDealer = other.GetComponent&lt;IDamageDealer&gt;();&#10;            var otherConditions = other.GetComponent&lt;DamageConditionsComponent&gt;();&#10;            TryDealDamage(other, self, otherDealer, otherConditions, targetLayers);&#10;        }&#10;&#10;        private static void TryDealDamage(&#10;            GameObject dealerObj,&#10;            GameObject targetObj,&#10;            IDamageDealer dealer,&#10;            DamageConditionsComponent conditions,&#10;            LayerMask targetLayers)&#10;        {&#10;            if (dealer == null) return;&#10;            if (((1 &lt;&lt; targetObj.layer) &amp; targetLayers) == 0) return;&#10;            var damageable = targetObj.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (conditions &amp;&amp; !conditions.CanBeDamagedBy(targetObj)) return;&#10;            int amount = dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, dealerObj);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;// This script is now deprecated in favor of TakeDamageOnCollision for most use cases.&#10;// Please use TakeDamageOnCollision on all damageable objects instead." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            foreach (IDamageCondition cond in _conditions)&#10;            {&#10;                if (cond != null &amp;&amp; !cond.CanBeDamagedBy(damager))&#10;                    return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            return _conditions.All(cond =&gt; cond == null || cond.CanBeDamagedBy(damager));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs" />
              <option name="originalContent" value="using Health.Damage;&#10;using UnityEditor;&#10;using UnityEngine;&#10;&#10;[CustomPropertyDrawer(typeof(ConditionLeaf))]&#10;public class ConditionLeafPropertyDrawer : ConditionNodePropertyDrawer {}&#10;&#10;[CustomPropertyDrawer(typeof(AndCondition))]&#10;public class AndConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;AND Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(OrCondition))]&#10;public class OrConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;OR Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(NotCondition))]&#10;public class NotConditionPropertyDrawer : ConditionNodePropertyDrawer {}&#10;" />
              <option name="updatedContent" value="// All custom property drawers for node types are now handled by ConditionNodePropertyDrawer.&#10;// This file is no longer needed and can be deleted, or you can leave it empty." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/README.md" />
              <option name="updatedContent" value="// Health/README.md&#10;&#10;# Health System Setup Guide&#10;&#10;## Folder Structure&#10;- `Core/` – Health logic&#10;- `Interfaces/` – All interfaces&#10;- `Shield/` – Shield logic&#10;- `Invincibility/` – Invincibility logic&#10;- `Damage/` – Damage logic and conditions&#10;&#10;## How to Compose Entities in Unity Editor&#10;&#10;### Player (Basic)&#10;- Add `HealthComponent` (Core)&#10;&#10;### Player with Shield&#10;- Add `HealthComponent` (Core)&#10;- Add `ShieldComponent` (Shield)&#10;&#10;### Player with Invincibility&#10;- Add `HealthComponent` (Core)&#10;- Add `InvincibilityComponent` (Invincibility)&#10;- Connect to your `IPowerUp` system to toggle invincibility&#10;&#10;### Enemy&#10;- Add `HealthComponent` (Core)&#10;&#10;### Hazard (Standard)&#10;- Add `HazardComponent` (Damage)&#10;- Add `DamageDealerComponent` (Damage)&#10;- Add a damage condition (e.g., `AlwaysAllowDamage`, `OnlyInvincibleCanDamage`, `OnlyShieldedCanDamage`) as needed&#10;- Assign the condition(s) to the `HazardComponent`'s `damageConditions` array in the Inspector&#10;&#10;### Custom Damage Conditions&#10;- Create a new MonoBehaviour implementing `IDamageCondition`&#10;- Add it to the hazard GameObject&#10;- Assign it in the `HazardComponent`&#10;&#10;## Extending&#10;- To add new damage conditions, create a new script implementing `IDamageCondition` and add it in the Editor. No need to modify existing code.&#10;&#10;## Events&#10;- Use UnityEvents or C# events on components for custom reactions (e.g., OnDeath, OnShieldBroken)&#10;&#10;## Cleanup&#10;- Remove old scripts like `ShieldActiveDisappearHazard`, `OnlyInvincibilityDamageController`, etc. after migration.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// When enabled, instantly kills any damageable object the player collides with.&#10;    /// Should be enabled only when the player is invincible.&#10;    /// &lt;/summary&gt;&#10;    [DisallowMultipleComponent]&#10;    public class PlayerInvincibleDamageDealer : MonoBehaviour, IDamageDealer&#10;    {&#10;        [SerializeField] private int damageAmount = 9999; // &quot;Kill&quot; value&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All by default&#10;&#10;        public int GetDamageAmount() =&gt; damageAmount;&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if (((1 &lt;&lt; collision.gameObject.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            var damageable = collision.gameObject.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable != null)&#10;            {&#10;                damageable.Damage(damageAmount, gameObject);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>