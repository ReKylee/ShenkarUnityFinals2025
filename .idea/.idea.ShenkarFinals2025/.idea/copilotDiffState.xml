<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Core/HealthComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Core/HealthComponent.cs" />
              <option name="originalContent" value="using System;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Core&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HealthComponent : MonoBehaviour, IHealth&#10;    {&#10;        [SerializeField] private int maxHp = 3;&#10;        private bool _isDead;&#10;&#10;        protected void Awake()&#10;        {&#10;            CurrentHp = maxHp;&#10;            _isDead = false;&#10;        }&#10;        public int MaxHp =&gt; maxHp;&#10;        public int CurrentHp { get; private set; }&#10;        public event Action&lt;int, int&gt; OnHealthChanged;&#10;        public event Action OnDeath;&#10;&#10;        public virtual void Damage(int amount, GameObject source = null)&#10;        {&#10;            if (_isDead) return;&#10;            CurrentHp = Mathf.Max(0, CurrentHp - amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;            if (CurrentHp == 0)&#10;            {&#10;                _isDead = true;&#10;                OnDeath?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            if (_isDead) return;&#10;            CurrentHp = Mathf.Min(MaxHp, CurrentHp + amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Core&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HealthComponent : MonoBehaviour, IHealth&#10;    {&#10;        [SerializeField] private int maxHp = 3;&#10;&#10;        protected void Awake()&#10;        {&#10;            CurrentHp = maxHp;&#10;        }&#10;        public int MaxHp =&gt; maxHp;&#10;        public int CurrentHp { get; private set; }&#10;        public event Action&lt;int, int&gt; OnHealthChanged;&#10;        public event Action OnDeath;&#10;&#10;        public virtual void Damage(int amount, GameObject source = null)&#10;        {&#10;            if (CurrentHp == 0) return;&#10;            int prevHp = CurrentHp;&#10;            CurrentHp = Mathf.Max(0, CurrentHp - amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;            if (CurrentHp == 0 &amp;&amp; prevHp &gt; 0)&#10;            {&#10;                OnDeath?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            if (CurrentHp == 0) return;&#10;            CurrentHp = Mathf.Min(MaxHp, CurrentHp + amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Health.Interfaces;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class AlwaysAllowDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        public bool CanBeDamagedBy(GameObject damager) =&gt; true;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OnlyProjectileCanDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OnlyProjectileCanDamage.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class OnlyProjectileCanDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        [SerializeField] private LayerMask projectileTag = LayerMask.NameToLayer(&quot;&quot;);&#10;        public bool CanBeDamagedBy(GameObject damager) =&gt; damager.CompareTag(projectileTag);&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class OnlyProjectileCanDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        [SerializeField] private LayerMask projectileLayers = ~0;&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            return ((1 &lt;&lt; damager.layer) &amp; projectileLayers) != 0;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All layers by default&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target))&#10;                return;&#10;&#10;            int amount = _dealer?.GetDamageAmount() ?? 1;&#10;            damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using System.Linq;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class BidirectionalDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject other = collision.gameObject;&#10;            GameObject self = gameObject;&#10;&#10;            // 1. This object damages the other&#10;            TryDealDamage(self, other, _dealer, _damageConditions, targetLayers);&#10;&#10;            // 2. The other object damages this&#10;            var otherDealer = other.GetComponent&lt;IDamageDealer&gt;();&#10;            var otherConditions = other.GetComponent&lt;DamageConditionsComponent&gt;();&#10;            TryDealDamage(other, self, otherDealer, otherConditions, targetLayers);&#10;        }&#10;&#10;        private static void TryDealDamage(&#10;            GameObject dealerObj,&#10;            GameObject targetObj,&#10;            IDamageDealer dealer,&#10;            DamageConditionsComponent conditions,&#10;            LayerMask targetLayers)&#10;        {&#10;            if (dealer == null) return;&#10;            if (((1 &lt;&lt; targetObj.layer) &amp; targetLayers) == 0) return;&#10;            var damageable = targetObj.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (conditions &amp;&amp; !conditions.CanBeDamagedBy(targetObj)) return;&#10;            int amount = dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, dealerObj);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;// This script is now deprecated in favor of TakeDamageOnCollision for most use cases.&#10;// Please use TakeDamageOnCollision on all damageable objects instead." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            foreach (IDamageCondition cond in _conditions)&#10;            {&#10;                if (cond != null &amp;&amp; !cond.CanBeDamagedBy(damager))&#10;                    return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            return _conditions.All(cond =&gt; cond == null || cond.CanBeDamagedBy(damager));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs" />
              <option name="originalContent" value="using Health.Damage;&#10;using UnityEditor;&#10;using UnityEngine;&#10;&#10;[CustomPropertyDrawer(typeof(ConditionLeaf))]&#10;public class ConditionLeafPropertyDrawer : ConditionNodePropertyDrawer {}&#10;&#10;[CustomPropertyDrawer(typeof(AndCondition))]&#10;public class AndConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;AND Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(OrCondition))]&#10;public class OrConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;OR Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(NotCondition))]&#10;public class NotConditionPropertyDrawer : ConditionNodePropertyDrawer {}&#10;" />
              <option name="updatedContent" value="// All custom property drawers for node types are now handled by ConditionNodePropertyDrawer.&#10;// This file is no longer needed and can be deleted, or you can leave it empty." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Invincibility/InvincibilityComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Invincibility/InvincibilityComponent.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Invincibility&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class InvincibilityComponent : MonoBehaviour, IInvincibility&#10;    {&#10;        public bool IsInvincible { get; private set; }&#10;        public void SetInvincible(bool value)&#10;        {&#10;            IsInvincible = value;&#10;        }&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Invincibility&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class InvincibilityComponent : MonoBehaviour, IInvincibility, IDamageDealer&#10;    {&#10;        public bool IsInvincible { get; private set; }&#10;        public void SetInvincible(bool value)&#10;        {&#10;            IsInvincible = value;&#10;        }&#10;&#10;        public int GetDamageAmount() =&gt; IsInvincible ? 9999 : 0;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/README.md" />
              <option name="updatedContent" value="// Health/README.md&#10;&#10;# Health System Setup Guide&#10;&#10;## Folder Structure&#10;- `Core/` – Health logic&#10;- `Interfaces/` – All interfaces&#10;- `Shield/` – Shield logic&#10;- `Invincibility/` – Invincibility logic&#10;- `Damage/` – Damage logic and conditions&#10;&#10;## How to Compose Entities in Unity Editor&#10;&#10;### Player (Basic)&#10;- Add `HealthComponent` (Core)&#10;&#10;### Player with Shield&#10;- Add `HealthComponent` (Core)&#10;- Add `ShieldComponent` (Shield)&#10;&#10;### Player with Invincibility&#10;- Add `HealthComponent` (Core)&#10;- Add `InvincibilityComponent` (Invincibility)&#10;- Connect to your `IPowerUp` system to toggle invincibility&#10;&#10;### Enemy&#10;- Add `HealthComponent` (Core)&#10;&#10;### Hazard (Standard)&#10;- Add `HazardComponent` (Damage)&#10;- Add `DamageDealerComponent` (Damage)&#10;- Add a damage condition (e.g., `AlwaysAllowDamage`, `OnlyInvincibleCanDamage`, `OnlyShieldedCanDamage`) as needed&#10;- Assign the condition(s) to the `HazardComponent`'s `damageConditions` array in the Inspector&#10;&#10;### Custom Damage Conditions&#10;- Create a new MonoBehaviour implementing `IDamageCondition`&#10;- Add it to the hazard GameObject&#10;- Assign it in the `HazardComponent`&#10;&#10;## Extending&#10;- To add new damage conditions, create a new script implementing `IDamageCondition` and add it in the Editor. No need to modify existing code.&#10;&#10;## Events&#10;- Use UnityEvents or C# events on components for custom reactions (e.g., OnDeath, OnShieldBroken)&#10;&#10;## Cleanup&#10;- Remove old scripts like `ShieldActiveDisappearHazard`, `OnlyInvincibilityDamageController`, etc. after migration.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Views/BarsHealthView.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Views/BarsHealthView.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace Health&#10;{&#10;    public class BarsHealthView : MonoBehaviour, IHealthView&#10;    {&#10;        [SerializeField] private Image bar;&#10;&#10;        public void UpdateDisplay(int currentHp, int maxHp)&#10;        {&#10;            // Truncate the fill amount to 3 decimal places&#10;            bar.fillAmount = Mathf.Floor((float)currentHp / maxHp * 1000f) / 1000f;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace Health&#10;{&#10;    public class BarsHealthView : MonoBehaviour, IHealthView&#10;    {&#10;        [SerializeField] private Image bar;&#10;&#10;        public void UpdateDisplay(int currentHp, int maxHp)&#10;        {&#10;            // Truncate the fill amount to 3 decimal places&#10;            bar.fillAmount = Mathf.Floor((float)currentHp / maxHp * 1000f) / 1000f;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerHealthController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerHealthController.cs" />
              <option name="originalContent" value="using Core;&#10;using Core.Events;&#10;using Health;&#10;using Health.Core;&#10;using Health.Interfaces;&#10;using Player.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Components&#10;{&#10;    public class PlayerHealthController : HealthComponent, IBypassableDamageable&#10;    {&#10;        [SerializeField] private BarsHealthView healthView;&#10;        private IEventBus _eventBus;&#10;        private GameFlowManager _gameFlowManager;&#10;        private IPlayerLivesService _livesService;&#10;        private IShield _shield;&#10;        private IInvincibility _invincibility;&#10;&#10;        #region VContainer Injection&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, IPlayerLivesService livesService, GameFlowManager gameFlowManager)&#10;        {&#10;            _eventBus = eventBus;&#10;            _livesService = livesService;&#10;            _gameFlowManager = gameFlowManager;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Unity Lifecycle&#10;&#10;        private new void Awake()&#10;        {&#10;            base.Awake();&#10;            _shield = GetComponent&lt;IShield&gt;();&#10;            _invincibility = GetComponent&lt;IInvincibility&gt;();&#10;        }&#10;&#10;        protected void Start()&#10;        {&#10;            healthView.UpdateDisplay(CurrentHp, MaxHp);&#10;            OnHealthChanged += HandleHealthChanged;&#10;            OnDeath += HandleHealthEmpty;&#10;        }&#10;&#10;        protected void OnDestroy()&#10;        {&#10;            OnHealthChanged -= HandleHealthChanged;&#10;            OnDeath -= HandleHealthEmpty;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Event Handlers&#10;&#10;        private void HandleHealthChanged(int hp, int maxHp)&#10;        {&#10;            healthView.UpdateDisplay(hp, maxHp);&#10;            _eventBus?.Publish(new PlayerHealthChangedEvent&#10;            {&#10;                CurrentHp = hp,&#10;                MaxHp = maxHp,&#10;                Damage = maxHp - hp,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private void HandleHealthEmpty()&#10;        {&#10;            if (_livesService == null)&#10;            {&#10;                Debug.LogError(&quot;[PlayerHealthController] _livesService is null. Ensure it is properly injected.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (!_gameFlowManager)&#10;            {&#10;                Debug.LogError(&quot;[PlayerHealthController] _gameFlowManager is null. Ensure it is properly injected.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (_livesService.TryUseLife())&#10;            {&#10;                Debug.Log(&#10;                    $&quot;[PlayerHealthController] Used a life, restored health. Lives remaining: {_livesService.CurrentLives}&quot;);&#10;&#10;                return;&#10;            }&#10;&#10;            _gameFlowManager.HandlePlayerDeath(transform.position);&#10;        }&#10;&#10;        #endregion&#10;&#10;&#10;        #region Damage Handling&#10;&#10;        public override void Damage(int amount, GameObject source = null)&#10;        {&#10;            if (_invincibility is { IsInvincible: true })&#10;                return;&#10;            if (_shield is { IsActive: true })&#10;            {&#10;                _shield.BreakShield(amount);&#10;                return;&#10;            }&#10;&#10;            base.Damage(amount, source);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Damage that bypasses transformation shield (used by continuous damage, etc.)&#10;        /// &lt;/summary&gt;&#10;        public void DamageBypass(int amount)&#10;        {&#10;            base.Damage(amount, gameObject);&#10;        }&#10;&#10;        #endregion&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Core;&#10;using Core.Events;&#10;using Health;&#10;using Health.Core;&#10;using Health.Interfaces;&#10;using Player.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Components&#10;{&#10;    public class PlayerHealthController : HealthComponent, IBypassableDamageable&#10;    {&#10;        [SerializeField] private BarsHealthView healthView;&#10;        private IEventBus _eventBus;&#10;        private GameFlowManager _gameFlowManager;&#10;        private IPlayerLivesService _livesService;&#10;        private IShield _shield;&#10;        private IInvincibility _invincibility;&#10;&#10;        #region VContainer Injection&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, IPlayerLivesService livesService, GameFlowManager gameFlowManager)&#10;        {&#10;            _eventBus = eventBus;&#10;            _livesService = livesService;&#10;            _gameFlowManager = gameFlowManager;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Unity Lifecycle&#10;&#10;        private new void Awake()&#10;        {&#10;            base.Awake();&#10;            _shield = GetComponent&lt;IShield&gt;();&#10;            _invincibility = GetComponent&lt;IInvincibility&gt;();&#10;        }&#10;&#10;        protected void Start()&#10;        {&#10;            healthView.UpdateDisplay(CurrentHp, MaxHp);&#10;            OnHealthChanged += HandleHealthChanged;&#10;            OnDeath += HandleHealthEmpty;&#10;        }&#10;&#10;        protected void OnDestroy()&#10;        {&#10;            OnHealthChanged -= HandleHealthChanged;&#10;            OnDeath -= HandleHealthEmpty;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Event Handlers&#10;&#10;        private void HandleHealthChanged(int hp, int maxHp)&#10;        {&#10;            Debug.Log($&quot;[PlayerHealthController] HandleHealthChanged called: hp={hp}, maxHp={maxHp}&quot;);&#10;            healthView.UpdateDisplay(hp, maxHp);&#10;            _eventBus?.Publish(new PlayerHealthChangedEvent&#10;            {&#10;                CurrentHp = hp,&#10;                MaxHp = maxHp,&#10;                Damage = maxHp - hp,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private void HandleHealthEmpty()&#10;        {&#10;            Debug.Log($&quot;[PlayerHealthController] HandleHealthEmpty called. Lives: {_livesService?.CurrentLives}&quot;);&#10;            if (_livesService == null)&#10;            {&#10;                Debug.LogError(&quot;[PlayerHealthController] _livesService is null. Ensure it is properly injected.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (!_gameFlowManager)&#10;            {&#10;                Debug.LogError(&quot;[PlayerHealthController] _gameFlowManager is null. Ensure it is properly injected.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (_livesService.TryUseLife())&#10;            {&#10;                Debug.Log(&#10;                    $&quot;[PlayerHealthController] Used a life, waiting for scene reload. Lives remaining: {_livesService.CurrentLives}&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log(&quot;[PlayerHealthController] No lives left, calling HandlePlayerDeath.&quot;);&#10;            _gameFlowManager.HandlePlayerDeath(transform.position);&#10;        }&#10;&#10;        #endregion&#10;&#10;&#10;        #region Damage Handling&#10;&#10;        public override void Damage(int amount, GameObject source = null)&#10;        {&#10;            Debug.Log($&quot;[PlayerHealthController] Damage called: amount={amount}, invincible={_invincibility?.IsInvincible}, shieldActive={_shield?.IsActive}&quot;);&#10;            if (_invincibility is { IsInvincible: true })&#10;                return;&#10;            if (_shield is { IsActive: true })&#10;            {&#10;                Debug.Log(&quot;[PlayerHealthController] Shield active, breaking shield.&quot;);&#10;                _shield.BreakShield(amount);&#10;                return;&#10;            }&#10;&#10;            base.Damage(amount, source);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Damage that bypasses transformation shield (used by continuous damage, etc.)&#10;        /// &lt;/summary&gt;&#10;        public void DamageBypass(int amount)&#10;        {&#10;            base.Damage(amount, gameObject);&#10;        }&#10;&#10;        #endregion&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// When enabled, instantly kills any damageable object the player collides with.&#10;    /// Should be enabled only when the player is invincible.&#10;    /// &lt;/summary&gt;&#10;    [DisallowMultipleComponent]&#10;    public class PlayerInvincibleDamageDealer : MonoBehaviour, IDamageDealer&#10;    {&#10;        [SerializeField] private int damageAmount = 9999; // &quot;Kill&quot; value&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All by default&#10;&#10;        public int GetDamageAmount() =&gt; damageAmount;&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if (((1 &lt;&lt; collision.gameObject.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            var damageable = collision.gameObject.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable != null)&#10;            {&#10;                damageable.Damage(damageAmount, gameObject);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>