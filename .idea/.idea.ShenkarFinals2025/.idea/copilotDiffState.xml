<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/ScoreController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/ScoreController.cs" />
              <option name="originalContent" value="using Collectables.Counter;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Collectables.Score&#10;{&#10;    public class ScoreController : MonoBehaviour&#10;    {&#10;        [SerializeField] private PaddedTextView scoreTextView;&#10;        [SerializeField] private PaddedTextView fruitCountHealthView;&#10;        private ICounterView _fruitCountHealthView;&#10;&#10;        private IScoreService _scoreService;&#10;        private ICounterView _scoreTextView;&#10;        private void Awake()&#10;        {&#10;            _scoreTextView = scoreTextView;&#10;            _fruitCountHealthView = fruitCountHealthView;&#10;        }&#10;        private void Start()&#10;        {&#10;            if (scoreTextView)&#10;            {&#10;                _scoreTextView.UpdateCountDisplay(_scoreService.CurrentScore);&#10;            }&#10;&#10;            if (fruitCountHealthView)&#10;            {&#10;                _fruitCountHealthView.UpdateCountDisplay(_scoreService.FruitCollectedCount);&#10;            }&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected += HandleScoreCollected;&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected -= HandleScoreCollected;&#10;        }&#10;&#10;        #region VContainer Injection&#10;&#10;        [Inject]&#10;        public void Construct(IScoreService scoreService)&#10;        {&#10;            _scoreService = scoreService;&#10;        }&#10;&#10;        #endregion&#10;&#10;        private void HandleScoreCollected(int scoreAmount, Vector3 position)&#10;        {&#10;            _scoreService.AddScore(scoreAmount);&#10;            _scoreService.AddFruitCollected(position);&#10;            if (scoreTextView)&#10;            {&#10;                _scoreTextView.UpdateCountDisplay(_scoreService.CurrentScore);&#10;            }&#10;&#10;            if (fruitCountHealthView)&#10;            {&#10;                _fruitCountHealthView.UpdateCountDisplay(_scoreService.FruitCollectedCount);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Collectables.Counter;&#10;using Core.Events;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Collectables.Score&#10;{&#10;    public class ScoreController : MonoBehaviour&#10;    {&#10;        [SerializeField] private PaddedTextView scoreTextView;&#10;        [SerializeField] private PaddedTextView fruitCountHealthView;&#10;        private ICounterView _fruitCountHealthView;&#10;&#10;        private IScoreService _scoreService;&#10;        private IEventBus _eventBus;&#10;        private ICounterView _scoreTextView;&#10;        &#10;        private void Awake()&#10;        {&#10;            _scoreTextView = scoreTextView;&#10;            _fruitCountHealthView = fruitCountHealthView;&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            if (scoreTextView)&#10;            {&#10;                _scoreTextView.UpdateCountDisplay(_scoreService.CurrentScore);&#10;            }&#10;&#10;            if (fruitCountHealthView)&#10;            {&#10;                _fruitCountHealthView.UpdateCountDisplay(_scoreService.FruitCollectedCount);&#10;            }&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected += HandleScoreCollected;&#10;            _eventBus?.Subscribe&lt;ScoreChangedEvent&gt;(OnScoreChanged);&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected -= HandleScoreCollected;&#10;            _eventBus?.Unsubscribe&lt;ScoreChangedEvent&gt;(OnScoreChanged);&#10;        }&#10;&#10;        private void OnScoreChanged(ScoreChangedEvent scoreEvent)&#10;        {&#10;            _scoreTextView?.UpdateCountDisplay(scoreEvent.NewScore);&#10;        }&#10;&#10;        #region VContainer Injection&#10;&#10;        [Inject]&#10;        public void Construct(IScoreService scoreService, IEventBus eventBus)&#10;        {&#10;            _scoreService = scoreService;&#10;            _eventBus = eventBus;&#10;        }&#10;&#10;        #endregion&#10;&#10;        private void HandleScoreCollected(int scoreAmount)&#10;        {&#10;            _scoreService.AddScore(scoreAmount);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/ScoreService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/ScoreService.cs" />
              <option name="originalContent" value="using Core;&#10;using Player.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Collectables.Score&#10;{&#10;    public class ScoreService : IScoreService&#10;    {&#10;        private const int OneUpThreshold = 30;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private IPlayerLivesService _livesService;&#10;        &#10;        public int CurrentScore =&gt; _gameDataCoordinator?.GetCurrentScore() ?? 0;&#10;        &#10;        public void AddScore(int amount)&#10;        {&#10;            int newScore = CurrentScore + amount;&#10;            _gameDataCoordinator?.UpdateScore(newScore);&#10;        }&#10;        &#10;        public void ResetScore()&#10;        {&#10;            _gameDataCoordinator?.UpdateScore(0);&#10;        }&#10;        &#10;        public void AddFruitCollected(Vector3 collectPosition)&#10;        {&#10;            _gameDataCoordinator?.AddFruitCollected();&#10;            int fruitCount = FruitCollectedCount;&#10;            if (fruitCount &gt; 0 &amp;&amp; fruitCount % OneUpThreshold == 0)&#10;            {&#10;                _livesService?.AddLife(collectPosition);&#10;                Debug.Log(&quot;One-up awarded! Player gained an extra life.&quot;);&#10;            }&#10;        }&#10;        &#10;        public int FruitCollectedCount =&gt; _gameDataCoordinator?.GetFruitCollectedCount() ?? 0;&#10;        &#10;        [Inject]&#10;        public void Construct(GameDataCoordinator gameDataCoordinator, IPlayerLivesService livesService)&#10;        {&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            _livesService = livesService;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Core;&#10;using Core.Events;&#10;using Player.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Collectables.Score&#10;{&#10;    public class ScoreService : IScoreService&#10;    {&#10;        private const int OneUpThreshold = 30;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private IPlayerLivesService _livesService;&#10;        private IEventBus _eventBus;&#10;        &#10;        public int CurrentScore =&gt; _gameDataCoordinator?.GetCurrentScore() ?? 0;&#10;        &#10;        public void AddScore(int amount)&#10;        {&#10;            int previousScore = CurrentScore;&#10;            int newScore = previousScore + amount;&#10;            _gameDataCoordinator?.UpdateScore(newScore);&#10;            &#10;            // Publish score changed event for UI updates&#10;            _eventBus?.Publish(new ScoreChangedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                NewScore = newScore,&#10;                ScoreChange = amount&#10;            });&#10;        }&#10;        &#10;        public void ResetScore()&#10;        {&#10;            _gameDataCoordinator?.UpdateScore(0);&#10;        }&#10;        &#10;        public void AddFruitCollected(Vector3 collectPosition)&#10;        {&#10;            _gameDataCoordinator?.AddFruitCollected();&#10;            int fruitCount = FruitCollectedCount;&#10;            if (fruitCount &gt; 0 &amp;&amp; fruitCount % OneUpThreshold == 0)&#10;            {&#10;                _livesService?.AddLife(collectPosition);&#10;                Debug.Log(&quot;One-up awarded! Player gained an extra life.&quot;);&#10;            }&#10;        }&#10;        &#10;        public int FruitCollectedCount =&gt; _gameDataCoordinator?.GetFruitCollectedCount() ?? 0;&#10;        &#10;        [Inject]&#10;        public void Construct(GameDataCoordinator gameDataCoordinator, IPlayerLivesService livesService, IEventBus eventBus)&#10;        {&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            _livesService = livesService;&#10;            _eventBus = eventBus;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/DI/GameLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/DI/GameLifetimeScope.cs" />
              <option name="originalContent" value="using Collectables.Score;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using Player.Interfaces;&#10;using Player.Services;&#10;using Player.UI;&#10;using Pooling;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;using Weapons.Models;&#10;using Weapons.Services;&#10;&#10;namespace Core.DI&#10;{&#10;    public class GameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Awake()&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Awake called.&quot;);&#10;            AddToAutoInject&lt;FireballWeapon&gt;();&#10;            base.Awake();&#10;        }&#10;&#10;        private void AddToAutoInject&lt;T&gt;() where T : Component&#10;        {&#10;&#10;            var components = FindObjectsByType&lt;T&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;&#10;            foreach (T comp in components)&#10;            {&#10;                autoInjectGameObjects.Add(comp.gameObject);&#10;            }&#10;        }&#10;&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Configuring DI container...&quot;);&#10;&#10;            // Register Core Services&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;&#10;            // Register EventBus as IEventPublisher as well (since EventBus implements IEventPublisher)&#10;            builder.Register&lt;IEventPublisher&gt;(resolver =&gt; resolver.Resolve&lt;IEventBus&gt;(), Lifetime.Singleton);&#10;&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IScoreService, ScoreService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ILevelDiscoveryService, LevelDiscoveryService&gt;(Lifetime.Singleton);&#10;            builder.RegisterComponentInHierarchy&lt;SceneLoadService&gt;().As&lt;ISceneLoadService&gt;();&#10;&#10;&#10;            // Register Player Services&#10;            builder.Register&lt;IPlayerLivesService&gt;(resolver&#10;                =&gt; new PlayerLivesService(&#10;                    resolver.Resolve&lt;GameDataCoordinator&gt;()&#10;                ), Lifetime.Singleton);&#10;&#10;&#10;            // Game Management&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;EndLevelZone&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;HealthBonusService&gt;();&#10;            // Pooling System&#10;            builder.RegisterComponentInHierarchy&lt;PoolManager&gt;().As&lt;IPoolService&gt;();&#10;&#10;            // Weapons&#10;            builder.RegisterComponentInHierarchy&lt;AxeWeapon&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;WeaponManagerService&gt;();&#10;&#10;            // Health&#10;            builder.RegisterComponentInHierarchy&lt;PlayerHealthController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerLivesUIController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerAnimationController&gt;();&#10;&#10;            // Score System&#10;            builder.RegisterComponentInHierarchy&lt;ScoreController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PopupTextService&gt;();&#10;&#10;&#10;            Debug.Log(&quot;[GameLifetimeScope] DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Collectables.Score;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using Health.Damage;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using Player.Interfaces;&#10;using Player.Services;&#10;using Player.UI;&#10;using Pooling;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;using Weapons.Models;&#10;using Weapons.Services;&#10;&#10;namespace Core.DI&#10;{&#10;    public class GameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Awake()&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Awake called.&quot;);&#10;            AddToAutoInject&lt;FireballWeapon&gt;();&#10;            base.Awake();&#10;        }&#10;&#10;        private void AddToAutoInject&lt;T&gt;() where T : Component&#10;        {&#10;&#10;            var components = FindObjectsByType&lt;T&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);&#10;&#10;            foreach (T comp in components)&#10;            {&#10;                autoInjectGameObjects.Add(comp.gameObject);&#10;            }&#10;        }&#10;&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Configuring DI container...&quot;);&#10;&#10;            // Register Core Services&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;&#10;            // Register EventBus as IEventPublisher as well (since EventBus implements IEventPublisher)&#10;            builder.Register&lt;IEventPublisher&gt;(resolver =&gt; resolver.Resolve&lt;IEventBus&gt;(), Lifetime.Singleton);&#10;&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IScoreService, ScoreService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ILevelDiscoveryService, LevelDiscoveryService&gt;(Lifetime.Singleton);&#10;            builder.RegisterComponentInHierarchy&lt;SceneLoadService&gt;().As&lt;ISceneLoadService&gt;();&#10;&#10;&#10;            // Register Player Services&#10;            builder.Register&lt;IPlayerLivesService&gt;(resolver&#10;                =&gt; new PlayerLivesService(&#10;                    resolver.Resolve&lt;GameDataCoordinator&gt;()&#10;                ), Lifetime.Singleton);&#10;&#10;&#10;            // Game Management&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;EndLevelZone&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;HealthBonusService&gt;();&#10;            // Pooling System&#10;            builder.RegisterComponentInHierarchy&lt;PoolManager&gt;().As&lt;IPoolService&gt;();&#10;&#10;            // Weapons&#10;            builder.RegisterComponentInHierarchy&lt;AxeWeapon&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;WeaponManagerService&gt;();&#10;&#10;            // Health&#10;            builder.RegisterComponentInHierarchy&lt;PlayerHealthController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerLivesUIController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerAnimationController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PeriodicBypassDamageDealer&gt;();&#10;&#10;            // Score System&#10;            builder.RegisterComponentInHierarchy&lt;ScoreController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PopupTextService&gt;();&#10;&#10;&#10;            Debug.Log(&quot;[GameLifetimeScope] DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Data/GameDataService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Data/GameDataService.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Core.Data&#10;{&#10;    public class GameDataService : IGameDataService&#10;    {&#10;        private readonly IGameDataRepository _repository;&#10;&#10;        [Inject]&#10;        public GameDataService(IGameDataRepository repository)&#10;        {&#10;            _repository = repository;&#10;            CurrentData = _repository.LoadData();&#10;        }&#10;&#10;        public GameData CurrentData { get; private set; }&#10;&#10;        public event Action&lt;GameData&gt; OnDataChanged;&#10;&#10;        public void UpdateLives(int lives)&#10;        {&#10;            CurrentData.lives = lives;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateScore(int score)&#10;        {&#10;            int previousScore = CurrentData.score;&#10;            CurrentData.score = score;&#10;            &#10;            // Update maxScore if current score is higher&#10;            if (score &gt; CurrentData.maxScore)&#10;            {&#10;                CurrentData.maxScore = score;&#10;                Debug.Log($&quot;[GameDataService] New high score achieved: {score}&quot;);&#10;            }&#10;            &#10;            Debug.Log($&quot;[GameDataService] Score updated: {previousScore} -&gt; {score}, MaxScore: {CurrentData.maxScore}&quot;);&#10;            NotifyDataChanged();&#10;            &#10;            // Force save on score changes to ensure persistence&#10;            SaveData();&#10;        }&#10;&#10;&#10;        public void UpdateCurrentLevel(string levelName)&#10;        {&#10;            CurrentData.currentLevel = levelName;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateBestTime(string levelName, float time)&#10;        {&#10;            var gameData = CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update overall best time&#10;            if (time &lt; gameData.bestTime)&#10;            {&#10;                gameData.bestTime = time;&#10;            }&#10;&#10;            // Update per-level best time&#10;            if (!gameData.LevelBestTimes.ContainsKey(levelName) || time &lt; gameData.LevelBestTimes[levelName])&#10;            {&#10;                gameData.LevelBestTimes[levelName] = time;&#10;            }&#10;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void ResetAllData()&#10;        {&#10;            _repository.DeleteData();&#10;            CurrentData = _repository.LoadData();&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void ResetProgressData()&#10;        {&#10;            // Reset only player progress data, preserve score and fruit count&#10;            CurrentData.lives = GameData.MaxLives;&#10;            CurrentData.currentLevel = &quot;&quot;;&#10;            CurrentData.selectedLevelIndex = 0;&#10;            // Note: Score, maxScore, fruitCollected, unlockedLevels, completedLevels, and best times are preserved&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void SaveData()&#10;        {&#10;            _repository.SaveData(CurrentData);&#10;        }&#10;&#10;        public void AddFruitCollected()&#10;        {&#10;            CurrentData.fruitCollected++;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime)&#10;        {&#10;            var gameData = CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update completed levels list&#10;            if (isCompleted &amp;&amp; !gameData.completedLevels.Contains(levelName))&#10;            {&#10;                gameData.completedLevels.Add(levelName);&#10;            }&#10;&#10;            // Update best time&#10;            if (!gameData.LevelBestTimes.ContainsKey(levelName) || completionTime &lt; gameData.LevelBestTimes[levelName])&#10;            {&#10;                gameData.LevelBestTimes[levelName] = completionTime;&#10;            }&#10;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UnlockLevel(string levelName)&#10;        {&#10;            if (CurrentData != null &amp;&amp; !string.IsNullOrEmpty(levelName) &amp;&amp; !CurrentData.unlockedLevels.Contains(levelName))&#10;            {&#10;                CurrentData.unlockedLevels.Add(levelName);&#10;                Debug.Log($&quot;[GameDataService] Level '{levelName}' unlocked and added to unlocked levels list&quot;);&#10;                NotifyDataChanged();&#10;                SaveData(); &#10;            }&#10;        }&#10;&#10;        public async Task&lt;List&lt;LevelData&gt;&gt; GetLevelDataAsync(ILevelDiscoveryService discoveryService)&#10;        {&#10;            if (CurrentData.levelDataCacheValid &amp;&amp; CurrentData.cachedLevelData.Any())&#10;            {&#10;                // Always re-apply default unlock status in case settings changed&#10;                ApplyDefaultUnlockStatus(CurrentData.cachedLevelData);&#10;                return CurrentData.cachedLevelData;&#10;            }&#10;&#10;            var discoveredLevels = await discoveryService.DiscoverLevelsFromSceneAsync();&#10;            CacheLevelData(discoveredLevels);&#10;            return discoveredLevels;&#10;        }&#10;&#10;        private void CacheLevelData(List&lt;LevelData&gt; levelData)&#10;        {&#10;            CurrentData.cachedLevelData = new List&lt;LevelData&gt;(levelData.OrderBy(l =&gt; l.levelIndex));&#10;            CurrentData.levelDataCacheValid = true;&#10;&#10;            // Apply default unlock status from level data&#10;            ApplyDefaultUnlockStatus(levelData);&#10;&#10;            SaveData();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Apply default unlock status from discovered level data&#10;        /// &lt;/summary&gt;&#10;        private void ApplyDefaultUnlockStatus(List&lt;LevelData&gt; levelData)&#10;        {&#10;            foreach (LevelData level in levelData.Where(level =&gt;&#10;                         level.UnlockedByDefault &amp;&amp; !CurrentData.unlockedLevels.Contains(level.levelName)))&#10;            {&#10;                CurrentData.unlockedLevels.Add(level.levelName);&#10;                Debug.Log($&quot;[GameDataService] Auto-unlocked level: {level.levelName} (UnlockedByDefault = true)&quot;);&#10;            }&#10;        }&#10;&#10;        private void NotifyDataChanged()&#10;        {&#10;            OnDataChanged?.Invoke(CurrentData);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Core.Data&#10;{&#10;    public class GameDataService : IGameDataService&#10;    {&#10;        private readonly IGameDataRepository _repository;&#10;&#10;        [Inject]&#10;        public GameDataService(IGameDataRepository repository)&#10;        {&#10;            _repository = repository;&#10;            CurrentData = _repository.LoadData();&#10;        }&#10;&#10;        public GameData CurrentData { get; private set; }&#10;&#10;        public event Action&lt;GameData&gt; OnDataChanged;&#10;&#10;        public void UpdateLives(int lives)&#10;        {&#10;            CurrentData.lives = lives;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateScore(int score)&#10;        {&#10;            int previousScore = CurrentData.score;&#10;            CurrentData.score = score;&#10;            &#10;            // Update maxScore if current score is higher&#10;            if (score &gt; CurrentData.maxScore)&#10;            {&#10;                CurrentData.maxScore = score;&#10;                Debug.Log($&quot;[GameDataService] New high score achieved: {score}&quot;);&#10;            }&#10;            &#10;            Debug.Log($&quot;[GameDataService] Score updated: {previousScore} -&gt; {score}, MaxScore: {CurrentData.maxScore}&quot;);&#10;            NotifyDataChanged();&#10;            &#10;            // Force save on score changes to ensure persistence&#10;            SaveData();&#10;        }&#10;&#10;&#10;        public void UpdateCurrentLevel(string levelName)&#10;        {&#10;            CurrentData.currentLevel = levelName;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateBestTime(string levelName, float time)&#10;        {&#10;            var gameData = CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update overall best time&#10;            if (time &lt; gameData.bestTime)&#10;            {&#10;                gameData.bestTime = time;&#10;            }&#10;&#10;            // Update per-level best time&#10;            if (!gameData.LevelBestTimes.ContainsKey(levelName) || time &lt; gameData.LevelBestTimes[levelName])&#10;            {&#10;                gameData.LevelBestTimes[levelName] = time;&#10;            }&#10;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void ResetAllData()&#10;        {&#10;            _repository.DeleteData();&#10;            CurrentData = _repository.LoadData();&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void ResetProgressData()&#10;        {&#10;            // Reset only level-specific progress data, preserve lives, score and fruit count&#10;            CurrentData.currentLevel = &quot;&quot;;&#10;            CurrentData.selectedLevelIndex = 0;&#10;            // Note: Lives, score, maxScore, fruitCollected, unlockedLevels, completedLevels, and best times are preserved&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void SaveData()&#10;        {&#10;            _repository.SaveData(CurrentData);&#10;        }&#10;&#10;        public void AddFruitCollected()&#10;        {&#10;            CurrentData.fruitCollected++;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime)&#10;        {&#10;            var gameData = CurrentData;&#10;            if (gameData == null) return;&#10;&#10;            // Update completed levels list&#10;            if (isCompleted &amp;&amp; !gameData.completedLevels.Contains(levelName))&#10;            {&#10;                gameData.completedLevels.Add(levelName);&#10;            }&#10;&#10;            // Update best time&#10;            if (!gameData.LevelBestTimes.ContainsKey(levelName) || completionTime &lt; gameData.LevelBestTimes[levelName])&#10;            {&#10;                gameData.LevelBestTimes[levelName] = completionTime;&#10;            }&#10;&#10;            NotifyDataChanged();&#10;        }&#10;&#10;        public void UnlockLevel(string levelName)&#10;        {&#10;            if (CurrentData != null &amp;&amp; !string.IsNullOrEmpty(levelName) &amp;&amp; !CurrentData.unlockedLevels.Contains(levelName))&#10;            {&#10;                CurrentData.unlockedLevels.Add(levelName);&#10;                Debug.Log($&quot;[GameDataService] Level '{levelName}' unlocked and added to unlocked levels list&quot;);&#10;                NotifyDataChanged();&#10;                SaveData(); &#10;            }&#10;        }&#10;&#10;        public async Task&lt;List&lt;LevelData&gt;&gt; GetLevelDataAsync(ILevelDiscoveryService discoveryService)&#10;        {&#10;            if (CurrentData.levelDataCacheValid &amp;&amp; CurrentData.cachedLevelData.Any())&#10;            {&#10;                // Always re-apply default unlock status in case settings changed&#10;                ApplyDefaultUnlockStatus(CurrentData.cachedLevelData);&#10;                return CurrentData.cachedLevelData;&#10;            }&#10;&#10;            var discoveredLevels = await discoveryService.DiscoverLevelsFromSceneAsync();&#10;            CacheLevelData(discoveredLevels);&#10;            return discoveredLevels;&#10;        }&#10;&#10;        private void CacheLevelData(List&lt;LevelData&gt; levelData)&#10;        {&#10;            CurrentData.cachedLevelData = new List&lt;LevelData&gt;(levelData.OrderBy(l =&gt; l.levelIndex));&#10;            CurrentData.levelDataCacheValid = true;&#10;&#10;            // Apply default unlock status from level data&#10;            ApplyDefaultUnlockStatus(levelData);&#10;&#10;            SaveData();&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Apply default unlock status from discovered level data&#10;        /// &lt;/summary&gt;&#10;        private void ApplyDefaultUnlockStatus(List&lt;LevelData&gt; levelData)&#10;        {&#10;            foreach (LevelData level in levelData.Where(level =&gt;&#10;                         level.UnlockedByDefault &amp;&amp; !CurrentData.unlockedLevels.Contains(level.levelName)))&#10;            {&#10;                CurrentData.unlockedLevels.Add(level.levelName);&#10;                Debug.Log($&quot;[GameDataService] Auto-unlocked level: {level.levelName} (UnlockedByDefault = true)&quot;);&#10;            }&#10;        }&#10;&#10;        private void NotifyDataChanged()&#10;        {&#10;            OnDataChanged?.Invoke(CurrentData);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Data/IGameDataService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Data/IGameDataService.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;&#10;namespace Core.Data&#10;{&#10;    public interface IGameDataService&#10;    {&#10;        GameData CurrentData { get; }&#10;        void UpdateLives(int lives);&#10;        void UpdateScore(int score);&#10;        void AddFruitCollected();&#10;        void UpdateBestTime(string levelName, float time);&#10;        void UpdateCurrentLevel(string levelName);&#10;        void UnlockLevel(string levelName);&#10;        void ResetAllData();&#10;        void SaveData();&#10;        event Action&lt;GameData&gt; OnDataChanged;&#10;        &#10;        // Level data operations that should go through GameDataService&#10;        void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime);&#10;        Task&lt;List&lt;LevelData&gt;&gt; GetLevelDataAsync(ILevelDiscoveryService discoveryService);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#13;&#10;using System.Collections.Generic;&#13;&#10;using System.Threading.Tasks;&#13;&#10;using LevelSelection;&#13;&#10;using LevelSelection.Services;&#13;&#10;&#13;&#10;namespace Core.Data&#13;&#10;{&#13;&#10;    public interface IGameDataService&#13;&#10;    {&#13;&#10;        GameData CurrentData { get; }&#13;&#10;        void UpdateLives(int lives);&#13;&#10;        void UpdateScore(int score);&#13;&#10;        void AddFruitCollected();&#13;&#10;        void UpdateBestTime(string levelName, float time);&#13;&#10;        void UpdateCurrentLevel(string levelName);&#13;&#10;        void UnlockLevel(string levelName);&#13;&#10;        void ResetAllData();&#13;&#10;        void SaveData();&#13;&#10;        void ResetProgressData(); // New method for selective reset&#13;&#10;        event Action&lt;GameData&gt; OnDataChanged;&#13;&#10;        &#13;&#10;        // Level data operations that should go through GameDataService&#13;&#10;        void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime);&#13;&#10;        Task&lt;List&lt;LevelData&gt;&gt; GetLevelDataAsync(ILevelDiscoveryService discoveryService);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/GameDataCoordinator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/GameDataCoordinator.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameDataCoordinator : MonoBehaviour&#10;    {&#10;        &#10;#if UNITY_EDITOR&#10;        [Header(&quot;Debug&quot;)]&#10;        [SerializeField] private bool resetGameData;&#10;#endif&#10;        &#10;        private IAutoSaveService _autoSaveService;&#10;        private IEventBus _eventBus;&#10;        private IGameDataService _gameDataService;&#10;        private ILevelDiscoveryService _levelDiscoveryService;&#10;        private bool _isInitialized;&#10;&#10;        // Track previous values to detect changes&#10;        private int _previousLives = -1;&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            IGameDataService gameDataService,&#10;            IEventBus eventBus,&#10;            IAutoSaveService autoSaveService,&#10;            ILevelDiscoveryService levelDiscoveryService)&#10;        {&#10;            _gameDataService = gameDataService;&#10;            _eventBus = eventBus;&#10;            _autoSaveService = autoSaveService;&#10;            _levelDiscoveryService = levelDiscoveryService;&#10;            _isInitialized = true;&#10;&#10;            Initialize();&#10;        }&#10;&#10;        private void Initialize()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;            _eventBus?.Subscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged);&#10;            _eventBus?.Subscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;        }&#10;&#10;#if UNITY_EDITOR&#10;        private void OnValidate()&#10;        {&#10;            if (resetGameData)&#10;            {&#10;                if (_gameDataService != null)&#10;                {&#10;                    _gameDataService.ResetAllData();&#10;                    Debug.Log(&quot;Game data has been reset.&quot;);&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning(&quot;GameDataService not available. Cannot reset game data.&quot;);&#10;                }&#10;                resetGameData = false;&#10;            }&#10;        }&#10;#endif&#10;&#10;        private void SaveData()&#10;        {&#10;            _gameDataService?.SaveData();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.Update();&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;            _eventBus?.Unsubscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged);&#10;            _eventBus?.Unsubscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;&#10;            _autoSaveService?.ForceSave();&#10;        }&#10;&#10;        private void OnApplicationPause(bool pauseStatus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationPause(pauseStatus);&#10;        }&#10;&#10;        private void OnApplicationFocus(bool hasFocus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationFocus(hasFocus);&#10;        }&#10;&#10;        private void OnPlayerDied(PlayerDeathEvent deathEvent)&#10;        {&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateBestTime(levelEvent.LevelName, levelEvent.CompletionTime);&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnGameStateChanged(GameStateChangedEvent stateEvent)&#10;        {&#10;            if (stateEvent.NewState is GameState.Victory or GameState.GameOver)&#10;            {&#10;                _autoSaveService?.ForceSave();&#10;            }&#10;        }&#10;&#10;        private void OnLevelStarted(LevelStartedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateCurrentLevel(levelEvent.LevelName);&#10;        }&#10;&#10;        private void OnGameDataChanged(GameData newData)&#10;        {&#10;            // Check if lives changed and publish the appropriate event&#10;            if (_previousLives != newData.lives)&#10;            {&#10;                _eventBus?.Publish(new PlayerLivesChangedEvent&#10;                {&#10;                    PreviousLives = _previousLives,&#10;                    CurrentLives = newData.lives,&#10;                    MaxLives = GameData.MaxLives,&#10;                    Timestamp = Time.time&#10;                });&#10;&#10;                _previousLives = newData.lives;&#10;            }&#10;&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent levelEvent)&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = levelEvent.LevelIndex;&#10;                gameData.currentLevel = levelEvent.LevelName;&#10;            }&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = navigationEvent.NewIndex;&#10;            }&#10;        }&#10;&#10;        // Public API for other systems to request data operations&#10;        public void UpdateLives(int lives)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateLives(lives);&#10;        }&#10;&#10;        public void UpdateCurrentLevel(string levelName)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateCurrentLevel(levelName);&#10;        }&#10;&#10;        public void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateLevelProgress(levelName, isCompleted, completionTime);&#10;        }&#10;&#10;        public void UpdateScore(int score)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateScore(score);&#10;        }&#10;&#10;        public void AddFruitCollected()&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.AddFruitCollected();&#10;        }&#10;&#10;        public async Task&lt;List&lt;LevelData&gt;&gt; DiscoverLevelsAsync()&#10;        {&#10;            if (!_isInitialized || _gameDataService == null || _levelDiscoveryService == null)&#10;                return new List&lt;LevelData&gt;();&#10;            return await _gameDataService.GetLevelDataAsync(_levelDiscoveryService);&#10;        }&#10;&#10;        public GameData GetCurrentData()&#10;        {&#10;            return !_isInitialized ? null : _gameDataService?.CurrentData;&#10;        }&#10;&#10;        public void ResetAllData()&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.ResetAllData();&#10;        }&#10;&#10;        // Wrapper methods for GameData operations &#10;        public bool IsLevelUnlocked(string levelName)&#10;        {&#10;            return GetCurrentData()?.IsLevelUnlocked(levelName) ?? false;&#10;        }&#10;&#10;        public bool IsLevelCompleted(string levelName)&#10;        {&#10;            return GetCurrentData()?.IsLevelCompleted(levelName) ?? false;&#10;        }&#10;&#10;        public float GetLevelBestTime(string levelName)&#10;        {&#10;            return GetCurrentData()?.GetLevelBestTime(levelName) ?? float.MaxValue;&#10;        }&#10;&#10;        public int GetLevelBestScore(string levelName)&#10;        {&#10;            return GetCurrentData()?.GetLevelBestScore(levelName) ?? 0;&#10;        }&#10;&#10;        // Additional wrapper methods to avoid GetCurrentData() calls&#10;        public int GetCurrentLives()&#10;        {&#10;            return GetCurrentData()?.lives ?? GameData.MaxLives;&#10;        }&#10;&#10;        public List&lt;string&gt; GetUnlockedLevels()&#10;        {&#10;            return GetCurrentData()?.unlockedLevels ?? new List&lt;string&gt; { &quot;Level_01&quot; };&#10;        }&#10;&#10;        public List&lt;string&gt; GetCompletedLevels()&#10;        {&#10;            return GetCurrentData()?.completedLevels ?? new List&lt;string&gt;();&#10;        }&#10;&#10;        public int GetSelectedLevelIndex()&#10;        {&#10;            return GetCurrentData()?.selectedLevelIndex ?? 0;&#10;        }&#10;&#10;        public void UnlockLevel(string levelName)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UnlockLevel(levelName);&#10;        }&#10;&#10;        public int GetCurrentScore()&#10;        {&#10;            return GetCurrentData()?.score ?? 0;&#10;        }&#10;&#10;        public int GetFruitCollectedCount()&#10;        {&#10;            return GetCurrentData()?.fruitCollected ?? 0;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameDataCoordinator : MonoBehaviour&#10;    {&#10;        &#10;#if UNITY_EDITOR&#10;        [Header(&quot;Debug&quot;)]&#10;        [SerializeField] private bool resetGameData;&#10;#endif&#10;        &#10;        private IAutoSaveService _autoSaveService;&#10;        private IEventBus _eventBus;&#10;        private IGameDataService _gameDataService;&#10;        private ILevelDiscoveryService _levelDiscoveryService;&#10;        private bool _isInitialized;&#10;&#10;        // Track previous values to detect changes&#10;        private int _previousLives = -1;&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            IGameDataService gameDataService,&#10;            IEventBus eventBus,&#10;            IAutoSaveService autoSaveService,&#10;            ILevelDiscoveryService levelDiscoveryService)&#10;        {&#10;            _gameDataService = gameDataService;&#10;            _eventBus = eventBus;&#10;            _autoSaveService = autoSaveService;&#10;            _levelDiscoveryService = levelDiscoveryService;&#10;            _isInitialized = true;&#10;&#10;            Initialize();&#10;        }&#10;&#10;        private void Initialize()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;            _eventBus?.Subscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged);&#10;            _eventBus?.Subscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;        }&#10;&#10;#if UNITY_EDITOR&#10;        private void OnValidate()&#10;        {&#10;            if (resetGameData)&#10;            {&#10;                if (_gameDataService != null)&#10;                {&#10;                    _gameDataService.ResetAllData();&#10;                    Debug.Log(&quot;Game data has been reset.&quot;);&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning(&quot;GameDataService not available. Cannot reset game data.&quot;);&#10;                }&#10;                resetGameData = false;&#10;            }&#10;        }&#10;#endif&#10;&#10;        private void SaveData()&#10;        {&#10;            _gameDataService?.SaveData();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.Update();&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;LevelStartedEvent&gt;(OnLevelStarted);&#10;            _eventBus?.Unsubscribe&lt;GameStateChangedEvent&gt;(OnGameStateChanged);&#10;            _eventBus?.Unsubscribe&lt;PlayerDeathEvent&gt;(OnPlayerDied);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;&#10;            _autoSaveService?.ForceSave();&#10;        }&#10;&#10;        private void OnApplicationPause(bool pauseStatus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationPause(pauseStatus);&#10;        }&#10;&#10;        private void OnApplicationFocus(bool hasFocus)&#10;        {&#10;            if (!_isInitialized || _autoSaveService == null) return;&#10;&#10;            _autoSaveService.OnApplicationFocus(hasFocus);&#10;        }&#10;&#10;        private void OnPlayerDied(PlayerDeathEvent deathEvent)&#10;        {&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateBestTime(levelEvent.LevelName, levelEvent.CompletionTime);&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnGameStateChanged(GameStateChangedEvent stateEvent)&#10;        {&#10;            if (stateEvent.NewState is GameState.Victory or GameState.GameOver)&#10;            {&#10;                _autoSaveService?.ForceSave();&#10;            }&#10;        }&#10;&#10;        private void OnLevelStarted(LevelStartedEvent levelEvent)&#10;        {&#10;            _gameDataService?.UpdateCurrentLevel(levelEvent.LevelName);&#10;        }&#10;&#10;        private void OnGameDataChanged(GameData newData)&#10;        {&#10;            // Check if lives changed and publish the appropriate event&#10;            if (_previousLives != newData.lives)&#10;            {&#10;                _eventBus?.Publish(new PlayerLivesChangedEvent&#10;                {&#10;                    PreviousLives = _previousLives,&#10;                    CurrentLives = newData.lives,&#10;                    MaxLives = GameData.MaxLives,&#10;                    Timestamp = Time.time&#10;                });&#10;&#10;                _previousLives = newData.lives;&#10;            }&#10;&#10;            _autoSaveService?.RequestSave();&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent levelEvent)&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = levelEvent.LevelIndex;&#10;                gameData.currentLevel = levelEvent.LevelName;&#10;            }&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            GameData gameData = _gameDataService?.CurrentData;&#10;            if (gameData != null)&#10;            {&#10;                gameData.selectedLevelIndex = navigationEvent.NewIndex;&#10;            }&#10;        }&#10;&#10;        // Public API for other systems to request data operations&#10;        public void UpdateLives(int lives)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateLives(lives);&#10;        }&#10;&#10;        public void UpdateCurrentLevel(string levelName)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateCurrentLevel(levelName);&#10;        }&#10;&#10;        public void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateLevelProgress(levelName, isCompleted, completionTime);&#10;        }&#10;&#10;        public void UpdateScore(int score)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UpdateScore(score);&#10;        }&#10;&#10;        public void AddFruitCollected()&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.AddFruitCollected();&#10;        }&#10;&#10;        public async Task&lt;List&lt;LevelData&gt;&gt; DiscoverLevelsAsync()&#10;        {&#10;            if (!_isInitialized || _gameDataService == null || _levelDiscoveryService == null)&#10;                return new List&lt;LevelData&gt;();&#10;            return await _gameDataService.GetLevelDataAsync(_levelDiscoveryService);&#10;        }&#10;&#10;        public GameData GetCurrentData()&#10;        {&#10;            return !_isInitialized ? null : _gameDataService?.CurrentData;&#10;        }&#10;&#10;        public void ResetAllData()&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.ResetAllData();&#10;        }&#10;&#10;        public void ResetProgressData()&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.ResetProgressData();&#10;        }&#10;&#10;        // Wrapper methods for GameData operations &#10;        public bool IsLevelUnlocked(string levelName)&#10;        {&#10;            return GetCurrentData()?.IsLevelUnlocked(levelName) ?? false;&#10;        }&#10;&#10;        public bool IsLevelCompleted(string levelName)&#10;        {&#10;            return GetCurrentData()?.IsLevelCompleted(levelName) ?? false;&#10;        }&#10;&#10;        public float GetLevelBestTime(string levelName)&#10;        {&#10;            return GetCurrentData()?.GetLevelBestTime(levelName) ?? float.MaxValue;&#10;        }&#10;&#10;        public int GetLevelBestScore(string levelName)&#10;        {&#10;            return GetCurrentData()?.GetLevelBestScore(levelName) ?? 0;&#10;        }&#10;&#10;        // Additional wrapper methods to avoid GetCurrentData() calls&#10;        public int GetCurrentLives()&#10;        {&#10;            return GetCurrentData()?.lives ?? GameData.MaxLives;&#10;        }&#10;&#10;        public List&lt;string&gt; GetUnlockedLevels()&#10;        {&#10;            return GetCurrentData()?.unlockedLevels ?? new List&lt;string&gt; { &quot;Level_01&quot; };&#10;        }&#10;&#10;        public List&lt;string&gt; GetCompletedLevels()&#10;        {&#10;            return GetCurrentData()?.completedLevels ?? new List&lt;string&gt;();&#10;        }&#10;&#10;        public int GetSelectedLevelIndex()&#10;        {&#10;            return GetCurrentData()?.selectedLevelIndex ?? 0;&#10;        }&#10;&#10;        public void UnlockLevel(string levelName)&#10;        {&#10;            if (!_isInitialized) return;&#10;            _gameDataService?.UnlockLevel(levelName);&#10;        }&#10;&#10;        public int GetCurrentScore()&#10;        {&#10;            return GetCurrentData()?.score ?? 0;&#10;        }&#10;&#10;        public int GetFruitCollectedCount()&#10;        {&#10;            return GetCurrentData()?.fruitCollected ?? 0;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/GameFlowManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/GameFlowManager.cs" />
              <option name="originalContent" value="using System;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using EasyTransition;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameFlowManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Game Settings&quot;)]&#10;        [SerializeField] private float restartDelay = 2f;&#10;        &#10;        [Header(&quot;Victory Settings&quot;)]&#10;        [SerializeField] private string victorySceneName = &quot;YouWonScene&quot;;&#10;        [SerializeField] private float victoryTransitionDelay = 3f;&#10;        &#10;        private string _currentLevelName = &quot;Unknown&quot;;&#10;        private float _levelStartTime;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private ISceneLoadService _sceneLoadService;&#10;&#10;        private GameState CurrentState { get; set; } = GameState.MainMenu;&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, GameDataCoordinator gameDataCoordinator, ISceneLoadService sceneLoadService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            _sceneLoadService = sceneLoadService;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            _currentLevelName = GetCurrentLevelName();&#10;            &#10;            // Only auto-start gameplay in actual level scenes&#10;            // Other scenes (Level Select, Start Menu, etc.) will manage their own states&#10;            if (ShouldAutoStartGameplay())&#10;            {&#10;                StartGameplay();&#10;            }&#10;        }&#10;&#10;        private static bool ShouldAutoStartGameplay()&#10;        {&#10;            // Only auto-start gameplay in actual level scenes&#10;            string sceneName = SceneManager.GetActiveScene().name;&#10;            return !sceneName.Equals(&quot;Level Select&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; &#10;                   !sceneName.Contains(&quot;Start&quot;) &amp;&amp;&#10;                   !sceneName.Equals(&quot;YouWonScene&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            UnsubscribeFromEvents();&#10;        }&#10;&#10;        private void StartGameplay()&#10;        {&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = _currentLevelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void StartLevel(string levelName)&#10;        {&#10;            _currentLevelName = levelName;&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = levelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void PauseGame()&#10;        {&#10;            if (CurrentState == GameState.Playing)&#10;                ChangeState(GameState.Paused);&#10;        }&#10;&#10;        public void ResumeGame()&#10;        {&#10;            if (CurrentState == GameState.Paused)&#10;                ChangeState(GameState.Playing);&#10;        }&#10;&#10;        public void RestartLevel()&#10;        {&#10;            string currentSceneName = SceneManager.GetActiveScene().name;&#10;            _sceneLoadService?.LoadLevel(currentSceneName);&#10;        }&#10;&#10;        public void HandlePlayerDeath(Vector3 deathPosition)&#10;        {&#10;            _eventBus?.Publish(new PlayerDeathEvent&#10;            {&#10;                DeathPosition = deathPosition,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void CompleteLevel(string currentLevelName)&#10;        {&#10;            float completionTime = Time.time - _levelStartTime;&#10;            &#10;            _eventBus?.Publish(new LevelCompletedEvent&#10;            {&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void RequestLevelLoad(string levelName, string sceneName)&#10;        {&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                SceneName = sceneName&#10;            });&#10;        }&#10;&#10;        public void SelectLevel(string levelName, int levelIndex)&#10;        {&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                LevelIndex = levelIndex&#10;            });&#10;        }&#10;&#10;        public void NavigateLevel(int previousIndex, int newIndex, Vector2 direction)&#10;        {&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = newIndex,&#10;                Direction = direction&#10;            });&#10;        }&#10;&#10;        public void NavigateToLevelSelection()&#10;        {&#10;            try&#10;            {&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to navigate to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void OnGameOver(GameOverEvent gameOverEvent)&#10;        {&#10;            ChangeState(GameState.GameOver);&#10;            RestartLevelAfterDelayAsync(restartDelay);&#10;        }&#10;&#10;        private async void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            ChangeState(GameState.Victory);&#10;&#10;            // First, check if the level was already completed&#10;            bool wasAlreadyCompleted = _gameDataCoordinator.IsLevelCompleted(levelEvent.LevelName);&#10;&#10;            // Now, update the progress (marks as complete, updates best time, etc.)&#10;            _gameDataCoordinator.UpdateLevelProgress(levelEvent.LevelName, true, levelEvent.CompletionTime);&#10;&#10;            // If it's the first time completing this level, unlock the next one&#10;            if (!wasAlreadyCompleted)&#10;            {&#10;                await UnlockNextLevelByIndex(levelEvent.LevelName);&#10;            }&#10;&#10;            if (await IsGameCompletedAsync())&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] All levels completed! Transitioning to YouWonScene...&quot;);&#10;                TransitionToVictorySceneAsync();&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] Level {levelEvent.LevelName} completed. Returning to level selection...&quot;);&#10;                ReturnToLevelSelectionAsync();&#10;            }&#10;        }&#10;&#10;        private async Task UnlockNextLevelByIndex(string completedLevelName)&#10;        {&#10;            Debug.Log($&quot;[GameFlowManager] UnlockNextLevelByIndex called for: {completedLevelName}&quot;);&#10;            &#10;            var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            if (allLevels == null || allLevels.Count == 0) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] No levels discovered for unlocking next level&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Found {allLevels.Count} levels total&quot;);&#10;            &#10;            var completedLevel = allLevels.FirstOrDefault(l =&gt; l.levelName == completedLevelName);&#10;            if (completedLevel == null) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] Could not find completed level: {completedLevelName}&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Completed level index: {completedLevel.levelIndex}&quot;);&#10;            int nextLevelIndex = completedLevel.levelIndex + 1;&#10;&#10;            if (nextLevelIndex &lt; allLevels.Count)&#10;            {&#10;                var nextLevel = allLevels.FirstOrDefault(l =&gt; l.levelIndex == nextLevelIndex);&#10;                if (nextLevel != null)&#10;                {&#10;                    bool isAlreadyUnlocked = _gameDataCoordinator.IsLevelUnlocked(nextLevel.levelName);&#10;                    Debug.Log($&quot;[GameFlowManager] Next level '{nextLevel.levelName}' (index {nextLevelIndex}) - Already unlocked: {isAlreadyUnlocked}&quot;);&#10;                    &#10;                    if (!isAlreadyUnlocked)&#10;                    {&#10;                        _gameDataCoordinator.UnlockLevel(nextLevel.levelName);&#10;                        Debug.Log($&quot;[GameFlowManager] Unlocked next level: {nextLevel.levelName}&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        Debug.Log($&quot;[GameFlowManager] Next level {nextLevel.levelName} was already unlocked&quot;);&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;[GameFlowManager] Could not find level with index {nextLevelIndex}&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] No more levels to unlock (completed level was the last one)&quot;);&#10;            }&#10;        }&#10;&#10;        private async Task&lt;bool&gt; IsGameCompletedAsync()&#10;        {&#10;            try&#10;            {&#10;                // Get all available levels through GameDataCoordinator&#10;                var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;                &#10;                if (allLevels == null || allLevels.Count == 0)&#10;                {&#10;                    Debug.LogWarning(&quot;[GameFlowManager] No levels found in discovery service&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Get completed levels using wrapper method&#10;                var completedLevels = _gameDataCoordinator?.GetCompletedLevels();&#10;                if (completedLevels == null) return false;&#10;&#10;                // Check if all levels are in the completed list&#10;                var completedCount = 0;&#10;                foreach (var level in allLevels)&#10;                {&#10;                    if (completedLevels.Contains(level.levelName))&#10;                    {&#10;                        completedCount++;&#10;                    }&#10;                }&#10;                &#10;                Debug.Log($&quot;[GameFlowManager] Game completion check: {completedCount}/{allLevels.Count} levels completed&quot;);&#10;                &#10;                if (completedCount &gt;= allLevels.Count)&#10;                {&#10;                    Debug.Log(&quot;[GameFlowManager] All levels completed!&quot;);&#10;                    return true;&#10;                }&#10;&#10;                var remainingLevels = allLevels.Where(l =&gt; !completedLevels.Contains(l.levelName)).Select(l =&gt; l.levelName);&#10;                Debug.Log($&quot;[GameFlowManager] Remaining levels: {string.Join(&quot;, &quot;, remainingLevels)}&quot;);&#10;                return false;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Error checking game completion: {e}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private async void TransitionToVictorySceneAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(victoryTransitionDelay * 1000));&#10;                &#10;                _eventBus?.Publish(new GameCompletedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    FinalLevelName = _currentLevelName&#10;                });&#10;                &#10;                _sceneLoadService?.LoadLevel(victorySceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to transition to victory scene: {e}&quot;);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;        }&#10;&#10;        private async void ReturnToLevelSelectionAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(2f * 1000));&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to return to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnPlayerLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            bool lostLife = livesEvent.PreviousLives &gt; livesEvent.CurrentLives;&#10;            bool isGameOver = livesEvent.CurrentLives == 0;&#10;&#10;            if (isGameOver)&#10;            {&#10;                ChangeState(GameState.GameOver);&#10;                _gameDataCoordinator?.ResetAllData();&#10;                _eventBus?.Publish(new GameOverEvent { Timestamp = Time.time });&#10;            }&#10;&#10;            if (lostLife)&#10;            {&#10;                _eventBus?.Publish(new PlayerDeathEvent&#10;                {&#10;                    DeathPosition = PlayerLocator.PlayerTransform.position,&#10;                    Timestamp = Time.time&#10;                });&#10;            }&#10;&#10;            if (isGameOver || lostLife)&#10;            {&#10;                Time.timeScale = 0.01f;&#10;                RestartLevelAfterDelayAsync(restartDelay);&#10;            }&#10;        }&#10;&#10;        private async void RestartLevelAfterDelayAsync(float delay)&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(delay * 1000));&#10;                string currentSceneName = SceneManager.GetActiveScene().name;&#10;                _sceneLoadService?.LoadLevel(currentSceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to restart level after delay: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ChangeState(GameState newState)&#10;        {&#10;            if (CurrentState == newState) return;&#10;&#10;            GameState oldState = CurrentState;&#10;            CurrentState = newState;&#10;&#10;            _eventBus?.Publish(new GameStateChangedEvent&#10;            {&#10;                PreviousState = oldState,&#10;                NewState = newState,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private string GetCurrentLevelName() =&gt; SceneManager.GetActiveScene().name;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Core.Data;&#10;using Core.Events;&#10;using EasyTransition;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameFlowManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Game Settings&quot;)]&#10;        [SerializeField] private float restartDelay = 2f;&#10;        &#10;        [Header(&quot;Victory Settings&quot;)]&#10;        [SerializeField] private string victorySceneName = &quot;YouWonScene&quot;;&#10;        [SerializeField] private float victoryTransitionDelay = 3f;&#10;        &#10;        private string _currentLevelName = &quot;Unknown&quot;;&#10;        private float _levelStartTime;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private ISceneLoadService _sceneLoadService;&#10;&#10;        private GameState CurrentState { get; set; } = GameState.MainMenu;&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, GameDataCoordinator gameDataCoordinator, ISceneLoadService sceneLoadService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            _sceneLoadService = sceneLoadService;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            _currentLevelName = GetCurrentLevelName();&#10;            &#10;            // Only auto-start gameplay in actual level scenes&#10;            // Other scenes (Level Select, Start Menu, etc.) will manage their own states&#10;            if (ShouldAutoStartGameplay())&#10;            {&#10;                StartGameplay();&#10;            }&#10;        }&#10;&#10;        private static bool ShouldAutoStartGameplay()&#10;        {&#10;            // Only auto-start gameplay in actual level scenes&#10;            string sceneName = SceneManager.GetActiveScene().name;&#10;            return !sceneName.Equals(&quot;Level Select&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp; &#10;                   !sceneName.Contains(&quot;Start&quot;) &amp;&amp;&#10;                   !sceneName.Equals(&quot;YouWonScene&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            UnsubscribeFromEvents();&#10;        }&#10;&#10;        private void StartGameplay()&#10;        {&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = _currentLevelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void StartLevel(string levelName)&#10;        {&#10;            _currentLevelName = levelName;&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = levelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void PauseGame()&#10;        {&#10;            if (CurrentState == GameState.Playing)&#10;                ChangeState(GameState.Paused);&#10;        }&#10;&#10;        public void ResumeGame()&#10;        {&#10;            if (CurrentState == GameState.Paused)&#10;                ChangeState(GameState.Playing);&#10;        }&#10;&#10;        public void RestartLevel()&#10;        {&#10;            string currentSceneName = SceneManager.GetActiveScene().name;&#10;            _sceneLoadService?.LoadLevel(currentSceneName);&#10;        }&#10;&#10;        public void HandlePlayerDeath(Vector3 deathPosition)&#10;        {&#10;            _eventBus?.Publish(new PlayerDeathEvent&#10;            {&#10;                DeathPosition = deathPosition,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void CompleteLevel(string currentLevelName)&#10;        {&#10;            float completionTime = Time.time - _levelStartTime;&#10;            &#10;            _eventBus?.Publish(new LevelCompletedEvent&#10;            {&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void RequestLevelLoad(string levelName, string sceneName)&#10;        {&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                SceneName = sceneName&#10;            });&#10;        }&#10;&#10;        public void SelectLevel(string levelName, int levelIndex)&#10;        {&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                LevelIndex = levelIndex&#10;            });&#10;        }&#10;&#10;        public void NavigateLevel(int previousIndex, int newIndex, Vector2 direction)&#10;        {&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = newIndex,&#10;                Direction = direction&#10;            });&#10;        }&#10;&#10;        public void NavigateToLevelSelection()&#10;        {&#10;            try&#10;            {&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to navigate to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void OnGameOver(GameOverEvent gameOverEvent)&#10;        {&#10;            ChangeState(GameState.GameOver);&#10;            RestartLevelAfterDelayAsync(restartDelay);&#10;        }&#10;&#10;        private async void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            ChangeState(GameState.Victory);&#10;&#10;            // First, check if the level was already completed&#10;            bool wasAlreadyCompleted = _gameDataCoordinator.IsLevelCompleted(levelEvent.LevelName);&#10;&#10;            // Now, update the progress (marks as complete, updates best time, etc.)&#10;            _gameDataCoordinator.UpdateLevelProgress(levelEvent.LevelName, true, levelEvent.CompletionTime);&#10;&#10;            // If it's the first time completing this level, unlock the next one&#10;            if (!wasAlreadyCompleted)&#10;            {&#10;                await UnlockNextLevelByIndex(levelEvent.LevelName);&#10;            }&#10;&#10;            if (await IsGameCompletedAsync())&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] All levels completed! Transitioning to YouWonScene...&quot;);&#10;                TransitionToVictorySceneAsync();&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] Level {levelEvent.LevelName} completed. Returning to level selection...&quot;);&#10;                ReturnToLevelSelectionAsync();&#10;            }&#10;        }&#10;&#10;        private async Task UnlockNextLevelByIndex(string completedLevelName)&#10;        {&#10;            Debug.Log($&quot;[GameFlowManager] UnlockNextLevelByIndex called for: {completedLevelName}&quot;);&#10;            &#10;            var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            if (allLevels == null || allLevels.Count == 0) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] No levels discovered for unlocking next level&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Found {allLevels.Count} levels total&quot;);&#10;            &#10;            var completedLevel = allLevels.FirstOrDefault(l =&gt; l.levelName == completedLevelName);&#10;            if (completedLevel == null) &#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] Could not find completed level: {completedLevelName}&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Completed level index: {completedLevel.levelIndex}&quot;);&#10;            int nextLevelIndex = completedLevel.levelIndex + 1;&#10;&#10;            if (nextLevelIndex &lt; allLevels.Count)&#10;            {&#10;                var nextLevel = allLevels.FirstOrDefault(l =&gt; l.levelIndex == nextLevelIndex);&#10;                if (nextLevel != null)&#10;                {&#10;                    bool isAlreadyUnlocked = _gameDataCoordinator.IsLevelUnlocked(nextLevel.levelName);&#10;                    Debug.Log($&quot;[GameFlowManager] Next level '{nextLevel.levelName}' (index {nextLevelIndex}) - Already unlocked: {isAlreadyUnlocked}&quot;);&#10;                    &#10;                    if (!isAlreadyUnlocked)&#10;                    {&#10;                        _gameDataCoordinator.UnlockLevel(nextLevel.levelName);&#10;                        Debug.Log($&quot;[GameFlowManager] Unlocked next level: {nextLevel.levelName}&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        Debug.Log($&quot;[GameFlowManager] Next level {nextLevel.levelName} was already unlocked&quot;);&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;[GameFlowManager] Could not find level with index {nextLevelIndex}&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] No more levels to unlock (completed level was the last one)&quot;);&#10;            }&#10;        }&#10;&#10;        private async Task&lt;bool&gt; IsGameCompletedAsync()&#10;        {&#10;            try&#10;            {&#10;                // Get all available levels through GameDataCoordinator&#10;                var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;                &#10;                if (allLevels == null || allLevels.Count == 0)&#10;                {&#10;                    Debug.LogWarning(&quot;[GameFlowManager] No levels found in discovery service&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Get completed levels using wrapper method&#10;                var completedLevels = _gameDataCoordinator?.GetCompletedLevels();&#10;                if (completedLevels == null) return false;&#10;&#10;                // Check if all levels are in the completed list&#10;                var completedCount = 0;&#10;                foreach (var level in allLevels)&#10;                {&#10;                    if (completedLevels.Contains(level.levelName))&#10;                    {&#10;                        completedCount++;&#10;                    }&#10;                }&#10;                &#10;                Debug.Log($&quot;[GameFlowManager] Game completion check: {completedCount}/{allLevels.Count} levels completed&quot;);&#10;                &#10;                if (completedCount &gt;= allLevels.Count)&#10;                {&#10;                    Debug.Log(&quot;[GameFlowManager] All levels completed!&quot;);&#10;                    return true;&#10;                }&#10;&#10;                var remainingLevels = allLevels.Where(l =&gt; !completedLevels.Contains(l.levelName)).Select(l =&gt; l.levelName);&#10;                Debug.Log($&quot;[GameFlowManager] Remaining levels: {string.Join(&quot;, &quot;, remainingLevels)}&quot;);&#10;                return false;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Error checking game completion: {e}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private async void TransitionToVictorySceneAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(victoryTransitionDelay * 1000));&#10;                &#10;                _eventBus?.Publish(new GameCompletedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    FinalLevelName = _currentLevelName&#10;                });&#10;                &#10;                _sceneLoadService?.LoadLevel(victorySceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to transition to victory scene: {e}&quot;);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;        }&#10;&#10;        private async void ReturnToLevelSelectionAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(2f * 1000));&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to return to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnPlayerLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            bool lostLife = livesEvent.PreviousLives &gt; livesEvent.CurrentLives;&#10;            bool isGameOver = livesEvent.CurrentLives == 0;&#10;&#10;            if (isGameOver)&#10;            {&#10;                ChangeState(GameState.GameOver);&#10;                // Use selective reset to preserve score and level progress&#10;                _gameDataCoordinator?.ResetProgressData();&#10;                _eventBus?.Publish(new GameOverEvent { Timestamp = Time.time });&#10;            }&#10;&#10;            if (lostLife)&#10;            {&#10;                _eventBus?.Publish(new PlayerDeathEvent&#10;                {&#10;                    DeathPosition = PlayerLocator.PlayerTransform.position,&#10;                    Timestamp = Time.time&#10;                });&#10;            }&#10;&#10;            if (isGameOver || lostLife)&#10;            {&#10;                Time.timeScale = 0.01f;&#10;                RestartLevelAfterDelayAsync(restartDelay);&#10;            }&#10;        }&#10;&#10;        private async void RestartLevelAfterDelayAsync(float delay)&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(delay * 1000));&#10;                string currentSceneName = SceneManager.GetActiveScene().name;&#10;                _sceneLoadService?.LoadLevel(currentSceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to restart level after delay: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ChangeState(GameState newState)&#10;        {&#10;            if (CurrentState == newState) return;&#10;&#10;            GameState oldState = CurrentState;&#10;            CurrentState = newState;&#10;&#10;            _eventBus?.Publish(new GameStateChangedEvent&#10;            {&#10;                PreviousState = oldState,&#10;                NewState = newState,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private string GetCurrentLevelName() =&gt; SceneManager.GetActiveScene().name;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/PeriodicBypassDamageDealer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/PeriodicBypassDamageDealer.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using Core.Events;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Health.Damage&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Applies damage every interval seconds to the attached GameObject, bypassing shield logic.&#10;    /// &lt;/summary&gt;&#10;    [DisallowMultipleComponent]&#10;    public class PeriodicBypassDamageDealer : MonoBehaviour&#10;    {&#10;        [SerializeField] private int damageAmount = 1;&#10;        [SerializeField] private float interval = 3f;&#10;        private IBypassableDamageable _bypassable;&#10;        private Coroutine _damageRoutine;&#10;        private IEventBus _eventBus;&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus)&#10;        {&#10;            _eventBus = eventBus;&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            _bypassable = GetComponent&lt;IBypassableDamageable&gt;();&#10;        }&#10;        private void OnEnable()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            &#10;            if (_bypassable != null)&#10;                _damageRoutine = StartCoroutine(DamageLoop());&#10;        }&#10;        private void OnLevelCompleted(LevelCompletedEvent obj)&#10;        {&#10;            if (_damageRoutine != null)&#10;            {&#10;                StopCoroutine(_damageRoutine);&#10;                _damageRoutine = null;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (_damageRoutine != null)&#10;                StopCoroutine(_damageRoutine);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;        }&#10;&#10;        private IEnumerator DamageLoop()&#10;        {&#10;            while (true)&#10;            {&#10;                _bypassable.DamageBypass(damageAmount);&#10;                yield return new WaitForSeconds(interval);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using Core.Events;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Health.Damage&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Applies damage every interval seconds to the attached GameObject, bypassing shield logic.&#10;    /// &lt;/summary&gt;&#10;    [DisallowMultipleComponent]&#10;    public class PeriodicBypassDamageDealer : MonoBehaviour&#10;    {&#10;        [Header(&quot;Damage Settings&quot;)]&#10;        [SerializeField] private int damageAmount = 1;&#10;        [SerializeField] private float interval = 3f;&#10;        private IBypassableDamageable _bypassable;&#10;        private Coroutine _damageRoutine;&#10;        private IEventBus _eventBus;&#10;        private bool _isLevelCompleted;&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus)&#10;        {&#10;            _eventBus = eventBus;&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            _bypassable = GetComponent&lt;IBypassableDamageable&gt;();&#10;        }&#10;        &#10;        private void OnEnable()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _isLevelCompleted = false;&#10;            &#10;            if (_bypassable != null)&#10;                _damageRoutine = StartCoroutine(DamageLoop());&#10;        }&#10;        &#10;        private void OnLevelCompleted(LevelCompletedEvent obj)&#10;        {&#10;            Debug.Log(&quot;[PeriodicBypassDamageDealer] Level completed, stopping damage.&quot;);&#10;            _isLevelCompleted = true;&#10;            StopDamageRoutine();&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            _isLevelCompleted = true;&#10;            StopDamageRoutine();&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;        }&#10;&#10;        private void StopDamageRoutine()&#10;        {&#10;            if (_damageRoutine != null)&#10;            {&#10;                StopCoroutine(_damageRoutine);&#10;                _damageRoutine = null;&#10;            }&#10;        }&#10;&#10;        private IEnumerator DamageLoop()&#10;        {&#10;            while (_bypassable != null &amp;&amp; !_isLevelCompleted)&#10;            {&#10;                _bypassable.DamageBypass(damageAmount);&#10;                yield return new WaitForSeconds(interval);&#10;            }&#10;            &#10;            // Clear the routine reference when it exits naturally&#10;            _damageRoutine = null;&#10;            Debug.Log(&quot;[PeriodicBypassDamageDealer] Damage loop ended.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/DI/LevelSelectionLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/DI/LevelSelectionLifetimeScope.cs" />
              <option name="originalContent" value="using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace LevelSelection.DI&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     VContainer lifetime scope for Level Selection services&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Configuring level selection DI container...&quot;);&#10;&#10;            // Register core services that level selection depends on&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;&#10;            // Register core game management components&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;&#10;            // Register the new service-based architecture&#10;            builder.Register&lt;ILevelDiscoveryService, LevelDiscoveryService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;ILevelNavigationService, LevelNavigationService&gt;(Lifetime.Scoped);&#10;&#10;            // Register NEW focused services following SOLID principles&#10;            builder.Register&lt;ISelectorService, SelectorService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IInputFilterService, InputFilterService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IAudioFeedbackService, AudioFeedbackService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IItemSelectService, ItemSelectService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;ISceneLoadService, SceneLoadService&gt;(Lifetime.Scoped);&#10;&#10;            // Register the main controller&#10;            builder.RegisterComponentInHierarchy&lt;LevelSelectionController&gt;();&#10;&#10;            // Register supporting components that are still used&#10;            builder.RegisterComponentInHierarchy&lt;ItemSelectScreen&gt;();&#10;&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Level selection DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace LevelSelection.DI&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     VContainer lifetime scope for Level Selection services&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Configuring level selection DI container...&quot;);&#10;&#10;            // Register core services that level selection depends on&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;&#10;            // Register core game management components&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;&#10;            // Register the new service-based architecture&#10;            builder.Register&lt;ILevelDiscoveryService, LevelDiscoveryService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;ILevelNavigationService, LevelNavigationService&gt;(Lifetime.Scoped);&#10;&#10;            // Register NEW focused services following SOLID principles&#10;            builder.Register&lt;ISelectorService, SelectorService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IInputFilterService, InputFilterService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IAudioFeedbackService, AudioFeedbackService&gt;(Lifetime.Scoped);&#10;            builder.Register&lt;IItemSelectService, ItemSelectService&gt;(Lifetime.Scoped);&#10;            builder.RegisterComponentInHierarchy&lt;SceneLoadService&gt;().As&lt;ISceneLoadService&gt;();&#10;&#10;            // Register the main controller&#10;            builder.RegisterComponentInHierarchy&lt;LevelSelectionController&gt;();&#10;&#10;            // Register supporting components that are still used&#10;            builder.RegisterComponentInHierarchy&lt;ItemSelectScreen&gt;();&#10;&#10;            Debug.Log(&quot;[LevelSelectionLifetimeScope] Level selection DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/EndLevelZone.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/EndLevelZone.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using Core;&#10;using ModularCharacterController.Core;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Trigger zone that detects when the player completes a level.&#10;    ///     Its only responsibility is to notify the GameFlowManager.&#10;    /// &lt;/summary&gt;&#10;    [RequireComponent(typeof(Collider2D))]&#10;    public class EndLevelZone : MonoBehaviour&#10;    {&#10;        [Header(&quot;Level Completion Settings&quot;)] [SerializeField]&#10;        private string currentLevelName;&#10;&#10;        [SerializeField] private string nextLevelName;&#10;        [SerializeField] private float completionDelay = 2f;&#10;&#10;        [Header(&quot;Audio Feedback&quot;)] [SerializeField]&#10;        private AudioClip completionSound;&#10;&#10;        [Header(&quot;UI Feedback&quot;)] [SerializeField]&#10;        private GameObject completionUI;&#10;&#10;        [SerializeField] private float uiDisplayDuration = 3f;&#10;&#10;        private AudioSource _audioSource;&#10;        private GameFlowManager _gameFlowManager;&#10;        private bool _hasTriggered;&#10;&#10;        private void Awake()&#10;        {&#10;            // Setup audio component&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (_audioSource == null)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;&#10;            // Ensure trigger is set up correctly&#10;            Collider2D col = GetComponent&lt;Collider2D&gt;();&#10;            col.isTrigger = true;&#10;&#10;            // Hide completion UI initially&#10;            if (completionUI != null)&#10;            {&#10;                completionUI.SetActive(false);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter2D(Collider2D other)&#10;        {&#10;            // Check if player entered&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !_hasTriggered)&#10;            {&#10;                Rigidbody2D rb = other.GetComponent&lt;Rigidbody2D&gt;();&#10;                InputHandler input = other.GetComponent&lt;InputHandler&gt;();&#10;                StartCoroutine(CompleteLevel(rb, input));&#10;            }&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(GameFlowManager gameFlowManager)&#10;        {&#10;            _gameFlowManager = gameFlowManager;&#10;        }&#10;&#10;        private IEnumerator CompleteLevel(Rigidbody2D rb, InputHandler input)&#10;        {&#10;            _hasTriggered = true;&#10;&#10;            // Take control from the player&#10;            if (input)&#10;            {&#10;                input.enabled = false; // Disable player input&#10;            }&#10;            &#10;            if (rb)&#10;            {&#10;                rb.linearVelocity = Vector2.zero; // Reset velocity&#10;            }&#10;&#10;            // Make the player walk right&#10;            const float walkDuration = 1.3f;&#10;            float timer = 0f;&#10;            while (timer &lt; walkDuration)&#10;            {&#10;                if (rb)&#10;                {&#10;                    rb.linearVelocityX = 2f;&#10;                }&#10;&#10;                timer += Time.fixedDeltaTime;&#10;                yield return new WaitForFixedUpdate();&#10;            }&#10;&#10;            Debug.Log($&quot;[EndLevelZone] Player completed level: {currentLevelName}&quot;);&#10;&#10;            // Play completion sound&#10;            if (completionSound &amp;&amp; _audioSource)&#10;            {&#10;                _audioSource.PlayOneShot(completionSound);&#10;            }&#10;&#10;            // Show completion UI&#10;            if (completionUI != null)&#10;            {&#10;                completionUI.SetActive(true);&#10;                yield return new WaitForSeconds(uiDisplayDuration);&#10;                completionUI.SetActive(false);&#10;            }&#10;&#10;            // Wait for completion delay&#10;            yield return new WaitForSeconds(completionDelay);&#10;&#10;            // Notify GameFlowManager, which will handle all subsequent logic.&#10;            _gameFlowManager?.CompleteLevel(currentLevelName);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using Core;&#10;using ModularCharacterController.Core;&#10;using Player.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Trigger zone that detects when the player completes a level.&#10;    ///     Its only responsibility is to notify the GameFlowManager.&#10;    /// &lt;/summary&gt;&#10;    [RequireComponent(typeof(Collider2D))]&#10;    public class EndLevelZone : MonoBehaviour&#10;    {&#10;        [Header(&quot;Level Completion Settings&quot;)] [SerializeField]&#10;        private string currentLevelName;&#10;&#10;        [SerializeField] private string nextLevelName;&#10;        [SerializeField] private float completionDelay = 2f;&#10;&#10;        [Header(&quot;Audio Feedback&quot;)] [SerializeField]&#10;        private AudioClip completionSound;&#10;&#10;        [Header(&quot;UI Feedback&quot;)] [SerializeField]&#10;        private GameObject completionUI;&#10;&#10;        [SerializeField] private float uiDisplayDuration = 3f;&#10;&#10;        private AudioSource _audioSource;&#10;        private GameFlowManager _gameFlowManager;&#10;        private HealthBonusService _healthBonusService;&#10;        private bool _hasTriggered;&#10;&#10;        private void Awake()&#10;        {&#10;            // Setup audio component&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (_audioSource == null)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;&#10;            // Ensure trigger is set up correctly&#10;            Collider2D col = GetComponent&lt;Collider2D&gt;();&#10;            col.isTrigger = true;&#10;&#10;            // Hide completion UI initially&#10;            if (completionUI != null)&#10;            {&#10;                completionUI.SetActive(false);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter2D(Collider2D other)&#10;        {&#10;            // Check if player entered&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !_hasTriggered)&#10;            {&#10;                Rigidbody2D rb = other.GetComponent&lt;Rigidbody2D&gt;();&#10;                InputHandler input = other.GetComponent&lt;InputHandler&gt;();&#10;                StartCoroutine(CompleteLevel(rb, input));&#10;            }&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(GameFlowManager gameFlowManager, HealthBonusService healthBonusService)&#10;        {&#10;            _gameFlowManager = gameFlowManager;&#10;            _healthBonusService = healthBonusService;&#10;        }&#10;&#10;        private IEnumerator CompleteLevel(Rigidbody2D rb, InputHandler input)&#10;        {&#10;            _hasTriggered = true;&#10;&#10;            // Take control from the player&#10;            if (input)&#10;            {&#10;                input.enabled = false; // Disable player input&#10;            }&#10;            &#10;            if (rb)&#10;            {&#10;                rb.linearVelocity = Vector2.zero; // Reset velocity&#10;            }&#10;&#10;            // Make the player walk right&#10;            const float walkDuration = 1.3f;&#10;            float timer = 0f;&#10;            while (timer &lt; walkDuration)&#10;            {&#10;                if (rb)&#10;                {&#10;                    rb.linearVelocityX = 2f;&#10;                }&#10;&#10;                timer += Time.fixedDeltaTime;&#10;                yield return new WaitForFixedUpdate();&#10;            }&#10;&#10;            Debug.Log($&quot;[EndLevelZone] Player completed level: {currentLevelName}&quot;);&#10;&#10;            // Play completion sound&#10;            if (completionSound &amp;&amp; _audioSource)&#10;            {&#10;                _audioSource.PlayOneShot(completionSound);&#10;            }&#10;&#10;            // Show completion UI&#10;            if (completionUI != null)&#10;            {&#10;                completionUI.SetActive(true);&#10;                yield return new WaitForSeconds(uiDisplayDuration);&#10;                completionUI.SetActive(false);&#10;            }&#10;&#10;            // Calculate health bonus before completing the level&#10;            bool bonusComplete = false;&#10;            if (_healthBonusService != null)&#10;            {&#10;                Debug.Log(&quot;[EndLevelZone] Starting health bonus calculation...&quot;);&#10;                _healthBonusService.CalculateHealthBonus(() =&gt; bonusComplete = true);&#10;                &#10;                // Wait for bonus calculation to complete&#10;                yield return new WaitUntil(() =&gt; bonusComplete);&#10;                Debug.Log(&quot;[EndLevelZone] Health bonus calculation finished&quot;);&#10;            }&#10;&#10;            // Wait for completion delay&#10;            yield return new WaitForSeconds(completionDelay);&#10;&#10;            // Notify GameFlowManager, which will handle all subsequent logic.&#10;            _gameFlowManager?.CompleteLevel(currentLevelName);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Services/HealthBonusService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Services/HealthBonusService.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections;&#10;using Collectables.Score;&#10;using Health.Interfaces;&#10;using Player.Components;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Service responsible for calculating and awarding bonus points based on remaining health&#10;    /// &lt;/summary&gt;&#10;    public class HealthBonusService : MonoBehaviour&#10;    {&#10;        [Header(&quot;Bonus Settings&quot;)]&#10;        [SerializeField] private int pointsPerHp = 100;&#10;        [SerializeField] private float drainDelay = 0.2f;&#10;        [SerializeField] private float drainInterval = 0.1f;&#10;        &#10;        [Header(&quot;Audio&quot;)]&#10;        [SerializeField] private AudioClip bonusDrainSfx;&#10;        &#10;        private IScoreService _scoreService;&#10;        private PlayerHealthController _healthController;&#10;        private IHealthView _healthView;&#10;        private AudioSource _audioSource;&#10;        &#10;        [Inject]&#10;        public void Construct(IScoreService scoreService)&#10;        {&#10;            _scoreService = scoreService;&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (!_audioSource)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;            &#10;            _healthController = GetComponent&lt;PlayerHealthController&gt;();&#10;        }&#10;        private void Start()&#10;        {&#10;            _healthView = _healthController?.HealthView;&#10;            &#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Calculate and award bonus points for remaining health&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;onComplete&quot;&gt;Callback when bonus calculation is complete&lt;/param&gt;&#10;        public void CalculateHealthBonus(System.Action onComplete = null)&#10;        {&#10;            if (_healthController == null)&#10;            {&#10;                Debug.LogWarning(&quot;[HealthBonusService] No PlayerHealthController found&quot;);&#10;                onComplete?.Invoke();&#10;                return;&#10;            }&#10;            &#10;            int remainingHp = _healthController.CurrentHp;&#10;            &#10;            if (remainingHp &lt;= 0)&#10;            {&#10;                Debug.Log(&quot;[HealthBonusService] No remaining HP for bonus&quot;);&#10;                onComplete?.Invoke();&#10;                return;&#10;            }&#10;            &#10;            Debug.Log($&quot;[HealthBonusService] Starting health bonus calculation: {remainingHp} HP remaining&quot;);&#10;            StartCoroutine(DrainHealthForBonus(remainingHp, onComplete));&#10;        }&#10;        &#10;        private IEnumerator DrainHealthForBonus(int remainingHp, System.Action onComplete)&#10;        {&#10;            // Wait before starting the drain&#10;            yield return new WaitForSeconds(drainDelay);&#10;            &#10;            int totalBonus = remainingHp * pointsPerHp;&#10;            Debug.Log($&quot;[HealthBonusService] Total bonus to award: {totalBonus} points&quot;);&#10;            &#10;            // Drain each HP point individually&#10;            for (int i = 0; i &lt; remainingHp; i++)&#10;            {&#10;                // Award points for this HP&#10;                _scoreService?.AddScore(pointsPerHp);&#10;                &#10;                // Reduce health by 1 (visual only)&#10;                _healthView?.UpdateDisplay(&#10;                    Mathf.Max(_healthController.CurrentHp - i, 0), &#10;                    _healthController.MaxHp);&#10;&#10;                // Play drain sound effect&#10;                if (bonusDrainSfx &amp;&amp; _audioSource)&#10;                {&#10;                    _audioSource.PlayOneShot(bonusDrainSfx);&#10;                }&#10;                &#10;                &#10;                // Wait before next drain&#10;                yield return new WaitForSeconds(drainInterval);&#10;            }&#10;&#10;            onComplete?.Invoke();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections;&#10;using Collectables.Score;&#10;using Health.Interfaces;&#10;using Player.Components;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Service responsible for calculating and awarding bonus points based on remaining health&#10;    /// &lt;/summary&gt;&#10;    public class HealthBonusService : MonoBehaviour&#10;    {&#10;        [Header(&quot;Bonus Settings&quot;)]&#10;        [SerializeField] private int pointsPerHp = 100;&#10;        [SerializeField] private float drainDelay = 0.2f;&#10;        [SerializeField] private float drainInterval = 0.1f;&#10;        &#10;        [Header(&quot;Audio&quot;)]&#10;        [SerializeField] private AudioClip bonusDrainSfx;&#10;        &#10;        private IScoreService _scoreService;&#10;        private PlayerHealthController _healthController;&#10;        private IHealthView _healthView;&#10;        private AudioSource _audioSource;&#10;        &#10;        [Inject]&#10;        public void Construct(IScoreService scoreService)&#10;        {&#10;            _scoreService = scoreService;&#10;        }&#10;        &#10;        private void Awake()&#10;        {&#10;            _audioSource = GetComponent&lt;AudioSource&gt;();&#10;            if (!_audioSource)&#10;            {&#10;                _audioSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            }&#10;            &#10;            _healthController = GetComponent&lt;PlayerHealthController&gt;();&#10;        }&#10;        private void Start()&#10;        {&#10;            _healthView = _healthController?.HealthView;&#10;            &#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Calculate and award bonus points for remaining health&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;onComplete&quot;&gt;Callback when bonus calculation is complete&lt;/param&gt;&#10;        public void CalculateHealthBonus(System.Action onComplete = null)&#10;        {&#10;            if (_healthController == null)&#10;            {&#10;                Debug.LogWarning(&quot;[HealthBonusService] No PlayerHealthController found&quot;);&#10;                onComplete?.Invoke();&#10;                return;&#10;            }&#10;            &#10;            int remainingHp = _healthController.CurrentHp;&#10;            &#10;            if (remainingHp &lt;= 0)&#10;            {&#10;                Debug.Log(&quot;[HealthBonusService] No remaining HP for bonus&quot;);&#10;                onComplete?.Invoke();&#10;                return;&#10;            }&#10;            &#10;            Debug.Log($&quot;[HealthBonusService] Starting health bonus calculation: {remainingHp} HP remaining&quot;);&#10;            StartCoroutine(DrainHealthForBonus(remainingHp, onComplete));&#10;        }&#10;        &#10;        private IEnumerator DrainHealthForBonus(int remainingHp, System.Action onComplete)&#10;        {&#10;            // Wait before starting the drain&#10;            yield return new WaitForSeconds(drainDelay);&#10;            &#10;            int totalBonus = remainingHp * pointsPerHp;&#10;            Debug.Log($&quot;[HealthBonusService] Total bonus to award: {totalBonus} points&quot;);&#10;            &#10;            // Drain each HP point individually&#10;            for (int i = 0; i &lt; remainingHp; i++)&#10;            {&#10;                // Award points for this HP&#10;                _scoreService?.AddScore(pointsPerHp);&#10;                &#10;                // Calculate remaining health after draining this HP point&#10;                int healthAfterDrain = remainingHp - (i + 1);&#10;                &#10;                // Update health display (visual only)&#10;                _healthView?.UpdateDisplay(healthAfterDrain, _healthController.MaxHp);&#10;&#10;                // Play drain sound effect&#10;                if (bonusDrainSfx &amp;&amp; _audioSource)&#10;                {&#10;                    _audioSource.PlayOneShot(bonusDrainSfx);&#10;                }&#10;                &#10;                Debug.Log($&quot;[HealthBonusService] HP drained: {i + 1}/{remainingHp}, Remaining: {healthAfterDrain}, Points awarded: {pointsPerHp}&quot;);&#10;                &#10;                // Wait before next drain&#10;                yield return new WaitForSeconds(drainInterval);&#10;            }&#10;&#10;            onComplete?.Invoke();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameLifetimeScope.cs" />
              <option name="updatedContent" value="using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace StartGame&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     VContainer lifetime scope for Start Game screen&#10;    /// &lt;/summary&gt;&#10;    public class StartGameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[StartGameLifetimeScope] Configuring start game DI container...&quot;);&#10;&#10;            // Register core services needed for start screen&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ISceneLoadService, SceneLoadService&gt;(Lifetime.Singleton);&#10;&#10;            // Register core game management components&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;&#10;            // Register start game specific components&#10;            builder.RegisterComponentInHierarchy&lt;StartGameListener&gt;();&#10;&#10;            Debug.Log(&quot;[StartGameLifetimeScope] Start game DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>