<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/PopupTextService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/PopupTextService.cs" />
              <option name="originalContent" value="using Pooling;&#10;using TMPro;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Collectables.Score&#10;{&#10;    public class PopupTextService : MonoBehaviour&#10;    {&#10;        [Inject] private IPoolService _scoreTextPool;&#10;        [SerializeField] private TextMeshPro scoreTextPrefab;&#10;&#10;&#10;        private void OnEnable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected += HandleScoreCollected;&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected -= HandleScoreCollected;&#10;        }&#10;&#10;        private void HandleScoreCollected(int scoreAmount, Vector3 position)&#10;        {&#10;            ShowFloatingText(position, $&quot;{scoreAmount}&quot;);&#10;        }&#10;&#10;        public void ShowFloatingText(Vector3 position, string text)&#10;        {&#10;            TextMeshPro floatingTextObj = _scoreTextPool?.Get&lt;TextMeshPro&gt;(scoreTextPrefab, position, Quaternion.identity);&#10;                floatingText.text = text;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Pooling;&#10;using TMPro;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Collectables.Score&#10;{&#10;    public class PopupTextService : MonoBehaviour&#10;    {&#10;        [Inject] private IPoolService _scoreTextPool;&#10;        [SerializeField] private TextMeshPro scoreTextPrefab;&#10;&#10;&#10;        private void OnEnable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected += HandleScoreCollected;&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected -= HandleScoreCollected;&#10;        }&#10;&#10;        private void HandleScoreCollected(int scoreAmount, Vector3 position)&#10;        {&#10;            ShowFloatingText(position, $&quot;{scoreAmount}&quot;);&#10;        }&#10;&#10;        public void ShowFloatingText(Vector3 position, string text)&#10;        {&#10;            TextMeshPro floatingTextObj = _scoreTextPool?.Get&lt;TextMeshPro&gt;(scoreTextPrefab, position, Quaternion.identity);&#10;                floatingText.text = text;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/DI/GameLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/DI/GameLifetimeScope.cs" />
              <option name="originalContent" value="using Collectables.Score;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using Player.Components;&#10;using Player.Interfaces;&#10;using Player.Services;&#10;using Player.UI;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;using Weapons.Models;&#10;using Weapons.Services;&#10;&#10;namespace Core.DI&#10;{&#10;    public class GameLifetimeScope : LifetimeScope&#10;    {&#10;&#10;&#10;        protected override void Awake()&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Awake called.&quot;);&#10;            base.Awake();&#10;        }&#10;&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[GameLifetimeScope] Configuring DI container...&quot;);&#10;&#10;            // Register Core Services&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;&#10;            // Register EventBus as IEventPublisher as well (since EventBus implements IEventPublisher)&#10;            builder.Register&lt;IEventPublisher&gt;(resolver =&gt; resolver.Resolve&lt;IEventBus&gt;(), Lifetime.Singleton);&#10;&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IScoreService, ScoreService&gt;(Lifetime.Singleton);&#10;&#10;            // Register Player Services&#10;            builder.Register&lt;IPlayerLivesService&gt;(resolver&#10;                =&gt; new PlayerLivesService(&#10;                    resolver.Resolve&lt;IGameDataService&gt;(),&#10;                    resolver.Resolve&lt;IEventBus&gt;()&#10;                ), Lifetime.Singleton);&#10;&#10;            // Game Management&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;&#10;            // Weapons&#10;            builder.RegisterComponentInHierarchy&lt;AxeWeapon&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;FireballWeapon&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;WeaponManagerService&gt;();&#10;&#10;            // Health&#10;            builder.RegisterComponentInHierarchy&lt;PlayerHealthController&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;PlayerLivesUIController&gt;();&#10;&#10;            // Score System&#10;            builder.RegisterComponentInHierarchy&lt;ScoreController&gt;();&#10;&#10;&#10;            Debug.Log(&quot;[GameLifetimeScope] DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Collectables.Score;&#13;&#10;using Core.Data;&#13;&#10;using Core.Events;&#13;&#10;using Core.Services;&#13;&#10;using Player.Components;&#13;&#10;using Player.Interfaces;&#13;&#10;using Player.Services;&#13;&#10;using Player.UI;&#13;&#10;using UnityEngine;&#13;&#10;using VContainer;&#13;&#10;using VContainer.Unity;&#13;&#10;using Weapons.Models;&#13;&#10;using Weapons.Services;&#13;&#10;&#13;&#10;namespace Core.DI&#13;&#10;{&#13;&#10;    public class GameLifetimeScope : LifetimeScope&#13;&#10;    {&#13;&#10;&#13;&#10;&#13;&#10;        protected override void Awake()&#13;&#10;        {&#13;&#10;            Debug.Log(&quot;[GameLifetimeScope] Awake called.&quot;);&#13;&#10;            base.Awake();&#13;&#10;        }&#13;&#10;&#13;&#10;        protected override void Configure(IContainerBuilder builder)&#13;&#10;        {&#13;&#10;            Debug.Log(&quot;[GameLifetimeScope] Configuring DI container...&quot;);&#13;&#10;&#13;&#10;            // Register Core Services&#13;&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#13;&#10;&#13;&#10;            // Register EventBus as IEventPublisher as well (since EventBus implements IEventPublisher)&#13;&#10;            builder.Register&lt;IEventPublisher&gt;(resolver =&gt; resolver.Resolve&lt;IEventBus&gt;(), Lifetime.Singleton);&#13;&#10;&#13;&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#13;&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#13;&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#13;&#10;            builder.Register&lt;IScoreService, ScoreService&gt;(Lifetime.Singleton);&#13;&#10;&#13;&#10;            // Register Player Services&#13;&#10;            builder.Register&lt;IPlayerLivesService&gt;(resolver&#13;&#10;                =&gt; new PlayerLivesService(&#13;&#10;                    resolver.Resolve&lt;IGameDataService&gt;(),&#13;&#10;                    resolver.Resolve&lt;IEventBus&gt;()&#13;&#10;                ), Lifetime.Singleton);&#13;&#10;&#13;&#10;            // Game Management&#13;&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#13;&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#13;&#10;&#13;&#10;            // Weapons&#13;&#10;            builder.RegisterComponentInHierarchy&lt;AxeWeapon&gt;();&#13;&#10;            builder.RegisterComponentInHierarchy&lt;FireballWeapon&gt;();&#13;&#10;            builder.RegisterComponentInHierarchy&lt;WeaponManagerService&gt;();&#13;&#10;&#13;&#10;            // Health&#13;&#10;            builder.RegisterComponentInHierarchy&lt;PlayerHealthController&gt;();&#13;&#10;            builder.RegisterComponentInHierarchy&lt;PlayerLivesUIController&gt;();&#13;&#10;&#13;&#10;            // Score System&#13;&#10;            builder.RegisterComponentInHierarchy&lt;ScoreController&gt;();&#13;&#10;&#13;&#10;            // Pooling System&#13;&#10;            builder.RegisterComponentInHierarchy&lt;Pooling.PoolManager&gt;().As&lt;Pooling.IPoolService&gt;();&#13;&#10;&#13;&#10;&#13;&#10;            Debug.Log(&quot;[GameLifetimeScope] DI container configured successfully.&quot;);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyBehaviorController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyBehaviorController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Wires up modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyBehaviorController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (ITriggerBehavior trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;            foreach (IMovementBehavior move in _movementBehaviors) move.Move();&#10;            foreach (IAttackBehavior attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Coordinates modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyBehaviorController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (ITriggerBehavior trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;        }&#10;&#10;        private void FixedUpdate()&#10;        {&#10;            foreach (IMovementBehavior move in _movementBehaviors) move.Move();&#10;        }&#10;&#10;        private void LateUpdate()&#10;        {&#10;            foreach (IAttackBehavior attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyController.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Wires up modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (var trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;            foreach (var move in _movementBehaviors) move.Move();&#10;            foreach (var attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IAttackBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IAttackBehavior.cs" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IAttackBehavior&#10;    {&#10;        void Attack();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IMovementBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IMovementBehavior.cs" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IMovementBehavior&#10;    {&#10;        void Move();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/ITriggerBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/ITriggerBehavior.cs" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface ITriggerBehavior&#10;    {&#10;        void CheckTrigger();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/Behaviors/EnemyBehaviors.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/Behaviors/EnemyBehaviors.cs" />
              <option name="updatedContent" value="namespace Enemy.Behaviors&#10;{&#10;    // Optional movement behavior&#10;    public interface IMovable&#10;    {&#10;        void Move();&#10;    }&#10;&#10;    // Optional player proximity reaction&#10;    public interface IPlayerProximityReactable&#10;    {&#10;        void OnPlayerNearby();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/BirdEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/BirdEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Bird: Moves left, goes up and down&#10;    public class BirdEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private float moveSpeed = 2f;&#10;        [SerializeField] private float verticalAmplitude = 1f;&#10;        [SerializeField] private float verticalFrequency = 1f;&#10;        private Vector3 _startPos;&#10;        private float _time;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _startPos = transform.position;&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            _time += Time.deltaTime;&#10;            float yOffset = Mathf.Sin(_time * verticalFrequency) * verticalAmplitude;&#10;            transform.position = _startPos + new Vector3(-moveSpeed * _time, yOffset, 0);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBase.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public abstract class EnemyBase : MonoBehaviour&#10;    {&#10;        protected Rigidbody2D rb;&#10;        protected Collider2D col;&#10;        protected virtual void Awake()&#10;        {&#10;            rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            col = GetComponent&lt;Collider2D&gt;();&#10;        }&#10;&#10;        public virtual void Move() { }&#10;        public virtual void Attack() { }&#10;        public virtual void OnPlayerNearby() { }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBuilder.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBuilder.cs" />
              <option name="originalContent" value="using Enemy.Behaviors;&#10;using Weapons.Models;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyBuilder&#10;    {&#10;        private readonly EnemyBase _enemy;&#10;&#10;        public EnemyBuilder(EnemyBase enemy)&#10;        {&#10;            _enemy = enemy;&#10;        }&#10;&#10;        public EnemyBuilder WithFireSnakeBehavior()&#10;        {&#10;            // Example: assign FireballWeapon if available&#10;            var fireSnake = _enemy as FireSnakeEnemy;&#10;            if (fireSnake)&#10;            {&#10;                FireballWeapon weapon = fireSnake.GetComponentInChildren&lt;FireballWeapon&gt;();&#10;                if (weapon)&#10;                {&#10;                    weapon.Equip();&#10;                    // Additional setup if needed&#10;                }&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSpiderBehavior()&#10;        {&#10;            // Assign movement or proximity logic as needed&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithBirdBehavior()&#10;        {&#10;            // Assign movement logic as needed&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSnakeBehavior()&#10;        {&#10;            // Assign jump logic as needed&#10;            var snake = _enemy as SnakeEnemy;&#10;            if (snake)&#10;            {&#10;                // Example: assign a jump movement component or set jump parameters&#10;                // (Assume SnakeEnemy implements IMovable and has a Jump method)&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithFrogBehavior()&#10;        {&#10;            // Assign jump and proximity logic as needed&#10;            var frog = _enemy as FrogEnemy;&#10;            if (frog)&#10;            {&#10;                // Example: assign a jump movement component or set jump parameters&#10;                // (Assume FrogEnemy implements IMovable and IPlayerProximityReactable)&#10;            }&#10;            return this;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemy.Behaviors;&#10;using Weapons.Models;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyBuilder&#10;    {&#10;        private readonly EnemyBase _enemy;&#10;&#10;        public EnemyBuilder(EnemyBase enemy)&#10;        {&#10;            _enemy = enemy;&#10;        }&#10;&#10;        public EnemyBuilder WithFireSnakeBehavior()&#10;        {&#10;            // Example: assign FireballWeapon if available&#10;            var fireSnake = _enemy as FireSnakeEnemy;&#10;            if (fireSnake)&#10;            {&#10;                FireballWeapon weapon = fireSnake.GetComponentInChildren&lt;FireballWeapon&gt;();&#10;                if (weapon)&#10;                {&#10;                    weapon.Equip();&#10;                    // Additional setup if needed&#10;                }&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSpiderBehavior()&#10;        {&#10;            // Spider: Can move up/down or stay static in air&#10;            var spider = _enemy as SpiderEnemy;&#10;            if (spider)&#10;            {&#10;                // No extra setup needed; movement handled in SpiderEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithBirdBehavior()&#10;        {&#10;            // Bird: Moves left, goes up and down&#10;            var bird = _enemy as BirdEnemy;&#10;            if (bird)&#10;            {&#10;                // No extra setup needed; movement handled in BirdEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSnakeBehavior()&#10;        {&#10;            // Snake: Jumps forward&#10;            var snake = _enemy as SnakeEnemy;&#10;            if (snake)&#10;            {&#10;                // No extra setup needed; jump logic handled in SnakeEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithFrogBehavior()&#10;        {&#10;            // Frog: Jumps higher/farther, jumps when player is near&#10;            var frog = _enemy as FrogEnemy;&#10;            if (frog)&#10;            {&#10;                // No extra setup needed; jump and proximity handled in FrogEnemy&#10;            }&#10;            return this;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDirector.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDirector.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public static class EnemyDirector&#10;    {&#10;        // Entry point for configuring an enemy in the scene&#10;        public static void ConstructEnemy(EnemyType type, EnemyBase enemy)&#10;        {&#10;            // The director delegates the construction to the factory&#10;            EnemyFactory.ConfigureEnemy(type, enemy);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyFactory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyFactory.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public enum EnemyType&#10;    {&#10;        FireSnake,&#10;        Spider,&#10;        Bird,&#10;        Snake,&#10;        Frog&#10;    }&#10;&#10;    public static class EnemyFactory&#10;    {&#10;        // Configures an existing enemy instance using the builder pattern&#10;        public static void ConfigureEnemy(EnemyType type, EnemyBase enemy)&#10;        {&#10;            if (enemy == null) throw new ArgumentNullException(nameof(enemy));&#10;            var builder = new EnemyBuilder(enemy);&#10;            switch (type)&#10;            {&#10;                case EnemyType.FireSnake:&#10;                    builder.WithFireSnakeBehavior();&#10;                    break;&#10;                case EnemyType.Spider:&#10;                    builder.WithSpiderBehavior();&#10;                    break;&#10;                case EnemyType.Bird:&#10;                    builder.WithBirdBehavior();&#10;                    break;&#10;                case EnemyType.Snake:&#10;                    builder.WithSnakeBehavior();&#10;                    break;&#10;                case EnemyType.Frog:&#10;                    builder.WithFrogBehavior();&#10;                    break;&#10;                default:&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/FireSnakeEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/FireSnakeEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Weapons.Models;&#10;&#10;namespace Enemy&#10;{&#10;    public class FireSnakeEnemy : EnemyBase&#10;    {&#10;        [SerializeField] private FireballWeapon fireballWeapon;&#10;        [SerializeField] private float attackCooldown = 2f;&#10;        private float _nextAttackTime;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            if (fireballWeapon != null)&#10;                fireballWeapon.Equip();&#10;        }&#10;&#10;        public override void Attack()&#10;        {&#10;            if (fireballWeapon == null)&#10;                return;&#10;            if (Time.time &lt; _nextAttackTime)&#10;                return;&#10;            fireballWeapon.Shoot();&#10;            _nextAttackTime = Time.time + attackCooldown;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/FrogEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/FrogEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Frog: Jumps higher and farther, jumps when player is near&#10;    public class FrogEnemy : EnemyBase, IMovable, IPlayerProximityReactable&#10;    {&#10;        [SerializeField] private float jumpForce = 12f;&#10;        [SerializeField] private float jumpDistance = 6f;&#10;        [SerializeField] private float jumpCooldown = 2f;&#10;        private float _nextJumpTime;&#10;        private Rigidbody2D _rb;&#10;        private bool _playerNearby;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (_playerNearby &amp;&amp; Time.time &gt;= _nextJumpTime)&#10;            {&#10;                Vector2 jumpVector = new Vector2(jumpDistance, jumpForce);&#10;                _rb.AddForce(jumpVector, ForceMode2D.Impulse);&#10;                _nextJumpTime = Time.time + jumpCooldown;&#10;                _playerNearby = false; // Only jump once per proximity event&#10;            }&#10;        }&#10;&#10;        public void OnPlayerNearby()&#10;        {&#10;            _playerNearby = true;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/EnemyBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/EnemyBase.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/FireSnake.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/FireSnake.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/SnakeEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/SnakeEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Snake: Jumps forward&#10;    public class SnakeEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private float jumpForce = 7f;&#10;        [SerializeField] private float jumpInterval = 2f;&#10;        private float _nextJumpTime;&#10;        private Rigidbody2D _rb;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (Time.time &gt;= _nextJumpTime)&#10;            {&#10;                _rb.AddForce(Vector2.right * jumpForce, ForceMode2D.Impulse);&#10;                _nextJumpTime = Time.time + jumpInterval;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/SpiderEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/SpiderEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Spider: Can move up/down or stay static in air&#10;    public class SpiderEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private bool canMove = true;&#10;        [SerializeField] private float moveSpeed = 2f;&#10;        [SerializeField] private float moveDistance = 3f;&#10;        private Vector3 _startPos;&#10;        private bool _movingUp = true;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _startPos = transform.position;&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (!canMove) return;&#10;            float delta = moveSpeed * Time.deltaTime * (_movingUp ? 1 : -1);&#10;            transform.position += new Vector3(0, delta, 0);&#10;            if (Mathf.Abs(transform.position.y - _startPos.y) &gt; moveDistance)&#10;                _movingUp = !_movingUp;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Health.Interfaces;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class AlwaysAllowDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        public bool CanBeDamagedBy(GameObject damager) =&gt; true;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All layers by default&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target))&#10;                return;&#10;&#10;            int amount = _dealer?.GetDamageAmount() ?? 1;&#10;            damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using System.Linq;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class BidirectionalDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject other = collision.gameObject;&#10;            GameObject self = gameObject;&#10;&#10;            // 1. This object damages the other&#10;            TryDealDamage(self, other, _dealer, _damageConditions, targetLayers);&#10;&#10;            // 2. The other object damages this&#10;            var otherDealer = other.GetComponent&lt;IDamageDealer&gt;();&#10;            var otherConditions = other.GetComponent&lt;DamageConditionsComponent&gt;();&#10;            TryDealDamage(other, self, otherDealer, otherConditions, targetLayers);&#10;        }&#10;&#10;        private static void TryDealDamage(&#10;            GameObject dealerObj,&#10;            GameObject targetObj,&#10;            IDamageDealer dealer,&#10;            DamageConditionsComponent conditions,&#10;            LayerMask targetLayers)&#10;        {&#10;            if (dealer == null) return;&#10;            if (((1 &lt;&lt; targetObj.layer) &amp; targetLayers) == 0) return;&#10;            var damageable = targetObj.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (conditions &amp;&amp; !conditions.CanBeDamagedBy(targetObj)) return;&#10;            int amount = dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, dealerObj);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;// This script is now deprecated in favor of TakeDamageOnCollision for most use cases.&#10;// Please use TakeDamageOnCollision on all damageable objects instead." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            foreach (IDamageCondition cond in _conditions)&#10;            {&#10;                if (cond != null &amp;&amp; !cond.CanBeDamagedBy(damager))&#10;                    return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            return _conditions.All(cond =&gt; cond == null || cond.CanBeDamagedBy(damager));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs" />
              <option name="originalContent" value="using Health.Damage;&#10;using UnityEditor;&#10;using UnityEngine;&#10;&#10;[CustomPropertyDrawer(typeof(ConditionLeaf))]&#10;public class ConditionLeafPropertyDrawer : ConditionNodePropertyDrawer {}&#10;&#10;[CustomPropertyDrawer(typeof(AndCondition))]&#10;public class AndConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;AND Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(OrCondition))]&#10;public class OrConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;OR Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(NotCondition))]&#10;public class NotConditionPropertyDrawer : ConditionNodePropertyDrawer {}&#10;" />
              <option name="updatedContent" value="// All custom property drawers for node types are now handled by ConditionNodePropertyDrawer.&#10;// This file is no longer needed and can be deleted, or you can leave it empty." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/README.md" />
              <option name="updatedContent" value="// Health/README.md&#10;&#10;# Health System Setup Guide&#10;&#10;## Folder Structure&#10;- `Core/` – Health logic&#10;- `Interfaces/` – All interfaces&#10;- `Shield/` – Shield logic&#10;- `Invincibility/` – Invincibility logic&#10;- `Damage/` – Damage logic and conditions&#10;&#10;## How to Compose Entities in Unity Editor&#10;&#10;### Player (Basic)&#10;- Add `HealthComponent` (Core)&#10;&#10;### Player with Shield&#10;- Add `HealthComponent` (Core)&#10;- Add `ShieldComponent` (Shield)&#10;&#10;### Player with Invincibility&#10;- Add `HealthComponent` (Core)&#10;- Add `InvincibilityComponent` (Invincibility)&#10;- Connect to your `IPowerUp` system to toggle invincibility&#10;&#10;### Enemy&#10;- Add `HealthComponent` (Core)&#10;&#10;### Hazard (Standard)&#10;- Add `HazardComponent` (Damage)&#10;- Add `DamageDealerComponent` (Damage)&#10;- Add a damage condition (e.g., `AlwaysAllowDamage`, `OnlyInvincibleCanDamage`, `OnlyShieldedCanDamage`) as needed&#10;- Assign the condition(s) to the `HazardComponent`'s `damageConditions` array in the Inspector&#10;&#10;### Custom Damage Conditions&#10;- Create a new MonoBehaviour implementing `IDamageCondition`&#10;- Add it to the hazard GameObject&#10;- Assign it in the `HazardComponent`&#10;&#10;## Extending&#10;- To add new damage conditions, create a new script implementing `IDamageCondition` and add it in the Editor. No need to modify existing code.&#10;&#10;## Events&#10;- Use UnityEvents or C# events on components for custom reactions (e.g., OnDeath, OnShieldBroken)&#10;&#10;## Cleanup&#10;- Remove old scripts like `ShieldActiveDisappearHazard`, `OnlyInvincibilityDamageController`, etc. after migration.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// When enabled, instantly kills any damageable object the player collides with.&#10;    /// Should be enabled only when the player is invincible.&#10;    /// &lt;/summary&gt;&#10;    [DisallowMultipleComponent]&#10;    public class PlayerInvincibleDamageDealer : MonoBehaviour, IDamageDealer&#10;    {&#10;        [SerializeField] private int damageAmount = 9999; // &quot;Kill&quot; value&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All by default&#10;&#10;        public int GetDamageAmount() =&gt; damageAmount;&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if (((1 &lt;&lt; collision.gameObject.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            var damageable = collision.gameObject.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable != null)&#10;            {&#10;                damageable.Damage(damageAmount, gameObject);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Pooling/IPoolService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Pooling/IPoolService.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Pooling&#10;{&#10;    public interface IPoolService&#10;    {&#10;        GameObject Get(GameObject prefab, Vector3 position, Quaternion rotation);&#10;        void Release(GameObject prefab, GameObject instance);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Pooling&#10;{&#10;    public interface IPoolService&#10;    {&#10;        GameObject Get(GameObject prefab, Vector3 position, Quaternion rotation);&#10;        void Release(GameObject prefab, GameObject instance);&#10;        T Get&lt;T&gt;(GameObject prefab, Vector3 position, Quaternion rotation) where T : MonoBehaviour;&#10;        void Release&lt;T&gt;(GameObject prefab, T instance) where T : MonoBehaviour;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Pooling/IPoolable.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Pooling/IPoolable.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Pooling/PoolManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Pooling/PoolManager.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.Pool;&#10;&#10;namespace Pooling&#10;{&#10;    public class PoolManager : MonoBehaviour, IPoolService&#10;    {&#10;        [SerializeField] private int defaultCapacity = 10;&#10;        [SerializeField] private int maxSize = 100;&#10;&#10;        private readonly Dictionary&lt;GameObject, IObjectPool&lt;GameObject&gt;&gt; _pools = new();&#10;&#10;        public GameObject Get(GameObject prefab, Vector3 position, Quaternion rotation)&#10;        {&#10;            if (!_pools.TryGetValue(prefab, out var pool))&#10;            {&#10;                pool = CreatePool(prefab);&#10;                _pools[prefab] = pool;&#10;            }&#10;&#10;            GameObject obj = pool.Get();&#10;            obj.transform.SetPositionAndRotation(position, rotation);&#10;            return obj;&#10;        }&#10;&#10;        public void Release(GameObject prefab, GameObject instance)&#10;        {&#10;            if (_pools.TryGetValue(prefab, out var pool))&#10;                pool.Release(instance);&#10;            else&#10;                Destroy(instance);&#10;        }&#10;&#10;        public T Get&lt;T&gt;(GameObject prefab, Vector3 position, Quaternion rotation) where T : MonoBehaviour&#10;        {&#10;            GameObject obj = Get(prefab, position, rotation);&#10;            if (obj.TryGetComponent(out T component))&#10;            {&#10;                return component;&#10;            }&#10;&#10;            Debug.LogError($&quot;The prefab {prefab.name} does not have a component of type {typeof(T).Name}.&quot;);&#10;            return null;&#10;        }&#10;&#10;        public void Release&lt;T&gt;(GameObject prefab, T instance) where T : MonoBehaviour&#10;        {&#10;            Release(prefab, instance.gameObject);&#10;        }&#10;&#10;        private IObjectPool&lt;GameObject&gt; CreatePool(GameObject prefab)&#10;        {&#10;            return new ObjectPool&lt;GameObject&gt;(&#10;                () =&gt;&#10;                {&#10;                    GameObject obj = Instantiate(prefab, transform);&#10;                    obj.SetActive(false);&#10;                    return obj;&#10;                },&#10;                obj =&gt; obj?.SetActive(true),&#10;                obj =&gt; obj?.SetActive(false),&#10;                Destroy,&#10;                false,&#10;                defaultCapacity,&#10;                maxSize&#10;            );&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.Pool;&#10;&#10;namespace Pooling&#10;{&#10;    public class PoolManager : MonoBehaviour, IPoolService&#10;    {&#10;        [SerializeField] private int defaultCapacity = 10;&#10;        [SerializeField] private int maxSize = 100;&#10;&#10;        private readonly Dictionary&lt;GameObject, IObjectPool&lt;GameObject&gt;&gt; _pools = new();&#10;&#10;        public GameObject Get(GameObject prefab, Vector3 position, Quaternion rotation)&#10;        {&#10;            if (!_pools.TryGetValue(prefab, out var pool))&#10;            {&#10;                pool = CreatePool(prefab);&#10;                _pools[prefab] = pool;&#10;            }&#10;&#10;            GameObject obj = pool.Get();&#10;            obj.transform.SetPositionAndRotation(position, rotation);&#10;            return obj;&#10;        }&#10;&#10;        public void Release(GameObject prefab, GameObject instance)&#10;        {&#10;            if (instance == null)&#10;            {&#10;                Debug.LogWarning(&quot;Attempted to release a null instance.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (_pools.TryGetValue(prefab, out var pool))&#10;            {&#10;                pool.Release(instance);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning($&quot;No pool found for prefab '{prefab.name}'. Ensure the prefab is registered correctly.&quot;);&#10;                instance.SetActive(false); // Disable instead of destroying&#10;            }&#10;        }&#10;&#10;        public T Get&lt;T&gt;(GameObject prefab, Vector3 position, Quaternion rotation) where T : MonoBehaviour&#10;        {&#10;            GameObject obj = Get(prefab, position, rotation);&#10;            if (obj.TryGetComponent(out T component))&#10;            {&#10;                return component;&#10;            }&#10;&#10;            Debug.LogError($&quot;The prefab {prefab.name} does not have a component of type {typeof(T).Name}.&quot;);&#10;            return null;&#10;        }&#10;&#10;        public void Release&lt;T&gt;(GameObject prefab, T instance) where T : MonoBehaviour&#10;        {&#10;            Release(prefab, instance.gameObject);&#10;        }&#10;&#10;        private IObjectPool&lt;GameObject&gt; CreatePool(GameObject prefab)&#10;        {&#10;            return new ObjectPool&lt;GameObject&gt;(&#10;                () =&gt;&#10;                {&#10;                    GameObject obj = Instantiate(prefab, transform);&#10;                    obj.SetActive(false);&#10;                    return obj;&#10;                },&#10;                obj =&gt; obj?.SetActive(true),&#10;                obj =&gt; obj?.SetActive(false),&#10;                Destroy,&#10;                false,&#10;                defaultCapacity,&#10;                maxSize&#10;            );&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Pooling/PooledObject.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Pooling/PooledObject.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Pooling&#10;{&#10;    public class PooledObject : MonoBehaviour&#10;    {&#10;        public GameObject prefab;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Projectiles/Core/BaseProjectile.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Projectiles/Core/BaseProjectile.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;using Weapons;&#10;using Weapons.Interfaces;&#10;&#10;namespace Projectiles.Core&#10;{&#10;    public abstract class BaseProjectile : MonoBehaviour, IWeaponTypeProvider&#10;    {&#10;        [SerializeField] protected Vector2 speed = new(12f, 0f);&#10;&#10;        protected Rigidbody2D Rb;&#10;        public Action&lt;GameObject&gt; OnProjectileDestroyed { get; set; }&#10;&#10;        protected virtual void Awake()&#10;        {&#10;            Rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;        public virtual WeaponType WeaponType { get; set; }&#10;&#10;&#10;        public void Fire()&#10;        {&#10;            Move();&#10;        }&#10;&#10;        protected abstract void Move();&#10;&#10;        protected void DestroyProjectile()&#10;        {&#10;            if (!gameObject.activeInHierarchy)&#10;            {&#10;                return;&#10;            }&#10;&#10;            if (OnProjectileDestroyed != null)&#10;            {&#10;&#10;                // Reset all physics properties&#10;                Rb.linearVelocity = Vector2.zero;&#10;                Rb.angularVelocity = 0f;&#10;&#10;                // Reset any accumulated forces&#10;                Rb.totalForce = Vector2.zero;&#10;                Rb.totalTorque = 0f;&#10;                OnProjectileDestroyed?.Invoke(gameObject);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;using Weapons;&#10;using Weapons.Interfaces;&#10;&#10;namespace Projectiles.Core&#10;{&#10;    public abstract class BaseProjectile : MonoBehaviour, IWeaponTypeProvider&#10;    {&#10;        [SerializeField] protected Vector2 speed = new(12f, 0f);&#10;&#10;        protected Rigidbody2D Rb;&#10;        public Action&lt;GameObject&gt; OnProjectileDestroyed { get; set; }&#10;&#10;        protected virtual void Awake()&#10;        {&#10;            Rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;        public virtual WeaponType WeaponType { get; set; }&#10;&#10;&#10;        public void Fire()&#10;        {&#10;            Move();&#10;        }&#10;&#10;        protected abstract void Move();&#10;&#10;        protected void DestroyProjectile()&#10;        {&#10;            if (!gameObject.activeInHierarchy)&#10;            {&#10;                return;&#10;            }&#10;&#10;            if (OnProjectileDestroyed != null)&#10;            {&#10;&#10;                // Reset all physics properties&#10;                Rb.linearVelocity = Vector2.zero;&#10;                Rb.angularVelocity = 0f;&#10;&#10;                // Reset any accumulated forces&#10;                Rb.totalForce = Vector2.zero;&#10;                Rb.totalTorque = 0f;&#10;                OnProjectileDestroyed?.Invoke(gameObject);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Projectiles/ProjectileAxe.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Projectiles/ProjectileAxe.cs" />
              <option name="originalContent" value="using System;&#10;using Projectiles.Core;&#10;using UnityEngine;&#10;using Weapons;&#10;&#10;namespace Projectiles&#10;{&#10;    public class ProjectileAxe : BaseProjectile&#10;    {&#10;        [NonSerialized] public float Direction;&#10;        [NonSerialized] public float ThrowerVelocityX;&#10;        private void OnBecameInvisible()&#10;        {&#10;            ReturnToPool();&#10;        }&#10;        private void OnCollisionEnter2D(Collision2D other)&#10;        {&#10;            if (other.gameObject.CompareTag(&quot;Player&quot;))&#10;                return;&#10;&#10;            ReturnToPool();&#10;            Debug.Log($&quot;Axe hit {other.gameObject.name}.&quot;);&#10;        }&#10;&#10;&#10;        protected override void Move()&#10;        {&#10;&#10;            // World-space velocity = player's current velocity + desired arc velocity&#10;            Vector2 worldVelocity = new(speed.x * Direction + ThrowerVelocityX, speed.y);&#10;&#10;            // Cancel out thrower motion to isolate projectile speed&#10;            Rb.linearVelocity = worldVelocity;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#13;&#10;using Projectiles.Core;&#13;&#10;using UnityEngine;&#13;&#10;using Weapons;&#13;&#10;&#13;&#10;namespace Projectiles&#13;&#10;{&#13;&#10;    public class ProjectileAxe : BaseProjectile&#13;&#10;    {&#13;&#10;        [NonSerialized] public float Direction;&#13;&#10;        [NonSerialized] public float ThrowerVelocityX;&#13;&#10;        private void OnBecameInvisible()&#13;&#10;        {&#13;&#10;            DestroyProjectile();&#13;&#10;        }&#13;&#10;        private void OnCollisionEnter2D(Collision2D other)&#13;&#10;        {&#13;&#10;            if (other.gameObject.CompareTag(&quot;Player&quot;))&#13;&#10;                return;&#13;&#10;&#13;&#10;            DestroyProjectile();&#13;&#10;            Debug.Log($&quot;Axe hit {other.gameObject.name}.&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;&#13;&#10;        protected override void Move()&#13;&#10;        {&#13;&#10;&#13;&#10;            // World-space velocity = player's current velocity + desired arc velocity&#13;&#10;            Vector2 worldVelocity = new(speed.x * Direction + ThrowerVelocityX, speed.y);&#13;&#10;&#13;&#10;            // Cancel out thrower motion to isolate projectile speed&#13;&#10;            Rb.linearVelocity = worldVelocity;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Projectiles/ProjectileBoomerang.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Projectiles/ProjectileBoomerang.cs" />
              <option name="originalContent" value="using System;&#10;using Projectiles.Core;&#10;using UnityEngine;&#10;using Weapons;&#10;&#10;namespace Projectiles&#10;{&#10;    public class ProjectileBoomerang : BaseProjectile&#10;    {&#10;        [SerializeField] private float totalFlightTime = 1f;&#10;        [SerializeField] private AnimationCurve trajectoryXCurve = AnimationCurve.Linear(0, 0, 1, 0);&#10;        [SerializeField] private AnimationCurve trajectoryYCurve = AnimationCurve.Linear(0, 0, 1, 0);&#10;&#10;        private float _flightTimer;&#10;        private bool _isFlying;&#10;        private Vector3 _startPosition; // Fixed start position&#10;&#10;        [NonSerialized] public float Direction;&#10;        [NonSerialized] public Transform PlayerTransform;&#10;&#10;        private void Update()&#10;        {&#10;&#10;            if (_isFlying &amp;&amp; PlayerTransform)&#10;            {&#10;                _flightTimer += Time.deltaTime;&#10;                float progress = _flightTimer / totalFlightTime;&#10;&#10;                if (progress &gt;= 1f)&#10;                {&#10;                    OnBoomerangReturned?.Invoke();&#10;                    ReturnToPool();&#10;                    return;&#10;                }&#10;&#10;                // Calculate curve offsets&#10;                float xOffset = trajectoryXCurve.Evaluate(progress) * speed.x * Direction;&#10;                float yOffset = trajectoryYCurve.Evaluate(progress) * speed.y;&#10;&#10;                // Blend the base position from start to current player position&#10;                Vector3 basePosition = Vector3.Lerp(_startPosition, PlayerTransform.position, progress);&#10;                Vector3 curvePosition = basePosition + new Vector3(xOffset, yOffset, 0);&#10;&#10;                transform.position = curvePosition;&#10;&#10;                // Check if close to player (especially near the end)&#10;                if (progress &gt; 0.7f &amp;&amp; Vector3.Distance(transform.position, PlayerTransform.position) &lt; 1.5f)&#10;                {&#10;                    OnBoomerangReturned?.Invoke();&#10;                    ReturnToPool();&#10;                }&#10;            }&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            _isFlying = false;&#10;            _flightTimer = 0f;&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D other)&#10;        {&#10;            if (other.gameObject.CompareTag(&quot;Player&quot;) &amp;&amp; _flightTimer &gt; 0.5f)&#10;            {&#10;                OnBoomerangReturned?.Invoke();&#10;                ReturnToPool();&#10;            }&#10;        }&#10;&#10;        public event Action OnBoomerangReturned;&#10;&#10;        protected override void Move()&#10;        {&#10;            _startPosition = transform.position;&#10;            _flightTimer = 0f;&#10;            _isFlying = true;&#10;            transform.localScale = new Vector3(Direction, 1, 1);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using Projectiles.Core;&#10;using UnityEngine;&#10;using Weapons;&#10;&#10;namespace Projectiles&#10;{&#10;    public class ProjectileBoomerang : BaseProjectile&#10;    {&#10;        [SerializeField] private float totalFlightTime = 1f;&#10;        [SerializeField] private AnimationCurve trajectoryXCurve = AnimationCurve.Linear(0, 0, 1, 0);&#10;        [SerializeField] private AnimationCurve trajectoryYCurve = AnimationCurve.Linear(0, 0, 1, 0);&#10;&#10;        private float _flightTimer;&#10;        private bool _isFlying;&#10;        private Vector3 _startPosition; // Fixed start position&#10;&#10;        [NonSerialized] public float Direction;&#10;        [NonSerialized] public Transform PlayerTransform;&#10;&#10;        private void Update()&#10;        {&#10;&#10;            if (_isFlying &amp;&amp; PlayerTransform)&#10;            {&#10;                _flightTimer += Time.deltaTime;&#10;                float progress = _flightTimer / totalFlightTime;&#10;&#10;                if (progress &gt;= 1f)&#10;                {&#10;                    OnBoomerangReturned?.Invoke();&#10;                    DestroyProjectile();&#10;                    return;&#10;                }&#10;&#10;                // Calculate curve offsets&#10;                float xOffset = trajectoryXCurve.Evaluate(progress) * speed.x * Direction;&#10;                float yOffset = trajectoryYCurve.Evaluate(progress) * speed.y;&#10;&#10;                // Blend the base position from start to current player position&#10;                Vector3 basePosition = Vector3.Lerp(_startPosition, PlayerTransform.position, progress);&#10;                Vector3 curvePosition = basePosition + new Vector3(xOffset, yOffset, 0);&#10;&#10;                transform.position = curvePosition;&#10;&#10;                // Check if close to player (especially near the end)&#10;                if (progress &gt; 0.7f &amp;&amp; Vector3.Distance(transform.position, PlayerTransform.position) &lt; 1.5f)&#10;                {&#10;                    OnBoomerangReturned?.Invoke();&#10;                    DestroyProjectile();&#10;                }&#10;            }&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            _isFlying = false;&#10;            _flightTimer = 0f;&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D other)&#10;        {&#10;            if (other.gameObject.CompareTag(&quot;Player&quot;) &amp;&amp; _flightTimer &gt; 0.5f)&#10;            {&#10;                OnBoomerangReturned?.Invoke();&#10;                DestroyProjectile();&#10;            }&#10;        }&#10;&#10;        public event Action OnBoomerangReturned;&#10;&#10;        protected override void Move()&#10;        {&#10;            _startPosition = transform.position;&#10;            _flightTimer = 0f;&#10;            _isFlying = true;&#10;            transform.localScale = new Vector3(Direction, 1, 1);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Projectiles/ProjectileFireball.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Projectiles/ProjectileFireball.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections;&#10;using Projectiles.Core;&#10;using UnityEngine;&#10;using Weapons;&#10;&#10;namespace Projectiles&#10;{&#10;    public class ProjectileFireball : BaseProjectile&#10;    {&#10;        public float destroyTime = 5f;&#10;        [NonSerialized] public float Direction;&#10;        private void OnEnable()&#10;        {&#10;            StartCoroutine(DestroyObject());&#10;        }&#10;        private void OnBecameInvisible()&#10;        {&#10;            ReturnToPool();&#10;        }&#10;        private void OnCollisionEnter2D(Collision2D other)&#10;        {&#10;            if (other.gameObject.CompareTag(&quot;Player&quot;))&#10;                return;&#10;&#10;            Debug.Log($&quot;Laser hit {other.gameObject.name}.&quot;);&#10;            ReturnToPool();&#10;        }&#10;        private IEnumerator DestroyObject()&#10;        {&#10;            yield return new WaitForSeconds(destroyTime);&#10;            ReturnToPool();&#10;        }&#10;&#10;&#10;        protected override void Move()&#10;        {&#10;            Rb.linearVelocity = new Vector2(speed.x * Direction, speed.y);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections;&#10;using Projectiles.Core;&#10;using UnityEngine;&#10;using Weapons;&#10;&#10;namespace Projectiles&#10;{&#10;    public class ProjectileFireball : BaseProjectile&#10;    {&#10;        public float destroyTime = 5f;&#10;        [NonSerialized] public float Direction;&#10;        private void OnEnable()&#10;        {&#10;            StartCoroutine(DestroyObject());&#10;        }&#10;        private void OnBecameInvisible()&#10;        {&#10;            ReturnToPool();&#10;        }&#10;        private void OnCollisionEnter2D(Collision2D other)&#10;        {&#10;            if (other.gameObject.CompareTag(&quot;Player&quot;))&#10;                return;&#10;&#10;            Debug.Log($&quot;Laser hit {other.gameObject.name}.&quot;);&#10;            ReturnToPool();&#10;        }&#10;        private IEnumerator DestroyObject()&#10;        {&#10;            yield return new WaitForSeconds(destroyTime);&#10;            ReturnToPool();&#10;        }&#10;&#10;&#10;        protected override void Move()&#10;        {&#10;            Rb.linearVelocity = new Vector2(speed.x * Direction, speed.y);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/AxeWeapon.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/AxeWeapon.cs" />
              <option name="originalContent" value="using System;&#10;using Pooling;&#10;using Projectiles;&#10;using UnityEngine;&#10;using VContainer;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class AxeWeapon : MonoBehaviour, IUseableWeapon&#10;    {&#10;        [SerializeField] private WeaponType weaponType = WeaponType.Axe;&#10;        public WeaponType WeaponType =&gt; weaponType;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.5f;&#10;        private float _nextFireTime;&#10;&#10;        [NonSerialized] private Rigidbody2D _throwerRb;&#10;&#10;        [Inject] private IPoolService _poolService;&#10;        [SerializeField] private GameObject axePrefab;&#10;        private bool IsEquipped { get; set; }&#10;&#10;        private void Awake()&#10;        {&#10;            _throwerRb = GetComponentInParent&lt;Rigidbody2D&gt;();&#10;        }&#10;        public void Shoot()&#10;        {&#10;            // Check if weapon is equipped&#10;            if (!IsEquipped)&#10;            {&#10;                return;&#10;            }&#10;&#10;            // Check cooldown&#10;            if (Time.time &lt; _nextFireTime)&#10;            {&#10;                return;&#10;            }&#10;&#10;            GameObject curAxe = _poolService.Get(axePrefab, spawnPoint ? spawnPoint.position : transform.position, Quaternion.identity);&#10;&#10;            if (curAxe.TryGetComponent(out ProjectileAxe scAxe))&#10;            {&#10;                curAxe.layer = gameObject.layer;&#10;&#10;                scAxe.Direction = transform.parent?.localScale.x ?? 1;&#10;                scAxe.ThrowerVelocityX = _throwerRb.linearVelocity.x;&#10;&#10;                scAxe.Fire();&#10;&#10;                // Set cooldown&#10;                _nextFireTime = Time.time + cooldownTime;&#10;            }&#10;        }&#10;&#10;        public void Equip()&#10;        {&#10;            IsEquipped = true;&#10;        }&#10;&#10;        public void UnEquip()&#10;        {&#10;            IsEquipped = false;&#10;        }&#10;&#10;        public void Release(GameObject instance)&#10;        {&#10;            _poolService.Release(axePrefab, instance);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using Pooling;&#10;using Projectiles;&#10;using UnityEngine;&#10;using VContainer;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class AxeWeapon : MonoBehaviour, IUseableWeapon&#10;    {&#10;        [SerializeField] private WeaponType weaponType = WeaponType.Axe;&#10;        public WeaponType WeaponType =&gt; weaponType;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.5f;&#10;        private float _nextFireTime;&#10;&#10;        [NonSerialized] private Rigidbody2D _throwerRb;&#10;&#10;        [Inject] private IPoolService _poolService;&#10;        [SerializeField] private GameObject axePrefab;&#10;        private bool IsEquipped { get; set; }&#10;&#10;        private void Awake()&#10;        {&#10;            _throwerRb = GetComponentInParent&lt;Rigidbody2D&gt;();&#10;        }&#10;        public void Shoot()&#10;        {&#10;            // Check if weapon is equipped&#10;            if (!IsEquipped)&#10;            {&#10;                return;&#10;            }&#10;&#10;            // Check cooldown&#10;            if (Time.time &lt; _nextFireTime)&#10;            {&#10;                return;&#10;            }&#10;&#10;            GameObject curAxe = _poolService.Get(axePrefab, spawnPoint ? spawnPoint.position : transform.position, Quaternion.identity);&#10;&#10;            if (curAxe.TryGetComponent(out ProjectileAxe scAxe))&#10;            {&#10;                curAxe.layer = gameObject.layer;&#10;&#10;                scAxe.Direction = transform.parent?.localScale.x ?? 1;&#10;                scAxe.ThrowerVelocityX = _throwerRb.linearVelocity.x;&#10;&#10;                scAxe.Fire();&#10;&#10;                // Set cooldown&#10;                _nextFireTime = Time.time + cooldownTime;&#10;            }&#10;        }&#10;&#10;        public void Equip()&#10;        {&#10;            IsEquipped = true;&#10;        }&#10;&#10;        public void UnEquip()&#10;        {&#10;            IsEquipped = false;&#10;        }&#10;&#10;        public void Release(GameObject instance)&#10;        {&#10;            _poolService.Release(axePrefab, instance);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/BoomerangWeapon.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/BoomerangWeapon.cs" />
              <option name="originalContent" value="using System;&#10;using Projectiles;&#10;using UnityEngine;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class BoomerangWeapon : MonoBehaviour, IAmmoWeapon&#10;    {&#10;        [SerializeField] private WeaponType weaponType = WeaponType.Boomerang;&#10;        public WeaponType WeaponType =&gt; weaponType;        &#10;        [SerializeField] private GameObject boomerang;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.3f;&#10;&#10;        private float _nextFireTime;&#10;&#10;        private GameObject _pooledBoomerang;&#10;        private ProjectileBoomerang _pooledProjectile;&#10;        private Transform _returnToTransform;&#10;&#10;        private void Start()&#10;        {&#10;            _returnToTransform = transform.parent;&#10;&#10;            if (!boomerang)&#10;                return;&#10;&#10;            Transform spawnParent = spawnPoint ? spawnPoint : transform;&#10;            _pooledBoomerang = Instantiate(boomerang, spawnParent.position, Quaternion.identity, spawnParent);&#10;            _pooledProjectile = _pooledBoomerang.GetComponent&lt;ProjectileBoomerang&gt;();&#10;            _pooledProjectile.WeaponType = WeaponType;&#10;            &#10;            _pooledBoomerang.SetActive(false);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (_pooledProjectile)&#10;                _pooledProjectile.OnBoomerangReturned -= OnBoomerangReturned;&#10;&#10;            if (_pooledBoomerang)&#10;                Destroy(_pooledBoomerang);&#10;        }&#10;&#10;        public int CurrentAmmo { get; private set; } = 1;&#10;        public int MaxAmmo =&gt; 1;&#10;        public bool HasAmmo =&gt; CurrentAmmo &gt; 0;&#10;&#10;        public void SetAmmo(int ammo)&#10;        {&#10;            int old = CurrentAmmo;&#10;            CurrentAmmo = Mathf.Clamp(ammo, 0, MaxAmmo);&#10;            if (old != CurrentAmmo)&#10;                OnAmmoChanged?.Invoke(CurrentAmmo);&#10;        }&#10;&#10;        public void Shoot()&#10;        {&#10;            if (Time.time &lt; _nextFireTime || !HasAmmo || !_pooledBoomerang || _pooledBoomerang.activeSelf)&#10;                return;&#10;&#10;            _pooledBoomerang.transform.SetPositionAndRotation(&#10;                spawnPoint ? spawnPoint.position : transform.position,&#10;                Quaternion.identity&#10;            );&#10;&#10;            _pooledBoomerang.layer = gameObject.layer;&#10;            SetAmmo(0);&#10;&#10;            float dir = transform.parent?.localScale.x ?? 1;&#10;            _pooledProjectile.Direction = dir;&#10;            _pooledProjectile.PlayerTransform = _returnToTransform;&#10;            _pooledProjectile.OnBoomerangReturned += OnBoomerangReturned;&#10;&#10;            _pooledBoomerang.SetActive(true);&#10;            _pooledProjectile.Fire();&#10;&#10;            _nextFireTime = Time.time + cooldownTime;&#10;        }&#10;&#10;        public void Reload()&#10;        {&#10;            SetAmmo(1);&#10;        }&#10;        public event Action&lt;int&gt; OnAmmoChanged;&#10;&#10;        private void OnBoomerangReturned()&#10;        {&#10;            _pooledProjectile.OnBoomerangReturned -= OnBoomerangReturned;&#10;            _pooledBoomerang.SetActive(false);&#10;            SetAmmo(1);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using Projectiles;&#10;using UnityEngine;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class BoomerangWeapon : MonoBehaviour, IAmmoWeapon&#10;    {&#10;        [SerializeField] private WeaponType weaponType = WeaponType.Boomerang;&#10;        public WeaponType WeaponType =&gt; weaponType;        &#10;        [SerializeField] private GameObject boomerang;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.3f;&#10;&#10;        private float _nextFireTime;&#10;&#10;        private GameObject _pooledBoomerang;&#10;        private ProjectileBoomerang _pooledProjectile;&#10;        private Transform _returnToTransform;&#10;&#10;        private void Start()&#10;        {&#10;            _returnToTransform = transform.parent;&#10;&#10;            if (!boomerang)&#10;                return;&#10;&#10;            Transform spawnParent = spawnPoint ? spawnPoint : transform;&#10;            _pooledBoomerang = Instantiate(boomerang, spawnParent.position, Quaternion.identity, spawnParent);&#10;            _pooledProjectile = _pooledBoomerang.GetComponent&lt;ProjectileBoomerang&gt;();&#10;            _pooledProjectile.WeaponType = WeaponType;&#10;            &#10;            _pooledBoomerang.SetActive(false);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (_pooledProjectile)&#10;                _pooledProjectile.OnBoomerangReturned -= OnBoomerangReturned;&#10;&#10;            if (_pooledBoomerang)&#10;                Destroy(_pooledBoomerang);&#10;        }&#10;&#10;        public int CurrentAmmo { get; private set; } = 1;&#10;        public int MaxAmmo =&gt; 1;&#10;        public bool HasAmmo =&gt; CurrentAmmo &gt; 0;&#10;&#10;        public void SetAmmo(int ammo)&#10;        {&#10;            int old = CurrentAmmo;&#10;            CurrentAmmo = Mathf.Clamp(ammo, 0, MaxAmmo);&#10;            if (old != CurrentAmmo)&#10;                OnAmmoChanged?.Invoke(CurrentAmmo);&#10;        }&#10;&#10;        public void Shoot()&#10;        {&#10;            if (Time.time &lt; _nextFireTime || !HasAmmo || !_pooledBoomerang || _pooledBoomerang.activeSelf)&#10;                return;&#10;&#10;            _pooledBoomerang.transform.SetPositionAndRotation(&#10;                spawnPoint ? spawnPoint.position : transform.position,&#10;                Quaternion.identity&#10;            );&#10;&#10;            _pooledBoomerang.layer = gameObject.layer;&#10;            SetAmmo(0);&#10;&#10;            float dir = transform.parent?.localScale.x ?? 1;&#10;            _pooledProjectile.Direction = dir;&#10;            _pooledProjectile.PlayerTransform = _returnToTransform;&#10;            _pooledProjectile.OnBoomerangReturned += OnBoomerangReturned;&#10;&#10;            _pooledBoomerang.SetActive(true);&#10;            _pooledProjectile.Fire();&#10;&#10;            _nextFireTime = Time.time + cooldownTime;&#10;        }&#10;&#10;        public void Reload()&#10;        {&#10;            SetAmmo(1);&#10;        }&#10;        public event Action&lt;int&gt; OnAmmoChanged;&#10;&#10;        private void OnBoomerangReturned()&#10;        {&#10;            _pooledProjectile.OnBoomerangReturned -= OnBoomerangReturned;&#10;            _pooledBoomerang.SetActive(false);&#10;            SetAmmo(1);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/FireballWeapon.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Weapons/Models/FireballWeapon.cs" />
              <option name="originalContent" value="using Pooling;&#10;using Projectiles;&#10;using UnityEngine;&#10;using VContainer;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class FireballWeapon : MonoBehaviour, IUseableWeapon&#10;    {&#10;        [SerializeField] private WeaponType weaponType = WeaponType.Fireball;&#10;        public WeaponType WeaponType =&gt; weaponType;&#10;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.3f;&#10;&#10;        private float _nextFireTime;&#10;&#10;        private bool IsEquipped { get; set; }&#10;&#10;        [Inject] private IPoolService _poolService;&#10;        [SerializeField] private GameObject fireballPrefab;&#10;&#10;        public void Shoot()&#10;        {&#10;            if (!IsEquipped)&#10;                return;&#10;&#10;            if (Time.time &lt; _nextFireTime)&#10;                return;&#10;&#10;            GameObject curFireball = _poolService.Get(fireballPrefab, spawnPoint ? spawnPoint.position : transform.position, Quaternion.identity);&#10;&#10;            if (curFireball.TryGetComponent(out ProjectileFireball scFireball))&#10;            {&#10;                curFireball.layer = gameObject.layer;&#10;                scFireball.Direction = transform.parent?.localScale.x ?? 1;&#10;                scFireball.WeaponType = weaponType;&#10;                scFireball.Fire();&#10;&#10;                // Set cooldown&#10;                _nextFireTime = Time.time + cooldownTime;&#10;            }&#10;        }&#10;&#10;        public void Equip()&#10;        {&#10;            IsEquipped = true;&#10;        }&#10;&#10;        public void UnEquip()&#10;        {&#10;            IsEquipped = false;&#10;        }&#10;&#10;        public void Release(GameObject instance)&#10;        {&#10;            _poolService.Release(fireballPrefab, instance);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Pooling;&#10;using Projectiles;&#10;using UnityEngine;&#10;using VContainer;&#10;using Weapons.Interfaces;&#10;&#10;namespace Weapons.Models&#10;{&#10;    public class FireballWeapon : MonoBehaviour, IUseableWeapon&#10;    {&#10;        [SerializeField] private WeaponType weaponType = WeaponType.Fireball;&#10;        public WeaponType WeaponType =&gt; weaponType;&#10;&#10;        [SerializeField] private Transform spawnPoint;&#10;        [SerializeField] private float cooldownTime = 0.3f;&#10;&#10;        private float _nextFireTime;&#10;&#10;        private bool IsEquipped { get; set; }&#10;&#10;        [Inject] private IPoolService _poolService;&#10;        [SerializeField] private GameObject fireballPrefab;&#10;&#10;        public void Shoot()&#10;        {&#10;            if (!IsEquipped)&#10;                return;&#10;&#10;            if (Time.time &lt; _nextFireTime)&#10;                return;&#10;&#10;            GameObject curFireball = _poolService.Get(fireballPrefab, spawnPoint ? spawnPoint.position : transform.position, Quaternion.identity);&#10;&#10;            if (curFireball.TryGetComponent(out ProjectileFireball scFireball))&#10;            {&#10;                curFireball.layer = gameObject.layer;&#10;                scFireball.Direction = transform.parent?.localScale.x ?? 1;&#10;                scFireball.WeaponType = weaponType;&#10;                scFireball.Fire();&#10;&#10;                // Set cooldown&#10;                _nextFireTime = Time.time + cooldownTime;&#10;            }&#10;        }&#10;&#10;        public void Equip()&#10;        {&#10;            IsEquipped = true;&#10;        }&#10;&#10;        public void UnEquip()&#10;        {&#10;            IsEquipped = false;&#10;        }&#10;&#10;        public void Release(GameObject instance)&#10;        {&#10;            _poolService.Release(fireballPrefab, instance);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>