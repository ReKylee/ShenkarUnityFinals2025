<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Editor/PrefabAuditorWindow.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Editor/PrefabAuditorWindow.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.IO;&#10;using System.Linq;&#10;using PowerUps.Container;&#10;using UnityEditor;&#10;using UnityEngine;&#10;&#10;namespace Editor&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Enhanced Prefab Auditor Window with optimized performance and improved functionality&#10;    /// &lt;/summary&gt;&#10;    public class PrefabAuditorWindow : EditorWindow&#10;    {&#10;&#10;        #region Enums&#10;&#10;        public enum FilterType&#10;        {&#10;            All,&#10;            Enemies,&#10;            Containers,&#10;            Others&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Utility Methods&#10;&#10;        private static string FormatFileSize(long bytes)&#10;        {&#10;            string[] sizes = { &quot;B&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot; };&#10;            double len = bytes;&#10;            int order = 0;&#10;            while (len &gt;= 1024 &amp;&amp; order &lt; sizes.Length - 1)&#10;            {&#10;                order++;&#10;                len = len / 1024;&#10;            }&#10;&#10;            return $&quot;{len:0.##} {sizes[order]}&quot;;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Serialized Settings&#10;&#10;        [Serializable]&#10;        public class WindowSettings&#10;        {&#10;            public string searchFilter = &quot;&quot;;&#10;            public FilterType filterType = FilterType.All;&#10;            public bool useGridView = true;&#10;            public bool autoRefresh = true;&#10;            public bool showAdvancedSettings;&#10;            public float pixelsPerUnit = 16f;&#10;            public int gridColumns = 4;&#10;            public bool enablePreviewCache = true;&#10;            public bool enableVirtualization = true;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Helper Classes&#10;&#10;        [Serializable]&#10;        public class PrefabInfo&#10;        {&#10;            public GameObject prefab;&#10;            public string name;&#10;            public string path;&#10;            public string guid;&#10;            public FilterType category;&#10;            public bool isValid;&#10;            public long fileSize;&#10;            public DateTime lastModified;&#10;&#10;            public PrefabInfo(GameObject prefab)&#10;            {&#10;                this.prefab = prefab;&#10;                name = prefab.name;&#10;                path = AssetDatabase.GetAssetPath(prefab);&#10;                guid = AssetDatabase.AssetPathToGUID(path);&#10;                category = DetermineCategory(prefab);&#10;                isValid = prefab != null;&#10;&#10;                if (File.Exists(path))&#10;                {&#10;                    FileInfo fileInfo = new(path);&#10;                    fileSize = fileInfo.Length;&#10;                    lastModified = fileInfo.LastWriteTime;&#10;                }&#10;            }&#10;&#10;            private static FilterType DetermineCategory(GameObject prefab)&#10;            {&#10;                if ((1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0)&#10;                    return FilterType.Enemies;&#10;&#10;                if (prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp;&#10;                    prefab.GetComponent&lt;PowerUpContainer&gt;() != null)&#10;                    return FilterType.Containers;&#10;&#10;                return FilterType.Others;&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Constants&#10;&#10;        private const int MaxFrequentPrefabs = 8;&#10;        private const float RadialMenuRadius = 100f;&#10;        private const float RadialMenuAnimationTime = 0.3f;&#10;        private const float PreviewSize = 64f;&#10;        private const string PrefabFolderPath = &quot;Assets/Prefabs&quot;;&#10;        private const string UsageDataKey = &quot;PrefabAuditor_UsageData_v2&quot;;&#10;        private const string SettingsKey = &quot;PrefabAuditor_Settings_v2&quot;;&#10;&#10;        #endregion&#10;&#10;        #region Private Fields&#10;&#10;        // Core Data&#10;        private readonly List&lt;PrefabInfo&gt; _prefabInfos = new();&#10;        private readonly List&lt;PrefabInfo&gt; _filteredPrefabs = new();&#10;        private readonly List&lt;GameObject&gt; _frequentPrefabs = new();&#10;        private readonly Dictionary&lt;GameObject, int&gt; _prefabUsageCount = new();&#10;&#10;        // Preview System&#10;        private readonly Dictionary&lt;GameObject, Texture2D&gt; _previewCache = new();&#10;        private readonly Queue&lt;GameObject&gt; _previewLoadQueue = new();&#10;        private bool _isLoadingPreviews;&#10;&#10;        // UI State&#10;        private WindowSettings _settings = new();&#10;        private Vector2 _scrollPosition;&#10;        private string _lastSearchFilter = &quot;&quot;;&#10;        private FilterType _lastFilterType = FilterType.All;&#10;&#10;        // Placement System&#10;        private bool _placementMode;&#10;        private GameObject _selectedPrefabForPlacement;&#10;        private GameObject _defaultDropPrefab;&#10;&#10;        // Radial Menu System&#10;        private bool _showRadialMenu;&#10;        private Vector2 _radialMenuPosition;&#10;        private float _radialMenuOpenTime;&#10;        private int _hoveredRadialIndex = -1;&#10;&#10;        // Performance Tracking&#10;        private double _lastRepaintTime;&#10;        private int _virtualizedStartIndex;&#10;        private int _virtualizedEndIndex;&#10;&#10;        // Styles (cached)&#10;        private static GUIStyle _headerStyle;&#10;        private static GUIStyle _cardStyle;&#10;        private static GUIStyle _buttonStyle;&#10;        private static readonly int Color1 = Shader.PropertyToID(&quot;_Color&quot;);&#10;        private static readonly int BaseColor = Shader.PropertyToID(&quot;_BaseColor&quot;);&#10;        private static readonly int MainTex = Shader.PropertyToID(&quot;_MainTex&quot;);&#10;&#10;        #endregion&#10;&#10;        #region Unity Lifecycle&#10;&#10;        [MenuItem(&quot;Tools/Enhanced Prefab Manager&quot;)]&#10;        public static void ShowWindow()&#10;        {&#10;            PrefabAuditorWindow window = GetWindow&lt;PrefabAuditorWindow&gt;(&quot;Prefab Manager&quot;);&#10;            window.minSize = new Vector2(600, 700);&#10;            window.maxSize = new Vector2(2000, 2000);&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            LoadSettings();&#10;            LoadPrefabs();&#10;            LoadUsageData();&#10;            UpdateFrequentPrefabs();&#10;&#10;            SceneView.duringSceneGui += OnSceneGUI;&#10;            EditorApplication.update += OnEditorUpdate;&#10;            EditorApplication.projectChanged += OnProjectChanged;&#10;&#10;            // Start preview loading&#10;            EditorApplication.delayCall += StartPreviewLoading;&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            SaveSettings();&#10;            SaveUsageData();&#10;&#10;            SceneView.duringSceneGui -= OnSceneGUI;&#10;            EditorApplication.update -= OnEditorUpdate;&#10;            EditorApplication.projectChanged -= OnProjectChanged;&#10;&#10;            ClearPreviews();&#10;        }&#10;&#10;        private void OnProjectChanged()&#10;        {&#10;            if (_settings.autoRefresh)&#10;            {&#10;                EditorApplication.delayCall += LoadPrefabs;&#10;            }&#10;        }&#10;&#10;        private void OnEditorUpdate()&#10;        {&#10;            double currentTime = EditorApplication.timeSinceStartup;&#10;&#10;            // Limit repaints for performance&#10;            if (_showRadialMenu &amp;&amp; currentTime - _lastRepaintTime &gt; 0.016f) // ~60fps&#10;            {&#10;                SceneView.lastActiveSceneView?.Repaint();&#10;                _lastRepaintTime = currentTime;&#10;            }&#10;&#10;            // Process preview loading queue&#10;            ProcessPreviewQueue();&#10;&#10;            // Auto-refresh check&#10;            if (_settings.autoRefresh &amp;&amp;&#10;                (_lastSearchFilter != _settings.searchFilter || _lastFilterType != _settings.filterType))&#10;            {&#10;                ApplyFilters();&#10;                _lastSearchFilter = _settings.searchFilter;&#10;                _lastFilterType = _settings.filterType;&#10;            }&#10;        }&#10;&#10;        private void OnGUI()&#10;        {&#10;            InitializeStyles();&#10;&#10;            using (new EditorGUILayout.VerticalScope())&#10;            {&#10;                DrawHeader();&#10;                DrawFiltersAndSearch();&#10;                DrawQuickSettings();&#10;                DrawPrefabsList();&#10;                DrawFooter();&#10;            }&#10;&#10;            HandleKeyboardShortcuts();&#10;        }&#10;&#10;        private void OnSceneGUI(SceneView sceneView)&#10;        {&#10;            Event currentEvent = Event.current;&#10;&#10;            // Handle radial menu first (higher priority)&#10;            if (HandleRadialMenu(currentEvent, sceneView))&#10;                return;&#10;&#10;            // Handle placement mode&#10;            HandlePlacementMode(currentEvent, sceneView);&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region UI Drawing&#10;&#10;        private void InitializeStyles()&#10;        {&#10;            if (_headerStyle != null) return;&#10;&#10;            _headerStyle = new GUIStyle(EditorStyles.boldLabel)&#10;            {&#10;                fontSize = 16,&#10;                alignment = TextAnchor.MiddleLeft,&#10;                normal = { textColor = EditorGUIUtility.isProSkin ? Color.white : Color.black }&#10;            };&#10;&#10;            _cardStyle = new GUIStyle(GUI.skin.box)&#10;            {&#10;                padding = new RectOffset(12, 12, 8, 8),&#10;                margin = new RectOffset(4, 4, 2, 2)&#10;            };&#10;&#10;            _buttonStyle = new GUIStyle(GUI.skin.button)&#10;            {&#10;                padding = new RectOffset(8, 8, 4, 4)&#10;            };&#10;&#10;&#10;        }&#10;&#10;        private void DrawHeader()&#10;        {&#10;            using (new EditorGUILayout.VerticalScope(_cardStyle))&#10;            {&#10;                EditorGUILayout.LabelField(&quot; Enhanced Prefab Manager&quot;, _headerStyle);&#10;                EditorGUILayout.LabelField(&#10;                    $&quot;Found {_prefabInfos.Count} prefabs | Showing {_filteredPrefabs.Count} | Cache: {_previewCache.Count}&quot;,&#10;                    EditorStyles.miniLabel);&#10;&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    if (GUILayout.Button(&quot; Refresh&quot;, _buttonStyle, GUILayout.Width(80)))&#10;                    {&#10;                        LoadPrefabs();&#10;                    }&#10;&#10;                    _settings.autoRefresh =&#10;                        GUILayout.Toggle(_settings.autoRefresh, &quot;Auto Refresh&quot;, GUILayout.Width(100));&#10;&#10;                    GUILayout.FlexibleSpace();&#10;&#10;                    if (_placementMode &amp;&amp; GUILayout.Button(&quot;❌ Exit Placement&quot;, _buttonStyle, GUILayout.Width(120)))&#10;                    {&#10;                        ExitPlacementMode();&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawFiltersAndSearch()&#10;        {&#10;            using (new EditorGUILayout.VerticalScope(_cardStyle))&#10;            {&#10;                EditorGUILayout.LabelField(&quot; Filters &amp; Search&quot;, EditorStyles.boldLabel);&#10;&#10;                // Search with clear button&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    EditorGUILayout.LabelField(&quot;Search:&quot;, GUILayout.Width(50));&#10;                    _settings.searchFilter = EditorGUILayout.TextField(_settings.searchFilter);&#10;                    if (GUILayout.Button(&quot;✕&quot;, GUILayout.Width(20)))&#10;                    {&#10;                        _settings.searchFilter = &quot;&quot;;&#10;                        ApplyFilters();&#10;                    }&#10;                }&#10;&#10;                // Filter and view options&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    EditorGUILayout.LabelField(&quot;Filter:&quot;, GUILayout.Width(50));&#10;                    FilterType newFilter = (FilterType)EditorGUILayout.EnumPopup(_settings.filterType);&#10;                    if (newFilter != _settings.filterType)&#10;                    {&#10;                        _settings.filterType = newFilter;&#10;                        ApplyFilters();&#10;                    }&#10;&#10;                    GUILayout.FlexibleSpace();&#10;&#10;                    EditorGUILayout.LabelField(&quot;View:&quot;, GUILayout.Width(40));&#10;                    _settings.useGridView =&#10;                        GUILayout.Toggle(_settings.useGridView, &quot;Grid&quot;, &quot;Button&quot;, GUILayout.Width(50));&#10;&#10;                    _settings.useGridView =&#10;                        !GUILayout.Toggle(!_settings.useGridView, &quot;List&quot;, &quot;Button&quot;, GUILayout.Width(50));&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawQuickSettings()&#10;        {&#10;            using (new EditorGUILayout.VerticalScope(_cardStyle))&#10;            {&#10;                _settings.showAdvancedSettings = EditorGUILayout.Foldout(_settings.showAdvancedSettings, &quot;⚙️ Settings&quot;,&#10;                    true, EditorStyles.foldout);&#10;&#10;                if (_settings.showAdvancedSettings)&#10;                {&#10;                    using (new EditorGUILayout.HorizontalScope())&#10;                    {&#10;                        EditorGUILayout.LabelField(&quot;Grid Snap (PPU):&quot;, GUILayout.Width(100));&#10;                        _settings.pixelsPerUnit =&#10;                            EditorGUILayout.FloatField(_settings.pixelsPerUnit, GUILayout.Width(60));&#10;&#10;                        GUILayout.Space(10);&#10;&#10;                        EditorGUILayout.LabelField(&quot;Grid Columns:&quot;, GUILayout.Width(85));&#10;                        _settings.gridColumns =&#10;                            EditorGUILayout.IntSlider(_settings.gridColumns, 2, 8, GUILayout.Width(100));&#10;                    }&#10;&#10;                    using (new EditorGUILayout.HorizontalScope())&#10;                    {&#10;                        EditorGUILayout.LabelField(&quot;Default Drop:&quot;, GUILayout.Width(80));&#10;                        _defaultDropPrefab =&#10;                            (GameObject)EditorGUILayout.ObjectField(_defaultDropPrefab, typeof(GameObject), false);&#10;&#10;                        GUILayout.Space(10);&#10;&#10;                        _settings.enablePreviewCache = GUILayout.Toggle(_settings.enablePreviewCache, &quot;Preview Cache&quot;);&#10;                        _settings.enableVirtualization =&#10;                            GUILayout.Toggle(_settings.enableVirtualization, &quot;Virtualization&quot;);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawPrefabsList()&#10;        {&#10;            using (new EditorGUILayout.VerticalScope(_cardStyle))&#10;            {&#10;                EditorGUILayout.LabelField(&quot; Prefabs&quot;, EditorStyles.boldLabel);&#10;&#10;                if (_filteredPrefabs.Count == 0)&#10;                {&#10;                    EditorGUILayout.HelpBox(&quot;No prefabs match current filters.&quot;, MessageType.Info);&#10;                    return;&#10;                }&#10;&#10;                CalculateVirtualization();&#10;&#10;                using (EditorGUILayout.ScrollViewScope scrollScope = new(_scrollPosition, GUILayout.ExpandHeight(true)))&#10;                {&#10;                    _scrollPosition = scrollScope.scrollPosition;&#10;&#10;                    if (_settings.useGridView)&#10;                    {&#10;                        DrawPrefabsGrid();&#10;                    }&#10;                    else&#10;                    {&#10;                        DrawPrefabsListItems();&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawPrefabsListItems()&#10;        {&#10;            var visiblePrefabs = GetVisiblePrefabs();&#10;&#10;            foreach (PrefabInfo prefabInfo in visiblePrefabs)&#10;            {&#10;                if (prefabInfo?.prefab == null) continue;&#10;                DrawPrefabListItem(prefabInfo);&#10;            }&#10;        }&#10;&#10;        private void DrawPrefabListItem(PrefabInfo prefabInfo)&#10;        {&#10;            using (new EditorGUILayout.VerticalScope(_cardStyle))&#10;            {&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    // Preview&#10;                    Texture2D preview = GetPrefabPreview(prefabInfo.prefab);&#10;                    if (preview != null)&#10;                    {&#10;                        GUILayout.Label(preview, GUILayout.Width(PreviewSize), GUILayout.Height(PreviewSize));&#10;                    }&#10;                    else&#10;                    {&#10;                        GUILayout.Box(&quot;Loading...&quot;, GUILayout.Width(PreviewSize), GUILayout.Height(PreviewSize));&#10;                    }&#10;&#10;                    // Info&#10;                    using (new EditorGUILayout.VerticalScope())&#10;                    {&#10;                        EditorGUILayout.LabelField(prefabInfo.name, EditorStyles.boldLabel);&#10;                        EditorGUILayout.LabelField($&quot;Category: {prefabInfo.category}&quot;, EditorStyles.miniLabel);&#10;&#10;                        if (_settings.showAdvancedSettings)&#10;                        {&#10;                            EditorGUILayout.LabelField($&quot;Size: {FormatFileSize(prefabInfo.fileSize)}&quot;,&#10;                                EditorStyles.miniLabel);&#10;                        }&#10;                    }&#10;&#10;                    GUILayout.FlexibleSpace();&#10;&#10;                    // Actions&#10;                    using (new EditorGUILayout.VerticalScope(GUILayout.Width(180)))&#10;                    {&#10;                        using (new EditorGUILayout.HorizontalScope())&#10;                        {&#10;                            if (GUILayout.Button(&quot;️ Place&quot;, _buttonStyle)) StartPlacementMode(prefabInfo.prefab);&#10;                            if (GUILayout.Button(&quot; Instant&quot;, _buttonStyle))&#10;                                PlacePrefabAtPosition(prefabInfo.prefab, Vector3.zero);&#10;                        }&#10;&#10;                        using (new EditorGUILayout.HorizontalScope())&#10;                        {&#10;                            if (GUILayout.Button(&quot; Select&quot;, _buttonStyle)) Selection.activeObject = prefabInfo.prefab;&#10;                            if (GUILayout.Button(&quot; Show&quot;, _buttonStyle))&#10;                                EditorGUIUtility.PingObject(prefabInfo.prefab);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawPrefabsGrid()&#10;        {&#10;            var visiblePrefabs = GetVisiblePrefabs();&#10;            int columns = _settings.gridColumns;&#10;            int rows = Mathf.CeilToInt((float)visiblePrefabs.Count / columns);&#10;&#10;            for (int row = 0; row &lt; rows; row++)&#10;            {&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    for (int col = 0; col &lt; columns; col++)&#10;                    {&#10;                        int index = row * columns + col;&#10;                        if (index &gt;= visiblePrefabs.Count)&#10;                        {&#10;                            GUILayout.FlexibleSpace();&#10;                            continue;&#10;                        }&#10;&#10;                        PrefabInfo prefabInfo = visiblePrefabs[index];&#10;                        if (prefabInfo?.prefab != null)&#10;                        {&#10;                            DrawPrefabGridItem(prefabInfo);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawPrefabGridItem(PrefabInfo prefabInfo)&#10;        {&#10;            float cellWidth = (position.width - 60) / _settings.gridColumns;&#10;&#10;            using (new EditorGUILayout.VerticalScope(GUILayout.Width(cellWidth), GUILayout.Height(140)))&#10;            {&#10;                // Preview&#10;                Texture2D preview = GetPrefabPreview(prefabInfo.prefab);&#10;                Rect rect = GUILayoutUtility.GetRect(cellWidth - 20, 80, GUILayout.ExpandWidth(false));&#10;&#10;                if (preview != null)&#10;                {&#10;                    GUI.DrawTexture(rect, preview, ScaleMode.ScaleToFit);&#10;                }&#10;                else&#10;                {&#10;                    EditorGUI.DrawRect(rect, Color.gray * 0.3f);&#10;                    GUI.Label(rect, &quot;Loading...&quot;, EditorStyles.centeredGreyMiniLabel);&#10;                }&#10;&#10;                // Name and actions&#10;                EditorGUILayout.LabelField(prefabInfo.name, EditorStyles.miniLabel, GUILayout.Width(cellWidth - 10));&#10;&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    if (GUILayout.Button(&quot;Place&quot;, GUILayout.Height(25)))&#10;                    {&#10;                        StartPlacementMode(prefabInfo.prefab);&#10;                    }&#10;&#10;                    if (GUILayout.Button(&quot;&quot;, GUILayout.Width(25), GUILayout.Height(25)))&#10;                    {&#10;                        EditorGUIUtility.PingObject(prefabInfo.prefab);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawFooter()&#10;        {&#10;            using (new EditorGUILayout.HorizontalScope())&#10;            {&#10;                if (GUILayout.Button(&quot;↶ Undo&quot;, _buttonStyle, GUILayout.Width(80)))&#10;                    Undo.PerformUndo();&#10;&#10;                if (GUILayout.Button(&quot;↷ Redo&quot;, _buttonStyle, GUILayout.Width(80)))&#10;                    Undo.PerformRedo();&#10;&#10;                GUILayout.FlexibleSpace();&#10;&#10;                EditorGUILayout.LabelField($&quot;Preview Queue: {_previewLoadQueue.Count}&quot;, EditorStyles.miniLabel);&#10;&#10;                if (GUILayout.Button(&quot;️ Clear Cache&quot;, _buttonStyle, GUILayout.Width(100)))&#10;                {&#10;                    ClearPreviews();&#10;                }&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Performance Optimizations&#10;&#10;        private void CalculateVirtualization()&#10;        {&#10;            if (!_settings.enableVirtualization)&#10;            {&#10;                _virtualizedStartIndex = 0;&#10;                _virtualizedEndIndex = _filteredPrefabs.Count;&#10;                return;&#10;            }&#10;&#10;            float itemHeight = _settings.useGridView ? 140f : 80f;&#10;            float visibleHeight = position.height - 200f; // Account for UI elements&#10;            float scrollOffset = _scrollPosition.y;&#10;&#10;            int visibleStart = Mathf.Max(0, Mathf.FloorToInt(scrollOffset / itemHeight) - 5);&#10;            int visibleCount = Mathf.CeilToInt(visibleHeight / itemHeight) + 10;&#10;&#10;            _virtualizedStartIndex = visibleStart;&#10;            _virtualizedEndIndex = Mathf.Min(_filteredPrefabs.Count, visibleStart + visibleCount);&#10;        }&#10;&#10;        private List&lt;PrefabInfo&gt; GetVisiblePrefabs()&#10;        {&#10;            if (!_settings.enableVirtualization)&#10;                return _filteredPrefabs;&#10;&#10;            return _filteredPrefabs.GetRange(_virtualizedStartIndex, _virtualizedEndIndex - _virtualizedStartIndex);&#10;        }&#10;&#10;        private void ProcessPreviewQueue()&#10;        {&#10;            if (!_settings.enablePreviewCache || _isLoadingPreviews || _previewLoadQueue.Count == 0)&#10;                return;&#10;&#10;            _isLoadingPreviews = true;&#10;&#10;            // Process a few previews per frame&#10;            for (int i = 0; i &lt; 3 &amp;&amp; _previewLoadQueue.Count &gt; 0; i++)&#10;            {&#10;                GameObject prefab = _previewLoadQueue.Dequeue();&#10;                if (prefab != null &amp;&amp; !_previewCache.ContainsKey(prefab))&#10;                {&#10;                    Texture2D preview = AssetPreview.GetAssetPreview(prefab);&#10;                    if (preview != null)&#10;                    {&#10;                        _previewCache[prefab] = preview;&#10;                    }&#10;                    else&#10;                    {&#10;                        // Re-queue if preview not ready&#10;                        _previewLoadQueue.Enqueue(prefab);&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;&#10;            _isLoadingPreviews = false;&#10;&#10;            // Repaint if we processed any previews&#10;            if (_previewLoadQueue.Count % 10 == 0)&#10;            {&#10;                Repaint();&#10;            }&#10;        }&#10;&#10;        private void StartPreviewLoading()&#10;        {&#10;            if (!_settings.enablePreviewCache) return;&#10;&#10;            _previewLoadQueue.Clear();&#10;            foreach (PrefabInfo prefabInfo in _prefabInfos.Where(prefabInfo =&gt; prefabInfo.prefab &amp;&amp; !_previewCache.ContainsKey(prefabInfo.prefab)))&#10;            {&#10;                _previewLoadQueue.Enqueue(prefabInfo.prefab);&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Scene GUI Handling&#10;&#10;        private bool HandleRadialMenu(Event currentEvent, SceneView sceneView)&#10;        {&#10;            if (currentEvent.type == EventType.MouseDown &amp;&amp; currentEvent.button == 1)&#10;            {&#10;                _showRadialMenu = true;&#10;                _radialMenuPosition = currentEvent.mousePosition;&#10;                _radialMenuOpenTime = (float)EditorApplication.timeSinceStartup;&#10;                _hoveredRadialIndex = -1;&#10;                currentEvent.Use();&#10;                return true;&#10;            }&#10;&#10;            if (!_showRadialMenu) return false;&#10;&#10;            // Always update hover state when mouse is moving or during repaint&#10;            if (currentEvent.type is EventType.MouseMove or EventType.Repaint)&#10;            {&#10;                int newHoveredIndex = GetRadialMenuIndex(currentEvent.mousePosition);&#10;                if (newHoveredIndex != _hoveredRadialIndex)&#10;                {&#10;                    _hoveredRadialIndex = newHoveredIndex;&#10;                    sceneView.Repaint();&#10;                }&#10;            }&#10;&#10;            DrawRadialMenu();&#10;&#10;            if (currentEvent.type == EventType.MouseUp &amp;&amp; currentEvent.button == 1)&#10;            {&#10;                GameObject selectedPrefab = GetPrefabFromRadialMenu(currentEvent.mousePosition);&#10;                if (selectedPrefab != null)&#10;                {&#10;                    StartPlacementMode(selectedPrefab);&#10;                }&#10;&#10;                _showRadialMenu = false;&#10;                _hoveredRadialIndex = -1;&#10;                currentEvent.Use();&#10;                return true;&#10;            }&#10;&#10;            if (currentEvent.type == EventType.KeyDown &amp;&amp; currentEvent.keyCode == KeyCode.Escape)&#10;            {&#10;                _showRadialMenu = false;&#10;                _hoveredRadialIndex = -1;&#10;                currentEvent.Use();&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        private void HandlePlacementMode(Event currentEvent, SceneView sceneView)&#10;        {&#10;            if (!_placementMode || _selectedPrefabForPlacement == null) return;&#10;&#10;            int controlId = GUIUtility.GetControlID(FocusType.Passive);&#10;            HandleUtility.AddDefaultControl(controlId);&#10;&#10;            Vector3 worldPos = GetMouseWorldPosition(currentEvent);&#10;&#10;            if (currentEvent.shift &amp;&amp; _settings.pixelsPerUnit &gt; 0)&#10;            {&#10;                worldPos = SnapToGrid(worldPos);&#10;            }&#10;&#10;            if (currentEvent.type == EventType.MouseMove || currentEvent.type == EventType.Repaint)&#10;            {&#10;                DrawPlacementPreview(currentEvent.mousePosition, worldPos);&#10;                sceneView.Repaint();&#10;            }&#10;            else if (currentEvent.type == EventType.MouseDown &amp;&amp; currentEvent.button == 0)&#10;            {&#10;                PlacePrefabAtPosition(_selectedPrefabForPlacement, worldPos);&#10;                currentEvent.Use();&#10;            }&#10;            else if (currentEvent.type == EventType.KeyDown &amp;&amp; currentEvent.keyCode == KeyCode.Escape)&#10;            {&#10;                ExitPlacementMode();&#10;                currentEvent.Use();&#10;            }&#10;        }&#10;&#10;        private void DrawPlacementPreview(Vector2 mousePos, Vector3 worldPos)&#10;        {&#10;            // Get prefab bounds for accurate sizing&#10;            Bounds prefabBounds = GetPrefabBounds(_selectedPrefabForPlacement);&#10;            Vector3 worldSize = prefabBounds.size;&#10;            Vector3 pivotOffset = GetPrefabPivotOffset(_selectedPrefabForPlacement, prefabBounds);&#10;&#10;            // If bounds are too small or invalid, use default size&#10;            if (worldSize.magnitude &lt; 0.1f)&#10;            {&#10;                worldSize = Vector3.one * 0.5f;&#10;                pivotOffset = Vector3.zero;&#10;            }&#10;&#10;            // Scale the world size to compensate for asset preview padding BEFORE any calculations&#10;            // Unity's asset previews have internal padding, so we scale up the world size to compensate&#10;            worldSize *= 1.2f; // Scale up by 20% to account for internal padding&#10;&#10;            // Apply grid snapping to the preview position if enabled&#10;            Vector3 previewWorldPos = worldPos;&#10;            if (Event.current.shift &amp;&amp; _settings.pixelsPerUnit &gt; 0)&#10;            {&#10;                previewWorldPos = SnapToGrid(worldPos);&#10;            }&#10;&#10;            // Convert the snapped world position back to screen coordinates for the preview&#10;            Vector2 previewScreenPos = mousePos;&#10;            Camera sceneCamera = SceneView.lastActiveSceneView?.camera;&#10;            if (sceneCamera != null)&#10;            {&#10;                // Account for pivot offset when converting to screen coordinates&#10;                Vector3 pivotWorldPos = previewWorldPos + pivotOffset;&#10;                Vector3 screenPoint = sceneCamera.WorldToScreenPoint(pivotWorldPos);&#10;                // Convert Unity screen coordinates to GUI coordinates&#10;                previewScreenPos = new Vector2(screenPoint.x,&#10;                    SceneView.lastActiveSceneView.position.height - screenPoint.y);&#10;            }&#10;&#10;            // Calculate accurate GUI preview size based on actual world size and camera&#10;            float screenSize = 80f; // Base size in pixels&#10;&#10;            if (sceneCamera != null)&#10;            {&#10;                if (sceneCamera.orthographic)&#10;                {&#10;                    // For orthographic camera, calculate screen size directly&#10;                    float orthographicSize = sceneCamera.orthographicSize;&#10;                    float screenHeight = SceneView.lastActiveSceneView.position.height;&#10;&#10;                    // Calculate pixels per world unit&#10;                    float pixelsPerWorldUnit = screenHeight / (orthographicSize * 2f);&#10;&#10;                    // Use the larger dimension of the sprite for accurate representation&#10;                    float largestWorldDimension = Mathf.Max(worldSize.x, worldSize.y, worldSize.z);&#10;                    screenSize = largestWorldDimension * pixelsPerWorldUnit;&#10;                }&#10;                else&#10;                {&#10;                    // For perspective camera, factor in distance&#10;                    float distance = Vector3.Distance(sceneCamera.transform.position, previewWorldPos);&#10;                    float fieldOfViewRad = sceneCamera.fieldOfView * Mathf.Deg2Rad;&#10;                    float screenHeight = SceneView.lastActiveSceneView.position.height;&#10;&#10;                    // Calculate how many world units fit in screen height at this distance&#10;                    float worldUnitsInScreenHeight = 2f * distance * Mathf.Tan(fieldOfViewRad * 0.5f);&#10;                    float pixelsPerWorldUnit = screenHeight / worldUnitsInScreenHeight;&#10;&#10;                    // Use the larger dimension of the sprite for accurate representation&#10;                    float largestWorldDimension = Mathf.Max(worldSize.x, worldSize.y, worldSize.z);&#10;                    screenSize = largestWorldDimension * pixelsPerWorldUnit;&#10;                }&#10;&#10;                // Clamp to reasonable bounds but allow larger sizes for bigger sprites&#10;                screenSize = Mathf.Clamp(screenSize, 20f, 400f);&#10;            }&#10;&#10;            // Get the prefab preview texture&#10;            Texture2D preview = GetPrefabPreview(_selectedPrefabForPlacement);&#10;&#10;            if (preview != null)&#10;            {&#10;                Handles.BeginGUI();&#10;&#10;                // Calculate preview rect centered on the snapped position with accurate size&#10;                Rect previewRect = new(&#10;                    previewScreenPos.x - screenSize * 0.5f,&#10;                    previewScreenPos.y - screenSize * 0.5f,&#10;                    screenSize,&#10;                    screenSize&#10;                );&#10;&#10;                // Draw the preview image with transparency support&#10;                Color originalColor = GUI.color;&#10;                GUI.color = new Color(1f, 1f, 1f, 1f); // Ensure full alpha for transparency&#10;                GUI.DrawTexture(previewRect, preview, ScaleMode.ScaleToFit, true); // Enable alpha blending&#10;                GUI.color = originalColor;&#10;&#10;                // Draw center crosshair for precise placement (use snapped position)&#10;                Vector2 center = previewScreenPos;&#10;                float crosshairSize = 6f;&#10;                Color crosshairColor = Color.red;&#10;                EditorGUI.DrawRect(new Rect(center.x - crosshairSize, center.y - 0.5f, crosshairSize * 2, 1),&#10;                    crosshairColor);&#10;&#10;                EditorGUI.DrawRect(new Rect(center.x - 0.5f, center.y - crosshairSize, 1, crosshairSize * 2),&#10;                    crosshairColor);&#10;&#10;                // Show prefab info below the preview&#10;                string infoText = _selectedPrefabForPlacement.name;&#10;                if (Event.current.shift &amp;&amp; _settings.pixelsPerUnit &gt; 0)&#10;                {&#10;                    infoText += &quot; (Grid Snap)&quot;;&#10;                }&#10;&#10;                // Add size info for debugging&#10;                infoText += $&quot; | Size: {worldSize.x:F1}x{worldSize.y:F1} | Screen: {screenSize:F0}px&quot;;&#10;&#10;                GUIContent infoContent = new(infoText);&#10;                Vector2 infoSize = EditorStyles.miniLabel.CalcSize(infoContent);&#10;                Rect infoRect = new(&#10;                    previewScreenPos.x - infoSize.x * 0.5f,&#10;                    previewRect.y + previewRect.height + 5,&#10;                    infoSize.x,&#10;                    infoSize.y&#10;                );&#10;&#10;                Color backgroundColor = new(0, 0, 0, 0.7f);&#10;                // Draw info background&#10;                EditorGUI.DrawRect(new Rect(infoRect.x - 2, infoRect.y - 1, infoRect.width + 4, infoRect.height + 2),&#10;                    backgroundColor);&#10;&#10;                // Draw info text&#10;                GUI.Label(infoRect, infoContent, EditorStyles.miniLabel);&#10;&#10;                Handles.EndGUI();&#10;            }&#10;&#10;            // Grid snap visualization (using the snapped world position)&#10;            if (Event.current.shift &amp;&amp; _settings.pixelsPerUnit &gt; 0)&#10;            {&#10;                Handles.color = Color.yellow;&#10;                float gridSize = 1.0f / _settings.pixelsPerUnit;&#10;&#10;                // Draw snap grid around cursor&#10;                for (int i = -1; i &lt;= 1; i++)&#10;                {&#10;                    for (int j = -1; j &lt;= 1; j++)&#10;                    {&#10;                        Vector3 gridPoint = previewWorldPos + new Vector3(i * gridSize, j * gridSize, 0);&#10;                        Handles.DrawWireCube(gridPoint, Vector3.one * gridSize * 0.2f);&#10;                    }&#10;                }&#10;            }&#10;&#10;            Handles.color = Color.white;&#10;        }&#10;&#10;        private Bounds GetPrefabBounds(GameObject prefab)&#10;        {&#10;            if (prefab == null) return new Bounds();&#10;&#10;            // Try to get bounds from renderers&#10;            var renderers = prefab.GetComponentsInChildren&lt;Renderer&gt;();&#10;            if (renderers != null &amp;&amp; renderers.Length &gt; 0)&#10;            {&#10;                Bounds bounds = renderers[0].bounds;&#10;                foreach (Renderer renderer in renderers)&#10;                {&#10;                    bounds.Encapsulate(renderer.bounds);&#10;                }&#10;&#10;                return bounds;&#10;            }&#10;&#10;            // Try to get bounds from colliders&#10;            var colliders = prefab.GetComponentsInChildren&lt;Collider&gt;();&#10;            if (colliders != null &amp;&amp; colliders.Length &gt; 0)&#10;            {&#10;                Bounds bounds = colliders[0].bounds;&#10;                foreach (Collider collider in colliders)&#10;                {&#10;                    bounds.Encapsulate(collider.bounds);&#10;                }&#10;&#10;                return bounds;&#10;            }&#10;&#10;            // Try to get bounds from colliders 2D&#10;            var colliders2D = prefab.GetComponentsInChildren&lt;Collider2D&gt;();&#10;            if (colliders2D is { Length: &gt; 0 })&#10;            {&#10;                Bounds bounds = colliders2D[0].bounds;&#10;                foreach (Collider2D collider in colliders2D)&#10;                {&#10;                    bounds.Encapsulate(collider.bounds);&#10;                }&#10;&#10;                return bounds;&#10;            }&#10;&#10;            // Fallback to transform bounds&#10;            return new Bounds(prefab.transform.position, Vector3.one);&#10;        }&#10;&#10;        private Vector3 GetPrefabPivotOffset(GameObject prefab, Bounds bounds)&#10;        {&#10;            if (prefab == null) return Vector3.zero;&#10;&#10;            // For 2D sprites, we need to consider the sprite's pivot settings&#10;            SpriteRenderer spriteRenderer = prefab.GetComponent&lt;SpriteRenderer&gt;();&#10;            if (spriteRenderer != null &amp;&amp; spriteRenderer.sprite != null)&#10;            {&#10;                Sprite sprite = spriteRenderer.sprite;&#10;&#10;                // Get the sprite's pivot in normalized coordinates (0-1)&#10;                Vector2 spritePivot = sprite.pivot;&#10;                Vector2 spriteSize = sprite.rect.size;&#10;                Vector2 normalizedPivot = new(spritePivot.x / spriteSize.x, spritePivot.y / spriteSize.y);&#10;&#10;                // Calculate the offset from center to pivot in world space&#10;                // This offset should move the preview so the pivot point is at the mouse cursor&#10;                Vector3 spriteOffset = new(&#10;                    (normalizedPivot.x - 0.5f) * bounds.size.x,&#10;                    (normalizedPivot.y - 0.5f) * bounds.size.y,&#10;                    0f&#10;                );&#10;&#10;                return spriteOffset;&#10;            }&#10;&#10;            // For non-sprite objects, calculate offset from bounds center to transform position&#10;            Vector3 pivotPosition = prefab.transform.position;&#10;            Vector3 pivotOffset = pivotPosition - bounds.center;&#10;            return pivotOffset;&#10;        }&#10;&#10;        private void DrawRadialMenu()&#10;        {&#10;            Handles.BeginGUI();&#10;&#10;            Vector2 center = _radialMenuPosition;&#10;            float elapsedTime = (float)EditorApplication.timeSinceStartup - _radialMenuOpenTime;&#10;            float growProgress = Mathf.Clamp01(elapsedTime / RadialMenuAnimationTime);&#10;            float radius = RadialMenuRadius * Mathf.SmoothStep(0, 1, growProgress);&#10;&#10;            // Background with gradient&#10;            Handles.color = new Color(0.1f, 0.1f, 0.1f, 0.9f);&#10;            Handles.DrawSolidDisc(center, Vector3.forward, radius);&#10;            Handles.color = new Color(0.3f, 0.3f, 0.3f, 0.8f);&#10;            Handles.DrawWireDisc(center, Vector3.forward, radius);&#10;            Handles.color = Color.white;&#10;&#10;            var prefabsToShow = _frequentPrefabs.Count &gt; 0&#10;                ? _frequentPrefabs&#10;                : _filteredPrefabs.Take(MaxFrequentPrefabs).Select(p =&gt; p.prefab).ToList();&#10;&#10;            int prefabCount = Mathf.Min(prefabsToShow.Count, MaxFrequentPrefabs);&#10;&#10;            for (int i = 0; i &lt; prefabCount; i++)&#10;            {&#10;                GameObject prefab = prefabsToShow[i];&#10;                if (prefab == null) continue;&#10;&#10;                float angle = i / (float)prefabCount * 360f - 90f;&#10;                Vector2 direction = new(Mathf.Cos(angle * Mathf.Deg2Rad), Mathf.Sin(angle * Mathf.Deg2Rad));&#10;                Vector2 itemPos = center + direction * (radius * 0.75f);&#10;&#10;                bool isHovered = i == _hoveredRadialIndex;&#10;                float iconSize = isHovered ? 55f : 45f;&#10;&#10;                // Enhanced highlighting for hovered item&#10;                if (isHovered)&#10;                {&#10;                    // Draw pulsing highlight background&#10;                    float pulseScale = 1f + Mathf.Sin((float)EditorApplication.timeSinceStartup * 8f) * 0.1f;&#10;                    Handles.color = new Color(0, 1, 1, 0.6f); // Cyan with transparency&#10;                    Handles.DrawSolidDisc(itemPos, Vector3.forward, iconSize * 0.7f * pulseScale);&#10;&#10;                    // Draw bright border&#10;                    Handles.color = Color.cyan;&#10;                    Handles.DrawWireDisc(itemPos, Vector3.forward, iconSize * 0.7f);&#10;                    Handles.color = Color.white;&#10;&#10;                    // Show enhanced name display&#10;                    GUIContent nameContent = new(prefab.name);&#10;                    Vector2 nameSize = EditorStyles.boldLabel.CalcSize(nameContent);&#10;                    Rect nameRect = new(&#10;                        center.x - nameSize.x * 0.5f,&#10;                        center.y + radius + 10,&#10;                        nameSize.x,&#10;                        nameSize.y&#10;                    );&#10;&#10;                    // Draw name background&#10;                    EditorGUI.DrawRect(&#10;                        new Rect(nameRect.x - 4, nameRect.y - 2, nameRect.width + 8, nameRect.height + 4),&#10;                        new Color(0, 0, 0, 0.8f));&#10;&#10;                    // Draw name with highlight color&#10;                    GUI.color = Color.cyan;&#10;                    GUI.Label(nameRect, nameContent, EditorStyles.boldLabel);&#10;                    GUI.color = Color.white;&#10;                }&#10;                else&#10;                {&#10;                    // Subtle highlight for non-hovered items&#10;                    Handles.color = new Color(0.4f, 0.4f, 0.4f, 0.3f);&#10;                    Handles.DrawSolidDisc(itemPos, Vector3.forward, iconSize * 0.6f);&#10;                    Handles.color = Color.white;&#10;                }&#10;&#10;                // Draw icon rect&#10;                Rect iconRect = new(&#10;                    itemPos.x - iconSize * 0.5f,&#10;                    itemPos.y - iconSize * 0.5f,&#10;                    iconSize,&#10;                    iconSize&#10;                );&#10;&#10;                // Draw preview with enhanced border for hovered items&#10;                Texture2D preview = GetPrefabPreview(prefab);&#10;                if (preview != null)&#10;                {&#10;                    if (isHovered)&#10;                    {&#10;                        // Draw glowing border for hovered item&#10;                        Rect borderRect = new(iconRect.x - 2, iconRect.y - 2, iconRect.width + 4, iconRect.height + 4);&#10;                        EditorGUI.DrawRect(borderRect, Color.cyan);&#10;                    }&#10;&#10;                    GUI.DrawTexture(iconRect, preview, ScaleMode.ScaleToFit);&#10;                }&#10;                else&#10;                {&#10;                    // Draw placeholder with proper highlighting&#10;                    Color placeholderColor = isHovered ? new Color(0.6f, 0.6f, 0.6f) : new Color(0.3f, 0.3f, 0.3f);&#10;                    EditorGUI.DrawRect(iconRect, placeholderColor);&#10;&#10;                    // Draw loading text&#10;                    GUI.color = isHovered ? Color.white : Color.gray;&#10;                    GUI.Label(iconRect, &quot;...&quot;, EditorStyles.centeredGreyMiniLabel);&#10;                    GUI.color = Color.white;&#10;                }&#10;            }&#10;&#10;            Handles.EndGUI();&#10;        }&#10;&#10;        private GameObject GetPrefabFromRadialMenu(Vector2 mousePosition)&#10;        {&#10;            int index = GetRadialMenuIndex(mousePosition);&#10;            if (index &lt; 0) return null;&#10;&#10;            var prefabsToShow = _frequentPrefabs.Count &gt; 0&#10;                ? _frequentPrefabs&#10;                : _filteredPrefabs.Take(MaxFrequentPrefabs).Select(p =&gt; p.prefab).ToList();&#10;&#10;            return index &lt; prefabsToShow.Count ? prefabsToShow[index] : null;&#10;        }&#10;&#10;        private int GetRadialMenuIndex(Vector2 mousePosition)&#10;        {&#10;            float distance = Vector2.Distance(mousePosition, _radialMenuPosition);&#10;            if (distance &lt; 20 || distance &gt; RadialMenuRadius * 0.9f) return -1; // Improved hit detection&#10;&#10;            var prefabsToShow = _frequentPrefabs.Count &gt; 0&#10;                ? _frequentPrefabs&#10;                : _filteredPrefabs.Take(MaxFrequentPrefabs).Select(p =&gt; p.prefab).ToList();&#10;&#10;            int prefabCount = Mathf.Min(prefabsToShow.Count, MaxFrequentPrefabs);&#10;            if (prefabCount == 0) return -1;&#10;&#10;            // Improved angle calculation for better selection accuracy&#10;            Vector2 direction = (mousePosition - _radialMenuPosition).normalized;&#10;            float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;&#10;&#10;            // Normalize angle to 0-360 range and adjust for starting at top&#10;            angle = (angle + 90f + 360f) % 360f;&#10;&#10;            float segmentAngle = 360f / prefabCount;&#10;            int index = Mathf.FloorToInt((angle + segmentAngle * 0.5f) / segmentAngle) % prefabCount;&#10;&#10;            return index;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Core Logic&#10;&#10;        private void StartPlacementMode(GameObject prefab)&#10;        {&#10;            if (!prefab) return;&#10;&#10;            _placementMode = true;&#10;            _selectedPrefabForPlacement = prefab;&#10;            IncrementPrefabUsage(prefab);&#10;            GUI.FocusControl(null);&#10;&#10;            Debug.Log($&quot;Started placement mode for: {prefab.name}&quot;);&#10;        }&#10;&#10;        private void ExitPlacementMode()&#10;        {&#10;            _placementMode = false;&#10;            _selectedPrefabForPlacement = null;&#10;            Debug.Log(&quot;Exited placement mode&quot;);&#10;        }&#10;&#10;        private void PlacePrefabAtPosition(GameObject prefab, Vector3 placePosition)&#10;        {&#10;            if (!prefab) return;&#10;&#10;            try&#10;            {&#10;                Undo.IncrementCurrentGroup();&#10;                GameObject instance = (GameObject)PrefabUtility.InstantiatePrefab(prefab);&#10;                Undo.RegisterCreatedObjectUndo(instance, $&quot;Place {prefab.name}&quot;);&#10;                instance.transform.position = placePosition;&#10;                Selection.activeGameObject = instance;&#10;&#10;                Debug.Log($&quot;Placed {prefab.name} at {placePosition}&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to place prefab {prefab.name}: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private Vector3 GetMouseWorldPosition(Event e)&#10;        {&#10;            Ray ray = HandleUtility.GUIPointToWorldRay(e.mousePosition);&#10;            Plane plane = new(Vector3.forward, Vector3.zero);&#10;&#10;            if (plane.Raycast(ray, out float distance))&#10;            {&#10;                return ray.GetPoint(distance);&#10;            }&#10;&#10;            return ray.origin;&#10;        }&#10;&#10;        private Vector3 SnapToGrid(Vector3 snapPosition)&#10;        {&#10;            if (_settings.pixelsPerUnit &lt;= 0) return snapPosition;&#10;&#10;            float ppu = _settings.pixelsPerUnit;&#10;            snapPosition.x = Mathf.Round(snapPosition.x * ppu) / ppu;&#10;            snapPosition.y = Mathf.Round(snapPosition.y * ppu) / ppu;&#10;            snapPosition.z = 0;&#10;&#10;            return snapPosition;&#10;        }&#10;&#10;        private void HandleKeyboardShortcuts()&#10;        {&#10;            Event e = Event.current;&#10;            if (e.type != EventType.KeyDown) return;&#10;&#10;            if (e.control || e.command)&#10;            {&#10;                switch (e.keyCode)&#10;                {&#10;                    case KeyCode.F:&#10;                        GUI.FocusControl(&quot;SearchField&quot;);&#10;                        e.Use();&#10;                        break;&#10;                    case KeyCode.R:&#10;                        LoadPrefabs();&#10;                        e.Use();&#10;                        break;&#10;                    case KeyCode.Escape:&#10;                        if (_placementMode)&#10;                        {&#10;                            ExitPlacementMode();&#10;                            e.Use();&#10;                        }&#10;&#10;                        break;&#10;                }&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Data Management&#10;&#10;        private void LoadPrefabs()&#10;        {&#10;            try&#10;            {&#10;                _prefabInfos.Clear();&#10;&#10;                if (!AssetDatabase.IsValidFolder(PrefabFolderPath))&#10;                {&#10;                    Debug.LogWarning($&quot;Prefab folder not found: {PrefabFolderPath}&quot;);&#10;                    return;&#10;                }&#10;&#10;                string[] guids = AssetDatabase.FindAssets(&quot;t:Prefab&quot;, new[] { PrefabFolderPath });&#10;&#10;                for (int i = 0; i &lt; guids.Length; i++)&#10;                {&#10;                    string guid = guids[i];&#10;                    string path = AssetDatabase.GUIDToAssetPath(guid);&#10;                    GameObject prefab = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);&#10;&#10;                    if (prefab != null)&#10;                    {&#10;                        _prefabInfos.Add(new PrefabInfo(prefab));&#10;                    }&#10;&#10;                    // Show progress for large collections&#10;                    if (i % 50 == 0)&#10;                    {&#10;                        EditorUtility.DisplayProgressBar(&quot;Loading Prefabs&quot;, $&quot;Processing {i}/{guids.Length}&quot;,&#10;                            (float)i / guids.Length);&#10;                    }&#10;                }&#10;&#10;                EditorUtility.ClearProgressBar();&#10;&#10;                ApplyFilters();&#10;                StartPreviewLoading();&#10;&#10;                Debug.Log($&quot;Loaded {_prefabInfos.Count} prefabs from {PrefabFolderPath}&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                EditorUtility.ClearProgressBar();&#10;                Debug.LogError($&quot;Failed to load prefabs: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ApplyFilters()&#10;        {&#10;            try&#10;            {&#10;                _filteredPrefabs.Clear();&#10;                string searchLower = _settings.searchFilter.ToLowerInvariant();&#10;&#10;                foreach (PrefabInfo prefabInfo in _prefabInfos)&#10;                {&#10;                    if (!prefabInfo.isValid || prefabInfo.prefab == null) continue;&#10;&#10;                    // Search filter&#10;                    if (!string.IsNullOrEmpty(_settings.searchFilter) &amp;&amp;&#10;                        !prefabInfo.name.ToLowerInvariant().Contains(searchLower))&#10;                    {&#10;                        continue;&#10;                    }&#10;&#10;                    // Category filter&#10;                    if (MatchesFilter(prefabInfo))&#10;                    {&#10;                        _filteredPrefabs.Add(prefabInfo);&#10;                    }&#10;                }&#10;&#10;                // Sort by usage frequency and name&#10;                _filteredPrefabs.Sort((a, b) =&gt;&#10;                {&#10;                    int usageA = _prefabUsageCount.GetValueOrDefault(a.prefab, 0);&#10;                    int usageB = _prefabUsageCount.GetValueOrDefault(b.prefab, 0);&#10;&#10;                    if (usageA != usageB)&#10;                        return usageB.CompareTo(usageA);&#10;&#10;                    return string.Compare(a.name, b.name, StringComparison.OrdinalIgnoreCase);&#10;                });&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to apply filters: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private bool MatchesFilter(PrefabInfo prefabInfo)&#10;        {&#10;            return _settings.filterType switch&#10;            {&#10;                FilterType.All =&gt; true,&#10;                FilterType.Enemies =&gt; prefabInfo.category == FilterType.Enemies,&#10;                FilterType.Containers =&gt; prefabInfo.category == FilterType.Containers,&#10;                FilterType.Others =&gt; prefabInfo.category == FilterType.Others,&#10;                _ =&gt; true&#10;            };&#10;        }&#10;&#10;        private void LoadUsageData()&#10;        {&#10;            try&#10;            {&#10;                _prefabUsageCount.Clear();&#10;                string data = EditorPrefs.GetString(UsageDataKey, &quot;&quot;);&#10;                if (string.IsNullOrEmpty(data)) return;&#10;&#10;                foreach (string entry in data.Split(';'))&#10;                {&#10;                    if (string.IsNullOrEmpty(entry)) continue;&#10;&#10;                    string[] parts = entry.Split(':');&#10;                    if (parts.Length != 2) continue;&#10;&#10;                    string path = AssetDatabase.GUIDToAssetPath(parts[0]);&#10;                    if (string.IsNullOrEmpty(path)) continue;&#10;&#10;                    GameObject prefab = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);&#10;                    if (prefab != null &amp;&amp; int.TryParse(parts[1], out int count))&#10;                    {&#10;                        _prefabUsageCount[prefab] = count;&#10;                    }&#10;                }&#10;&#10;                UpdateFrequentPrefabs();&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to load usage data: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SaveUsageData()&#10;        {&#10;            try&#10;            {&#10;                var validEntries = _prefabUsageCount&#10;                    .Where(kvp =&gt; kvp.Key != null &amp;&amp; AssetDatabase.Contains(kvp.Key))&#10;                    .Select(kvp =&gt;&#10;                    {&#10;                        string path = AssetDatabase.GetAssetPath(kvp.Key);&#10;                        string guid = AssetDatabase.AssetPathToGUID(path);&#10;                        return $&quot;{guid}:{kvp.Value}&quot;;&#10;                    });&#10;&#10;                string data = string.Join(&quot;;&quot;, validEntries);&#10;                EditorPrefs.SetString(UsageDataKey, data);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to save usage data: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private void LoadSettings()&#10;        {&#10;            try&#10;            {&#10;                string json = EditorPrefs.GetString(SettingsKey, &quot;&quot;);&#10;                if (!string.IsNullOrEmpty(json))&#10;                {&#10;                    _settings = JsonUtility.FromJson&lt;WindowSettings&gt;(json);&#10;                }&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to load settings: {e.Message}&quot;);&#10;                _settings = new WindowSettings();&#10;            }&#10;        }&#10;&#10;        private void SaveSettings()&#10;        {&#10;            try&#10;            {&#10;                string json = JsonUtility.ToJson(_settings);&#10;                EditorPrefs.SetString(SettingsKey, json);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to save settings: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private void IncrementPrefabUsage(GameObject prefab)&#10;        {&#10;            if (prefab == null) return;&#10;&#10;            _prefabUsageCount.TryGetValue(prefab, out int count);&#10;            _prefabUsageCount[prefab] = count + 1;&#10;&#10;            UpdateFrequentPrefabs();&#10;            EditorApplication.delayCall += SaveUsageData;&#10;        }&#10;&#10;        private void UpdateFrequentPrefabs()&#10;        {&#10;            _frequentPrefabs.Clear();&#10;            var sortedPrefabs = _prefabUsageCount&#10;                .Where(kvp =&gt; kvp.Key != null)&#10;                .OrderByDescending(kvp =&gt; kvp.Value)&#10;                .Take(MaxFrequentPrefabs)&#10;                .Select(kvp =&gt; kvp.Key);&#10;&#10;            _frequentPrefabs.AddRange(sortedPrefabs);&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Preview System&#10;&#10;        private Texture2D GetPrefabPreview(GameObject prefab)&#10;        {&#10;            if (prefab == null) return null;&#10;&#10;            // Check cache first&#10;            if (_settings.enablePreviewCache &amp;&amp; _previewCache.TryGetValue(prefab, out Texture2D cachedPreview))&#10;            {&#10;                // Validate cached preview is still valid&#10;                if (cachedPreview != null &amp;&amp; !AssetPreview.IsLoadingAssetPreview(prefab.GetInstanceID()))&#10;                {&#10;                    return cachedPreview;&#10;                }&#10;&#10;                // Remove invalid cache entry&#10;                _previewCache.Remove(prefab);&#10;            }&#10;&#10;            // Try to get preview from Unity's AssetPreview system&#10;            Texture2D preview = AssetPreview.GetAssetPreview(prefab);&#10;&#10;            if (preview != null)&#10;            {&#10;                // Process the preview to make background transparent&#10;                Texture2D processedPreview = MakePreviewTransparent(preview);&#10;&#10;                // Cache the processed preview&#10;                if (_settings.enablePreviewCache)&#10;                {&#10;                    _previewCache[prefab] = processedPreview;&#10;                }&#10;&#10;                return processedPreview;&#10;            }&#10;&#10;            // If no preview available, check if it's still loading&#10;            if (AssetPreview.IsLoadingAssetPreview(prefab.GetInstanceID()))&#10;            {&#10;                // Force refresh to potentially generate preview&#10;                AssetPreview.GetAssetPreview(prefab);&#10;&#10;                // Queue for later retry if not already queued&#10;                if (_settings.enablePreviewCache &amp;&amp; !_previewLoadQueue.Contains(prefab))&#10;                {&#10;                    _previewLoadQueue.Enqueue(prefab);&#10;                }&#10;&#10;                return null;&#10;            }&#10;&#10;            // Try to generate a mini preview from the prefab's renderer&#10;            return GenerateCustomPreview(prefab);&#10;        }&#10;&#10;        private Texture2D MakePreviewTransparent(Texture2D originalTexture)&#10;        {&#10;            if (originalTexture == null) return null;&#10;&#10;            try&#10;            {&#10;                // Create a new readable texture&#10;                Texture2D readableTexture =&#10;                    new(originalTexture.width, originalTexture.height, TextureFormat.RGBA32, false);&#10;&#10;                // Create a RenderTexture to copy the original texture&#10;                RenderTexture renderTexture = RenderTexture.GetTemporary(originalTexture.width, originalTexture.height,&#10;                    0, RenderTextureFormat.ARGB32);&#10;&#10;                Graphics.Blit(originalTexture, renderTexture);&#10;&#10;                // Read the pixels from the RenderTexture&#10;                RenderTexture.active = renderTexture;&#10;                readableTexture.ReadPixels(new Rect(0, 0, originalTexture.width, originalTexture.height), 0, 0);&#10;                readableTexture.Apply();&#10;                RenderTexture.active = null;&#10;                RenderTexture.ReleaseTemporary(renderTexture);&#10;&#10;                // Process pixels to make background transparent&#10;                var pixels = readableTexture.GetPixels();&#10;                Color backgroundColor = pixels[0]; // Assume top-left corner is background&#10;&#10;                for (int i = 0; i &lt; pixels.Length; i++)&#10;                {&#10;                    Color pixel = pixels[i];&#10;&#10;                    // If pixel is very similar to background color, make it transparent&#10;                    float colorDistance = Vector3.Distance(&#10;                        new Vector3(pixel.r, pixel.g, pixel.b),&#10;                        new Vector3(backgroundColor.r, backgroundColor.g, backgroundColor.b)&#10;                    );&#10;&#10;                    if (colorDistance &lt; 0.1f) // Threshold for background detection&#10;                    {&#10;                        pixels[i] = new Color(pixel.r, pixel.g, pixel.b, 0f); // Make transparent&#10;                    }&#10;                    else&#10;                    {&#10;                        // Keep original alpha or make slightly transparent for blending&#10;                        pixels[i] = new Color(pixel.r, pixel.g, pixel.b, pixel.a * 0.9f);&#10;                    }&#10;                }&#10;&#10;                readableTexture.SetPixels(pixels);&#10;                readableTexture.Apply();&#10;&#10;                return readableTexture;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogWarning($&quot;Failed to make preview transparent: {e.Message}&quot;);&#10;                return originalTexture; // Return original if processing fails&#10;            }&#10;        }&#10;&#10;        private Texture2D GenerateCustomPreview(GameObject prefab)&#10;        {&#10;            try&#10;            {&#10;                // Get all renderers in the prefab&#10;                var renderers = prefab.GetComponentsInChildren&lt;Renderer&gt;();&#10;                if (renderers == null || renderers.Length == 0)&#10;                    return null;&#10;&#10;                // Create a simple colored texture based on the prefab's main material&#10;                Renderer mainRenderer = renderers[0];&#10;                if (mainRenderer.sharedMaterial != null)&#10;                {&#10;                    Color materialColor = Color.white;&#10;&#10;                    // Try to get color from various shader properties&#10;                    Material material = mainRenderer.sharedMaterial;&#10;                    if (material.HasProperty(Color1))&#10;                    {&#10;                        materialColor = material.GetColor(Color1);&#10;                    }&#10;                    else if (material.HasProperty(BaseColor))&#10;                    {&#10;                        materialColor = material.GetColor(BaseColor);&#10;                    }&#10;                    else if (material.HasProperty(MainTex) &amp;&amp; material.mainTexture)&#10;                    {&#10;                        // Use a sample from the main texture&#10;                        Texture2D texture = material.mainTexture as Texture2D;&#10;                        if (texture &amp;&amp; texture.isReadable)&#10;                        {&#10;                            materialColor = texture.GetPixel(texture.width / 2, texture.height / 2);&#10;                        }&#10;                    }&#10;&#10;                    // Create a simple 64x64 preview texture&#10;                    Texture2D customPreview = new(64, 64, TextureFormat.RGBA32, false);&#10;                    var pixels = new Color[64 * 64];&#10;&#10;                    // Create a simple gradient/pattern&#10;                    for (int y = 0; y &lt; 64; y++)&#10;                    {&#10;                        for (int x = 0; x &lt; 64; x++)&#10;                        {&#10;                            float distance = Vector2.Distance(new Vector2(x, y), new Vector2(32, 32));&#10;                            float alpha = Mathf.Clamp01(1.0f - distance / 32.0f);&#10;                            pixels[y * 64 + x] = new Color(materialColor.r, materialColor.g, materialColor.b,&#10;                                alpha * materialColor.a);&#10;                        }&#10;                    }&#10;&#10;                    customPreview.SetPixels(pixels);&#10;                    customPreview.Apply();&#10;&#10;                    // Cache the custom preview&#10;                    if (_settings.enablePreviewCache)&#10;                    {&#10;                        _previewCache[prefab] = customPreview;&#10;                    }&#10;&#10;                    return customPreview;&#10;                }&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogWarning($&quot;Failed to generate custom preview for {prefab.name}: {e.Message}&quot;);&#10;            }&#10;&#10;            return null;&#10;        }&#10;&#10;        private void ClearPreviews()&#10;        {&#10;            foreach (Texture2D preview in _previewCache.Values)&#10;            {&#10;                if (preview != null)&#10;                {&#10;                    DestroyImmediate(preview);&#10;                }&#10;            }&#10;&#10;            _previewCache.Clear();&#10;            _previewLoadQueue.Clear();&#10;        }&#10;&#10;        private void RefreshPreviewCache()&#10;        {&#10;            // Clear existing cache&#10;            ClearPreviews();&#10;&#10;            // Restart preview loading&#10;            StartPreviewLoading();&#10;&#10;            // Force repaint&#10;        }&#10;&#10;        #endregion&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.IO;&#10;using System.Linq;&#10;using PowerUps.Container;&#10;using UnityEditor;&#10;using UnityEngine;&#10;&#10;namespace Editor&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Enhanced Prefab Auditor Window with optimized performance and improved functionality&#10;    /// &lt;/summary&gt;&#10;    public class PrefabAuditorWindow : EditorWindow&#10;    {&#10;&#10;        #region Enums&#10;&#10;        public enum FilterType&#10;        {&#10;            All,&#10;            Enemies,&#10;            Containers,&#10;            Others&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Utility Methods&#10;&#10;        private static string FormatFileSize(long bytes)&#10;        {&#10;            string[] sizes = { &quot;B&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot; };&#10;            double len = bytes;&#10;            int order = 0;&#10;            while (len &gt;= 1024 &amp;&amp; order &lt; sizes.Length - 1)&#10;            {&#10;                order++;&#10;                len = len / 1024;&#10;            }&#10;&#10;            return $&quot;{len:0.##} {sizes[order]}&quot;;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Serialized Settings&#10;&#10;        [Serializable]&#10;        public class WindowSettings&#10;        {&#10;            public string searchFilter = &quot;&quot;;&#10;            public FilterType filterType = FilterType.All;&#10;            public bool useGridView = true;&#10;            public bool autoRefresh = true;&#10;            public bool showAdvancedSettings;&#10;            public float pixelsPerUnit = 16f;&#10;            public int gridColumns = 4;&#10;            public bool enablePreviewCache = true;&#10;            public bool enableVirtualization = true;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Helper Classes&#10;&#10;        [Serializable]&#10;        public class PrefabInfo&#10;        {&#10;            public GameObject prefab;&#10;            public string name;&#10;            public string path;&#10;            public string guid;&#10;            public FilterType category;&#10;            public bool isValid;&#10;            public long fileSize;&#10;            public DateTime lastModified;&#10;&#10;            public PrefabInfo(GameObject prefab)&#10;            {&#10;                this.prefab = prefab;&#10;                name = prefab.name;&#10;                path = AssetDatabase.GetAssetPath(prefab);&#10;                guid = AssetDatabase.AssetPathToGUID(path);&#10;                category = DetermineCategory(prefab);&#10;                isValid = prefab != null;&#10;&#10;                if (File.Exists(path))&#10;                {&#10;                    FileInfo fileInfo = new(path);&#10;                    fileSize = fileInfo.Length;&#10;                    lastModified = fileInfo.LastWriteTime;&#10;                }&#10;            }&#10;&#10;            private static FilterType DetermineCategory(GameObject prefab)&#10;            {&#10;                if ((1 &lt;&lt; prefab.layer &amp; LayerMask.GetMask(&quot;Enemy&quot;)) != 0)&#10;                    return FilterType.Enemies;&#10;&#10;                if (prefab.layer == LayerMask.NameToLayer(&quot;Collectibles&quot;) &amp;&amp;&#10;                    prefab.GetComponent&lt;PowerUpContainer&gt;() != null)&#10;                    return FilterType.Containers;&#10;&#10;                return FilterType.Others;&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Constants&#10;&#10;        private const int MaxFrequentPrefabs = 8;&#10;        private const float RadialMenuRadius = 100f;&#10;        private const float RadialMenuAnimationTime = 0.3f;&#10;        private const float PreviewSize = 64f;&#10;        private const string PrefabFolderPath = &quot;Assets/Prefabs&quot;;&#10;        private const string UsageDataKey = &quot;PrefabAuditor_UsageData_v2&quot;;&#10;        private const string SettingsKey = &quot;PrefabAuditor_Settings_v2&quot;;&#10;&#10;        #endregion&#10;&#10;        #region Private Fields&#10;&#10;        // Core Data&#10;        private readonly List&lt;PrefabInfo&gt; _prefabInfos = new();&#10;        private readonly List&lt;PrefabInfo&gt; _filteredPrefabs = new();&#10;        private readonly List&lt;GameObject&gt; _frequentPrefabs = new();&#10;        private readonly Dictionary&lt;GameObject, int&gt; _prefabUsageCount = new();&#10;&#10;        // Preview System&#10;        private readonly Dictionary&lt;GameObject, Texture2D&gt; _previewCache = new();&#10;        private readonly Queue&lt;GameObject&gt; _previewLoadQueue = new();&#10;        private bool _isLoadingPreviews;&#10;&#10;        // UI State&#10;        private WindowSettings _settings = new();&#10;        private Vector2 _scrollPosition;&#10;        private string _lastSearchFilter = &quot;&quot;;&#10;        private FilterType _lastFilterType = FilterType.All;&#10;&#10;        // Placement System&#10;        private bool _placementMode;&#10;        private GameObject _selectedPrefabForPlacement;&#10;        private GameObject _defaultDropPrefab;&#10;&#10;        // Radial Menu System&#10;        private bool _showRadialMenu;&#10;        private Vector2 _radialMenuPosition;&#10;        private float _radialMenuOpenTime;&#10;        private int _hoveredRadialIndex = -1;&#10;&#10;        // Performance Tracking&#10;        private double _lastRepaintTime;&#10;        private int _virtualizedStartIndex;&#10;        private int _virtualizedEndIndex;&#10;&#10;        // Styles (cached)&#10;        private static GUIStyle _headerStyle;&#10;        private static GUIStyle _cardStyle;&#10;        private static GUIStyle _buttonStyle;&#10;        private static readonly int Color1 = Shader.PropertyToID(&quot;_Color&quot;);&#10;        private static readonly int BaseColor = Shader.PropertyToID(&quot;_BaseColor&quot;);&#10;        private static readonly int MainTex = Shader.PropertyToID(&quot;_MainTex&quot;);&#10;&#10;        #endregion&#10;&#10;        #region Unity Lifecycle&#10;&#10;        [MenuItem(&quot;Tools/Enhanced Prefab Manager&quot;)]&#10;        public static void ShowWindow()&#10;        {&#10;            PrefabAuditorWindow window = GetWindow&lt;PrefabAuditorWindow&gt;(&quot;Prefab Manager&quot;);&#10;            window.minSize = new Vector2(600, 700);&#10;            window.maxSize = new Vector2(2000, 2000);&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            LoadSettings();&#10;            LoadPrefabs();&#10;            LoadUsageData();&#10;            UpdateFrequentPrefabs();&#10;&#10;            SceneView.duringSceneGui += OnSceneGUI;&#10;            EditorApplication.update += OnEditorUpdate;&#10;            EditorApplication.projectChanged += OnProjectChanged;&#10;&#10;            // Start preview loading&#10;            EditorApplication.delayCall += StartPreviewLoading;&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            SaveSettings();&#10;            SaveUsageData();&#10;&#10;            SceneView.duringSceneGui -= OnSceneGUI;&#10;            EditorApplication.update -= OnEditorUpdate;&#10;            EditorApplication.projectChanged -= OnProjectChanged;&#10;&#10;            ClearPreviews();&#10;        }&#10;&#10;        private void OnProjectChanged()&#10;        {&#10;            if (_settings.autoRefresh)&#10;            {&#10;                EditorApplication.delayCall += LoadPrefabs;&#10;            }&#10;        }&#10;&#10;        private void OnEditorUpdate()&#10;        {&#10;            double currentTime = EditorApplication.timeSinceStartup;&#10;&#10;            // Limit repaints for performance&#10;            if (_showRadialMenu &amp;&amp; currentTime - _lastRepaintTime &gt; 0.016f) // ~60fps&#10;            {&#10;                SceneView.lastActiveSceneView?.Repaint();&#10;                _lastRepaintTime = currentTime;&#10;            }&#10;&#10;            // Process preview loading queue&#10;            ProcessPreviewQueue();&#10;&#10;            // Auto-refresh check&#10;            if (_settings.autoRefresh &amp;&amp;&#10;                (_lastSearchFilter != _settings.searchFilter || _lastFilterType != _settings.filterType))&#10;            {&#10;                ApplyFilters();&#10;                _lastSearchFilter = _settings.searchFilter;&#10;                _lastFilterType = _settings.filterType;&#10;            }&#10;        }&#10;&#10;        private void OnGUI()&#10;        {&#10;            InitializeStyles();&#10;&#10;            using (new EditorGUILayout.VerticalScope())&#10;            {&#10;                DrawHeader();&#10;                DrawFiltersAndSearch();&#10;                DrawQuickSettings();&#10;                DrawPrefabsList();&#10;                DrawFooter();&#10;            }&#10;&#10;            HandleKeyboardShortcuts();&#10;        }&#10;&#10;        private void OnSceneGUI(SceneView sceneView)&#10;        {&#10;            Event currentEvent = Event.current;&#10;&#10;            // Handle radial menu first (higher priority)&#10;            if (HandleRadialMenu(currentEvent, sceneView))&#10;                return;&#10;&#10;            // Handle placement mode&#10;            HandlePlacementMode(currentEvent, sceneView);&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region UI Drawing&#10;&#10;        private void InitializeStyles()&#10;        {&#10;            if (_headerStyle != null) return;&#10;&#10;            _headerStyle = new GUIStyle(EditorStyles.boldLabel)&#10;            {&#10;                fontSize = 16,&#10;                alignment = TextAnchor.MiddleLeft,&#10;                normal = { textColor = EditorGUIUtility.isProSkin ? Color.white : Color.black }&#10;            };&#10;&#10;            _cardStyle = new GUIStyle(GUI.skin.box)&#10;            {&#10;                padding = new RectOffset(12, 12, 8, 8),&#10;                margin = new RectOffset(4, 4, 2, 2)&#10;            };&#10;&#10;            _buttonStyle = new GUIStyle(GUI.skin.button)&#10;            {&#10;                padding = new RectOffset(8, 8, 4, 4)&#10;            };&#10;&#10;&#10;        }&#10;&#10;        private void DrawHeader()&#10;        {&#10;            using (new EditorGUILayout.VerticalScope(_cardStyle))&#10;            {&#10;                EditorGUILayout.LabelField(&quot; Enhanced Prefab Manager&quot;, _headerStyle);&#10;                EditorGUILayout.LabelField(&#10;                    $&quot;Found {_prefabInfos.Count} prefabs | Showing {_filteredPrefabs.Count} | Cache: {_previewCache.Count}&quot;,&#10;                    EditorStyles.miniLabel);&#10;&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    if (GUILayout.Button(&quot; Refresh&quot;, _buttonStyle, GUILayout.Width(80)))&#10;                    {&#10;                        LoadPrefabs();&#10;                    }&#10;&#10;                    _settings.autoRefresh =&#10;                        GUILayout.Toggle(_settings.autoRefresh, &quot;Auto Refresh&quot;, GUILayout.Width(100));&#10;&#10;                    GUILayout.FlexibleSpace();&#10;&#10;                    if (_placementMode &amp;&amp; GUILayout.Button(&quot;❌ Exit Placement&quot;, _buttonStyle, GUILayout.Width(120)))&#10;                    {&#10;                        ExitPlacementMode();&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawFiltersAndSearch()&#10;        {&#10;            using (new EditorGUILayout.VerticalScope(_cardStyle))&#10;            {&#10;                EditorGUILayout.LabelField(&quot; Filters &amp; Search&quot;, EditorStyles.boldLabel);&#10;&#10;                // Search with clear button&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    EditorGUILayout.LabelField(&quot;Search:&quot;, GUILayout.Width(50));&#10;                    _settings.searchFilter = EditorGUILayout.TextField(_settings.searchFilter);&#10;                    if (GUILayout.Button(&quot;✕&quot;, GUILayout.Width(20)))&#10;                    {&#10;                        _settings.searchFilter = &quot;&quot;;&#10;                        ApplyFilters();&#10;                    }&#10;                }&#10;&#10;                // Filter and view options&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    EditorGUILayout.LabelField(&quot;Filter:&quot;, GUILayout.Width(50));&#10;                    FilterType newFilter = (FilterType)EditorGUILayout.EnumPopup(_settings.filterType);&#10;                    if (newFilter != _settings.filterType)&#10;                    {&#10;                        _settings.filterType = newFilter;&#10;                        ApplyFilters();&#10;                    }&#10;&#10;                    GUILayout.FlexibleSpace();&#10;&#10;                    EditorGUILayout.LabelField(&quot;View:&quot;, GUILayout.Width(40));&#10;                    _settings.useGridView =&#10;                        GUILayout.Toggle(_settings.useGridView, &quot;Grid&quot;, &quot;Button&quot;, GUILayout.Width(50));&#10;&#10;                    _settings.useGridView =&#10;                        !GUILayout.Toggle(!_settings.useGridView, &quot;List&quot;, &quot;Button&quot;, GUILayout.Width(50));&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawQuickSettings()&#10;        {&#10;            using (new EditorGUILayout.VerticalScope(_cardStyle))&#10;            {&#10;                _settings.showAdvancedSettings = EditorGUILayout.Foldout(_settings.showAdvancedSettings, &quot;⚙️ Settings&quot;,&#10;                    true, EditorStyles.foldout);&#10;&#10;                if (_settings.showAdvancedSettings)&#10;                {&#10;                    using (new EditorGUILayout.HorizontalScope())&#10;                    {&#10;                        EditorGUILayout.LabelField(&quot;Grid Snap (PPU):&quot;, GUILayout.Width(100));&#10;                        _settings.pixelsPerUnit =&#10;                            EditorGUILayout.FloatField(_settings.pixelsPerUnit, GUILayout.Width(60));&#10;&#10;                        GUILayout.Space(10);&#10;&#10;                        EditorGUILayout.LabelField(&quot;Grid Columns:&quot;, GUILayout.Width(85));&#10;                        _settings.gridColumns =&#10;                            EditorGUILayout.IntSlider(_settings.gridColumns, 2, 8, GUILayout.Width(100));&#10;                    }&#10;&#10;                    using (new EditorGUILayout.HorizontalScope())&#10;                    {&#10;                        EditorGUILayout.LabelField(&quot;Default Drop:&quot;, GUILayout.Width(80));&#10;                        _defaultDropPrefab =&#10;                            (GameObject)EditorGUILayout.ObjectField(_defaultDropPrefab, typeof(GameObject), false);&#10;&#10;                        GUILayout.Space(10);&#10;&#10;                        _settings.enablePreviewCache = GUILayout.Toggle(_settings.enablePreviewCache, &quot;Preview Cache&quot;);&#10;                        _settings.enableVirtualization =&#10;                            GUILayout.Toggle(_settings.enableVirtualization, &quot;Virtualization&quot;);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawPrefabsList()&#10;        {&#10;            using (new EditorGUILayout.VerticalScope(_cardStyle))&#10;            {&#10;                EditorGUILayout.LabelField(&quot; Prefabs&quot;, EditorStyles.boldLabel);&#10;&#10;                if (_filteredPrefabs.Count == 0)&#10;                {&#10;                    EditorGUILayout.HelpBox(&quot;No prefabs match current filters.&quot;, MessageType.Info);&#10;                    return;&#10;                }&#10;&#10;                CalculateVirtualization();&#10;&#10;                using (EditorGUILayout.ScrollViewScope scrollScope = new(_scrollPosition, GUILayout.ExpandHeight(true)))&#10;                {&#10;                    _scrollPosition = scrollScope.scrollPosition;&#10;&#10;                    if (_settings.useGridView)&#10;                    {&#10;                        DrawPrefabsGrid();&#10;                    }&#10;                    else&#10;                    {&#10;                        DrawPrefabsListItems();&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawPrefabsListItems()&#10;        {&#10;            var visiblePrefabs = GetVisiblePrefabs();&#10;&#10;            foreach (PrefabInfo prefabInfo in visiblePrefabs)&#10;            {&#10;                if (prefabInfo?.prefab == null) continue;&#10;                DrawPrefabListItem(prefabInfo);&#10;            }&#10;        }&#10;&#10;        private void DrawPrefabListItem(PrefabInfo prefabInfo)&#10;        {&#10;            using (new EditorGUILayout.VerticalScope(_cardStyle))&#10;            {&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    // Preview&#10;                    Texture2D preview = GetPrefabPreview(prefabInfo.prefab);&#10;                    if (preview != null)&#10;                    {&#10;                        GUILayout.Label(preview, GUILayout.Width(PreviewSize), GUILayout.Height(PreviewSize));&#10;                    }&#10;                    else&#10;                    {&#10;                        GUILayout.Box(&quot;Loading...&quot;, GUILayout.Width(PreviewSize), GUILayout.Height(PreviewSize));&#10;                    }&#10;&#10;                    // Info&#10;                    using (new EditorGUILayout.VerticalScope())&#10;                    {&#10;                        EditorGUILayout.LabelField(prefabInfo.name, EditorStyles.boldLabel);&#10;                        EditorGUILayout.LabelField($&quot;Category: {prefabInfo.category}&quot;, EditorStyles.miniLabel);&#10;&#10;                        if (_settings.showAdvancedSettings)&#10;                        {&#10;                            EditorGUILayout.LabelField($&quot;Size: {FormatFileSize(prefabInfo.fileSize)}&quot;,&#10;                                EditorStyles.miniLabel);&#10;                        }&#10;                    }&#10;&#10;                    GUILayout.FlexibleSpace();&#10;&#10;                    // Actions&#10;                    using (new EditorGUILayout.VerticalScope(GUILayout.Width(180)))&#10;                    {&#10;                        using (new EditorGUILayout.HorizontalScope())&#10;                        {&#10;                            if (GUILayout.Button(&quot;️ Place&quot;, _buttonStyle)) StartPlacementMode(prefabInfo.prefab);&#10;                            if (GUILayout.Button(&quot; Instant&quot;, _buttonStyle))&#10;                                PlacePrefabAtPosition(prefabInfo.prefab, Vector3.zero);&#10;                        }&#10;&#10;                        using (new EditorGUILayout.HorizontalScope())&#10;                        {&#10;                            if (GUILayout.Button(&quot; Select&quot;, _buttonStyle)) Selection.activeObject = prefabInfo.prefab;&#10;                            if (GUILayout.Button(&quot; Show&quot;, _buttonStyle))&#10;                                EditorGUIUtility.PingObject(prefabInfo.prefab);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawPrefabsGrid()&#10;        {&#10;            var visiblePrefabs = GetVisiblePrefabs();&#10;            int columns = _settings.gridColumns;&#10;            int rows = Mathf.CeilToInt((float)visiblePrefabs.Count / columns);&#10;&#10;            for (int row = 0; row &lt; rows; row++)&#10;            {&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    for (int col = 0; col &lt; columns; col++)&#10;                    {&#10;                        int index = row * columns + col;&#10;                        if (index &gt;= visiblePrefabs.Count)&#10;                        {&#10;                            GUILayout.FlexibleSpace();&#10;                            continue;&#10;                        }&#10;&#10;                        PrefabInfo prefabInfo = visiblePrefabs[index];&#10;                        if (prefabInfo?.prefab != null)&#10;                        {&#10;                            DrawPrefabGridItem(prefabInfo);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawPrefabGridItem(PrefabInfo prefabInfo)&#10;        {&#10;            float cellWidth = (position.width - 60) / _settings.gridColumns;&#10;&#10;            using (new EditorGUILayout.VerticalScope(GUILayout.Width(cellWidth), GUILayout.Height(140)))&#10;            {&#10;                // Preview&#10;                Texture2D preview = GetPrefabPreview(prefabInfo.prefab);&#10;                Rect rect = GUILayoutUtility.GetRect(cellWidth - 20, 80, GUILayout.ExpandWidth(false));&#10;&#10;                if (preview != null)&#10;                {&#10;                    GUI.DrawTexture(rect, preview, ScaleMode.ScaleToFit);&#10;                }&#10;                else&#10;                {&#10;                    EditorGUI.DrawRect(rect, Color.gray * 0.3f);&#10;                    GUI.Label(rect, &quot;Loading...&quot;, EditorStyles.centeredGreyMiniLabel);&#10;                }&#10;&#10;                // Name and actions&#10;                EditorGUILayout.LabelField(prefabInfo.name, EditorStyles.miniLabel, GUILayout.Width(cellWidth - 10));&#10;&#10;                using (new EditorGUILayout.HorizontalScope())&#10;                {&#10;                    if (GUILayout.Button(&quot;Place&quot;, GUILayout.Height(25)))&#10;                    {&#10;                        StartPlacementMode(prefabInfo.prefab);&#10;                    }&#10;&#10;                    if (GUILayout.Button(&quot;&quot;, GUILayout.Width(25), GUILayout.Height(25)))&#10;                    {&#10;                        EditorGUIUtility.PingObject(prefabInfo.prefab);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DrawFooter()&#10;        {&#10;            using (new EditorGUILayout.HorizontalScope())&#10;            {&#10;                if (GUILayout.Button(&quot;↶ Undo&quot;, _buttonStyle, GUILayout.Width(80)))&#10;                    Undo.PerformUndo();&#10;&#10;                if (GUILayout.Button(&quot;↷ Redo&quot;, _buttonStyle, GUILayout.Width(80)))&#10;                    Undo.PerformRedo();&#10;&#10;                GUILayout.FlexibleSpace();&#10;&#10;                EditorGUILayout.LabelField($&quot;Preview Queue: {_previewLoadQueue.Count}&quot;, EditorStyles.miniLabel);&#10;&#10;                if (GUILayout.Button(&quot;️ Clear Cache&quot;, _buttonStyle, GUILayout.Width(100)))&#10;                {&#10;                    ClearPreviews();&#10;                }&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Performance Optimizations&#10;&#10;        private void CalculateVirtualization()&#10;        {&#10;            if (!_settings.enableVirtualization)&#10;            {&#10;                _virtualizedStartIndex = 0;&#10;                _virtualizedEndIndex = _filteredPrefabs.Count;&#10;                return;&#10;            }&#10;&#10;            float itemHeight = _settings.useGridView ? 140f : 80f;&#10;            float visibleHeight = position.height - 200f; // Account for UI elements&#10;            float scrollOffset = _scrollPosition.y;&#10;&#10;            int visibleStart = Mathf.Max(0, Mathf.FloorToInt(scrollOffset / itemHeight) - 5);&#10;            int visibleCount = Mathf.CeilToInt(visibleHeight / itemHeight) + 10;&#10;&#10;            _virtualizedStartIndex = visibleStart;&#10;            _virtualizedEndIndex = Mathf.Min(_filteredPrefabs.Count, visibleStart + visibleCount);&#10;        }&#10;&#10;        private List&lt;PrefabInfo&gt; GetVisiblePrefabs()&#10;        {&#10;            if (!_settings.enableVirtualization)&#10;                return _filteredPrefabs;&#10;&#10;            return _filteredPrefabs.GetRange(_virtualizedStartIndex, _virtualizedEndIndex - _virtualizedStartIndex);&#10;        }&#10;&#10;        private void ProcessPreviewQueue()&#10;        {&#10;            if (!_settings.enablePreviewCache || _isLoadingPreviews || _previewLoadQueue.Count == 0)&#10;                return;&#10;&#10;            _isLoadingPreviews = true;&#10;&#10;            // Process a few previews per frame&#10;            for (int i = 0; i &lt; 3 &amp;&amp; _previewLoadQueue.Count &gt; 0; i++)&#10;            {&#10;                GameObject prefab = _previewLoadQueue.Dequeue();&#10;                if (prefab != null &amp;&amp; !_previewCache.ContainsKey(prefab))&#10;                {&#10;                    Texture2D preview = AssetPreview.GetAssetPreview(prefab);&#10;                    if (preview != null)&#10;                    {&#10;                        _previewCache[prefab] = preview;&#10;                    }&#10;                    else&#10;                    {&#10;                        // Re-queue if preview not ready&#10;                        _previewLoadQueue.Enqueue(prefab);&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;&#10;            _isLoadingPreviews = false;&#10;&#10;            // Repaint if we processed any previews&#10;            if (_previewLoadQueue.Count % 10 == 0)&#10;            {&#10;                Repaint();&#10;            }&#10;        }&#10;&#10;        private void StartPreviewLoading()&#10;        {&#10;            if (!_settings.enablePreviewCache) return;&#10;&#10;            _previewLoadQueue.Clear();&#10;            foreach (PrefabInfo prefabInfo in _prefabInfos.Where(prefabInfo =&gt; prefabInfo.prefab &amp;&amp; !_previewCache.ContainsKey(prefabInfo.prefab)))&#10;            {&#10;                _previewLoadQueue.Enqueue(prefabInfo.prefab);&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Scene GUI Handling&#10;&#10;        private bool HandleRadialMenu(Event currentEvent, SceneView sceneView)&#10;        {&#10;            if (currentEvent.type == EventType.MouseDown &amp;&amp; currentEvent.button == 1)&#10;            {&#10;                _showRadialMenu = true;&#10;                _radialMenuPosition = currentEvent.mousePosition;&#10;                _radialMenuOpenTime = (float)EditorApplication.timeSinceStartup;&#10;                _hoveredRadialIndex = -1;&#10;                currentEvent.Use();&#10;                return true;&#10;            }&#10;&#10;            if (!_showRadialMenu) return false;&#10;&#10;            // Always update hover state when mouse is moving or during repaint&#10;            if (currentEvent.type is EventType.MouseMove or EventType.Repaint)&#10;            {&#10;                int newHoveredIndex = GetRadialMenuIndex(currentEvent.mousePosition);&#10;                if (newHoveredIndex != _hoveredRadialIndex)&#10;                {&#10;                    _hoveredRadialIndex = newHoveredIndex;&#10;                    sceneView.Repaint();&#10;                }&#10;            }&#10;&#10;            DrawRadialMenu();&#10;&#10;            if (currentEvent.type == EventType.MouseUp &amp;&amp; currentEvent.button == 1)&#10;            {&#10;                GameObject selectedPrefab = GetPrefabFromRadialMenu(currentEvent.mousePosition);&#10;                if (selectedPrefab != null)&#10;                {&#10;                    StartPlacementMode(selectedPrefab);&#10;                }&#10;&#10;                _showRadialMenu = false;&#10;                _hoveredRadialIndex = -1;&#10;                currentEvent.Use();&#10;                return true;&#10;            }&#10;&#10;            if (currentEvent.type == EventType.KeyDown &amp;&amp; currentEvent.keyCode == KeyCode.Escape)&#10;            {&#10;                _showRadialMenu = false;&#10;                _hoveredRadialIndex = -1;&#10;                currentEvent.Use();&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        private void HandlePlacementMode(Event currentEvent, SceneView sceneView)&#10;        {&#10;            if (!_placementMode || _selectedPrefabForPlacement == null) return;&#10;&#10;            int controlId = GUIUtility.GetControlID(FocusType.Passive);&#10;            HandleUtility.AddDefaultControl(controlId);&#10;&#10;            Vector3 worldPos = GetMouseWorldPosition(currentEvent);&#10;&#10;            if (currentEvent.shift &amp;&amp; _settings.pixelsPerUnit &gt; 0)&#10;            {&#10;                worldPos = SnapToGrid(worldPos);&#10;            }&#10;&#10;            if (currentEvent.type == EventType.MouseMove || currentEvent.type == EventType.Repaint)&#10;            {&#10;                DrawPlacementPreview(currentEvent.mousePosition, worldPos);&#10;                sceneView.Repaint();&#10;            }&#10;            else if (currentEvent.type == EventType.MouseDown &amp;&amp; currentEvent.button == 0)&#10;            {&#10;                PlacePrefabAtPosition(_selectedPrefabForPlacement, worldPos);&#10;                currentEvent.Use();&#10;            }&#10;            else if (currentEvent.type == EventType.KeyDown &amp;&amp; currentEvent.keyCode == KeyCode.Escape)&#10;            {&#10;                ExitPlacementMode();&#10;                currentEvent.Use();&#10;            }&#10;        }&#10;&#10;        private void DrawPlacementPreview(Vector2 mousePos, Vector3 worldPos)&#10;        {&#10;            // Get prefab bounds for accurate sizing&#10;            Bounds prefabBounds = GetPrefabBounds(_selectedPrefabForPlacement);&#10;            Vector3 worldSize = prefabBounds.size;&#10;            Vector3 pivotOffset = GetPrefabPivotOffset(_selectedPrefabForPlacement, prefabBounds);&#10;&#10;            // If bounds are too small or invalid, use default size&#10;            if (worldSize.magnitude &lt; 0.1f)&#10;            {&#10;                worldSize = Vector3.one * 0.5f;&#10;                pivotOffset = Vector3.zero;&#10;            }&#10;&#10;            // Scale the world size to compensate for asset preview padding BEFORE any calculations&#10;            // Unity's asset previews have internal padding, so we scale up the world size to compensate&#10;            worldSize *= 1.2f; // Scale up by 20% to account for internal padding&#10;&#10;            // Apply grid snapping to the preview position if enabled&#10;            Vector3 previewWorldPos = worldPos;&#10;            if (Event.current.shift &amp;&amp; _settings.pixelsPerUnit &gt; 0)&#10;            {&#10;                previewWorldPos = SnapToGrid(worldPos);&#10;            }&#10;&#10;            // Convert the snapped world position back to screen coordinates for the preview&#10;            Vector2 previewScreenPos = mousePos;&#10;            Camera sceneCamera = SceneView.lastActiveSceneView?.camera;&#10;            if (sceneCamera != null)&#10;            {&#10;                // For placement preview, we want to use the direct mouse position&#10;                // The world position calculation is for actual placement, not preview positioning&#10;                previewScreenPos = mousePos;&#10;            }&#10;&#10;            // Calculate accurate GUI preview size based on actual world size and camera&#10;            float screenSize = 80f; // Base size in pixels&#10;&#10;            if (sceneCamera != null)&#10;            {&#10;                if (sceneCamera.orthographic)&#10;                {&#10;                    // For orthographic camera, calculate screen size directly&#10;                    float orthographicSize = sceneCamera.orthographicSize;&#10;                    float screenHeight = SceneView.lastActiveSceneView.position.height;&#10;&#10;                    // Calculate pixels per world unit&#10;                    float pixelsPerWorldUnit = screenHeight / (orthographicSize * 2f);&#10;&#10;                    // Use the larger dimension of the sprite for accurate representation&#10;                    float largestWorldDimension = Mathf.Max(worldSize.x, worldSize.y, worldSize.z);&#10;                    screenSize = largestWorldDimension * pixelsPerWorldUnit;&#10;                }&#10;                else&#10;                {&#10;                    // For perspective camera, factor in distance&#10;                    float distance = Vector3.Distance(sceneCamera.transform.position, previewWorldPos);&#10;                    float fieldOfViewRad = sceneCamera.fieldOfView * Mathf.Deg2Rad;&#10;                    float screenHeight = SceneView.lastActiveSceneView.position.height;&#10;&#10;                    // Calculate how many world units fit in screen height at this distance&#10;                    float worldUnitsInScreenHeight = 2f * distance * Mathf.Tan(fieldOfViewRad * 0.5f);&#10;                    float pixelsPerWorldUnit = screenHeight / worldUnitsInScreenHeight;&#10;&#10;                    // Use the larger dimension of the sprite for accurate representation&#10;                    float largestWorldDimension = Mathf.Max(worldSize.x, worldSize.y, worldSize.z);&#10;                    screenSize = largestWorldDimension * pixelsPerWorldUnit;&#10;                }&#10;&#10;                // Clamp to reasonable bounds but allow larger sizes for bigger sprites&#10;                screenSize = Mathf.Clamp(screenSize, 20f, 400f);&#10;            }&#10;&#10;            // Get the prefab preview texture&#10;            Texture2D preview = GetPrefabPreview(_selectedPrefabForPlacement);&#10;&#10;            if (preview != null)&#10;            {&#10;                Handles.BeginGUI();&#10;&#10;                // Calculate preview rect centered on the snapped position with accurate size&#10;                Rect previewRect = new(&#10;                    previewScreenPos.x - screenSize * 0.5f,&#10;                    previewScreenPos.y - screenSize * 0.5f,&#10;                    screenSize,&#10;                    screenSize&#10;                );&#10;&#10;                // Draw the preview image with transparency support&#10;                Color originalColor = GUI.color;&#10;                GUI.color = new Color(1f, 1f, 1f, 1f); // Ensure full alpha for transparency&#10;                GUI.DrawTexture(previewRect, preview, ScaleMode.ScaleToFit, true); // Enable alpha blending&#10;                GUI.color = originalColor;&#10;&#10;                // Draw center crosshair for precise placement (use snapped position)&#10;                Vector2 center = previewScreenPos;&#10;                float crosshairSize = 6f;&#10;                Color crosshairColor = Color.red;&#10;                EditorGUI.DrawRect(new Rect(center.x - crosshairSize, center.y - 0.5f, crosshairSize * 2, 1),&#10;                    crosshairColor);&#10;&#10;                EditorGUI.DrawRect(new Rect(center.x - 0.5f, center.y - crosshairSize, 1, crosshairSize * 2),&#10;                    crosshairColor);&#10;&#10;                // Show prefab info below the preview&#10;                string infoText = _selectedPrefabForPlacement.name;&#10;                if (Event.current.shift &amp;&amp; _settings.pixelsPerUnit &gt; 0)&#10;                {&#10;                    infoText += &quot; (Grid Snap)&quot;;&#10;                }&#10;&#10;                // Add size info for debugging&#10;                infoText += $&quot; | Size: {worldSize.x:F1}x{worldSize.y:F1} | Screen: {screenSize:F0}px&quot;;&#10;&#10;                GUIContent infoContent = new(infoText);&#10;                Vector2 infoSize = EditorStyles.miniLabel.CalcSize(infoContent);&#10;                Rect infoRect = new(&#10;                    previewScreenPos.x - infoSize.x * 0.5f,&#10;                    previewRect.y + previewRect.height + 5,&#10;                    infoSize.x,&#10;                    infoSize.y&#10;                );&#10;&#10;                Color backgroundColor = new(0, 0, 0, 0.7f);&#10;                // Draw info background&#10;                EditorGUI.DrawRect(new Rect(infoRect.x - 2, infoRect.y - 1, infoRect.width + 4, infoRect.height + 2),&#10;                    backgroundColor);&#10;&#10;                // Draw info text&#10;                GUI.Label(infoRect, infoContent, EditorStyles.miniLabel);&#10;&#10;                Handles.EndGUI();&#10;            }&#10;&#10;            // Grid snap visualization (using the snapped world position)&#10;            if (Event.current.shift &amp;&amp; _settings.pixelsPerUnit &gt; 0)&#10;            {&#10;                Handles.color = Color.yellow;&#10;                float gridSize = 1.0f / _settings.pixelsPerUnit;&#10;&#10;                // Draw snap grid around cursor&#10;                for (int i = -1; i &lt;= 1; i++)&#10;                {&#10;                    for (int j = -1; j &lt;= 1; j++)&#10;                    {&#10;                        Vector3 gridPoint = previewWorldPos + new Vector3(i * gridSize, j * gridSize, 0);&#10;                        Handles.DrawWireCube(gridPoint, Vector3.one * gridSize * 0.2f);&#10;                    }&#10;                }&#10;            }&#10;&#10;            Handles.color = Color.white;&#10;        }&#10;&#10;        private Bounds GetPrefabBounds(GameObject prefab)&#10;        {&#10;            if (prefab == null) return new Bounds();&#10;&#10;            // Try to get bounds from renderers&#10;            var renderers = prefab.GetComponentsInChildren&lt;Renderer&gt;();&#10;            if (renderers != null &amp;&amp; renderers.Length &gt; 0)&#10;            {&#10;                Bounds bounds = renderers[0].bounds;&#10;                foreach (Renderer renderer in renderers)&#10;                {&#10;                    bounds.Encapsulate(renderer.bounds);&#10;                }&#10;&#10;                return bounds;&#10;            }&#10;&#10;            // Try to get bounds from colliders&#10;            var colliders = prefab.GetComponentsInChildren&lt;Collider&gt;();&#10;            if (colliders != null &amp;&amp; colliders.Length &gt; 0)&#10;            {&#10;                Bounds bounds = colliders[0].bounds;&#10;                foreach (Collider collider in colliders)&#10;                {&#10;                    bounds.Encapsulate(collider.bounds);&#10;                }&#10;&#10;                return bounds;&#10;            }&#10;&#10;            // Try to get bounds from colliders 2D&#10;            var colliders2D = prefab.GetComponentsInChildren&lt;Collider2D&gt;();&#10;            if (colliders2D is { Length: &gt; 0 })&#10;            {&#10;                Bounds bounds = colliders2D[0].bounds;&#10;                foreach (Collider2D collider in colliders2D)&#10;                {&#10;                    bounds.Encapsulate(collider.bounds);&#10;                }&#10;&#10;                return bounds;&#10;            }&#10;&#10;            // Fallback to transform bounds&#10;            return new Bounds(prefab.transform.position, Vector3.one);&#10;        }&#10;&#10;        private Vector3 GetPrefabPivotOffset(GameObject prefab, Bounds bounds)&#10;        {&#10;            if (prefab == null) return Vector3.zero;&#10;&#10;            // For 2D sprites, we need to consider the sprite's pivot settings&#10;            SpriteRenderer spriteRenderer = prefab.GetComponent&lt;SpriteRenderer&gt;();&#10;            if (spriteRenderer != null &amp;&amp; spriteRenderer.sprite != null)&#10;            {&#10;                Sprite sprite = spriteRenderer.sprite;&#10;&#10;                // Get the sprite's pivot in normalized coordinates (0-1)&#10;                Vector2 spritePivot = sprite.pivot;&#10;                Vector2 spriteSize = sprite.rect.size;&#10;                Vector2 normalizedPivot = new(spritePivot.x / spriteSize.x, spritePivot.y / spriteSize.y);&#10;&#10;                // Calculate the offset from center to pivot in world space&#10;                // This offset should move the preview so the pivot point is at the mouse cursor&#10;                Vector3 spriteOffset = new(&#10;                    (normalizedPivot.x - 0.5f) * bounds.size.x,&#10;                    (normalizedPivot.y - 0.5f) * bounds.size.y,&#10;                    0f&#10;                );&#10;&#10;                return spriteOffset;&#10;            }&#10;&#10;            // For non-sprite objects, calculate offset from bounds center to transform position&#10;            Vector3 pivotPosition = prefab.transform.position;&#10;            Vector3 pivotOffset = pivotPosition - bounds.center;&#10;            return pivotOffset;&#10;        }&#10;&#10;        private void DrawRadialMenu()&#10;        {&#10;            Handles.BeginGUI();&#10;&#10;            Vector2 center = _radialMenuPosition;&#10;            float elapsedTime = (float)EditorApplication.timeSinceStartup - _radialMenuOpenTime;&#10;            float growProgress = Mathf.Clamp01(elapsedTime / RadialMenuAnimationTime);&#10;            float radius = RadialMenuRadius * Mathf.SmoothStep(0, 1, growProgress);&#10;&#10;            // Background with gradient&#10;            Handles.color = new Color(0.1f, 0.1f, 0.1f, 0.9f);&#10;            Handles.DrawSolidDisc(center, Vector3.forward, radius);&#10;            Handles.color = new Color(0.3f, 0.3f, 0.3f, 0.8f);&#10;            Handles.DrawWireDisc(center, Vector3.forward, radius);&#10;            Handles.color = Color.white;&#10;&#10;            var prefabsToShow = _frequentPrefabs.Count &gt; 0&#10;                ? _frequentPrefabs&#10;                : _filteredPrefabs.Take(MaxFrequentPrefabs).Select(p =&gt; p.prefab).ToList();&#10;&#10;            int prefabCount = Mathf.Min(prefabsToShow.Count, MaxFrequentPrefabs);&#10;&#10;            for (int i = 0; i &lt; prefabCount; i++)&#10;            {&#10;                GameObject prefab = prefabsToShow[i];&#10;                if (prefab == null) continue;&#10;&#10;                float angle = i / (float)prefabCount * 360f - 90f;&#10;                Vector2 direction = new(Mathf.Cos(angle * Mathf.Deg2Rad), Mathf.Sin(angle * Mathf.Deg2Rad));&#10;                Vector2 itemPos = center + direction * (radius * 0.75f);&#10;&#10;                bool isHovered = i == _hoveredRadialIndex;&#10;                float iconSize = isHovered ? 55f : 45f;&#10;&#10;                // Enhanced highlighting for hovered item&#10;                if (isHovered)&#10;                {&#10;                    // Draw pulsing highlight background&#10;                    float pulseScale = 1f + Mathf.Sin((float)EditorApplication.timeSinceStartup * 8f) * 0.1f;&#10;                    Handles.color = new Color(0, 1, 1, 0.6f); // Cyan with transparency&#10;                    Handles.DrawSolidDisc(itemPos, Vector3.forward, iconSize * 0.7f * pulseScale);&#10;&#10;                    // Draw bright border&#10;                    Handles.color = Color.cyan;&#10;                    Handles.DrawWireDisc(itemPos, Vector3.forward, iconSize * 0.7f);&#10;                    Handles.color = Color.white;&#10;&#10;                    // Show enhanced name display&#10;                    GUIContent nameContent = new(prefab.name);&#10;                    Vector2 nameSize = EditorStyles.boldLabel.CalcSize(nameContent);&#10;                    Rect nameRect = new(&#10;                        center.x - nameSize.x * 0.5f,&#10;                        center.y + radius + 10,&#10;                        nameSize.x,&#10;                        nameSize.y&#10;                    );&#10;&#10;                    // Draw name background&#10;                    EditorGUI.DrawRect(&#10;                        new Rect(nameRect.x - 4, nameRect.y - 2, nameRect.width + 8, nameRect.height + 4),&#10;                        new Color(0, 0, 0, 0.8f));&#10;&#10;                    // Draw name with highlight color&#10;                    GUI.color = Color.cyan;&#10;                    GUI.Label(nameRect, nameContent, EditorStyles.boldLabel);&#10;                    GUI.color = Color.white;&#10;                }&#10;                else&#10;                {&#10;                    // Subtle highlight for non-hovered items&#10;                    Handles.color = new Color(0.4f, 0.4f, 0.4f, 0.3f);&#10;                    Handles.DrawSolidDisc(itemPos, Vector3.forward, iconSize * 0.6f);&#10;                    Handles.color = Color.white;&#10;                }&#10;&#10;                // Draw icon rect&#10;                Rect iconRect = new(&#10;                    itemPos.x - iconSize * 0.5f,&#10;                    itemPos.y - iconSize * 0.5f,&#10;                    iconSize,&#10;                    iconSize&#10;                );&#10;&#10;                // Draw preview with enhanced border for hovered items&#10;                Texture2D preview = GetPrefabPreview(prefab);&#10;                if (preview != null)&#10;                {&#10;                    if (isHovered)&#10;                    {&#10;                        // Draw glowing border for hovered item&#10;                        Rect borderRect = new(iconRect.x - 2, iconRect.y - 2, iconRect.width + 4, iconRect.height + 4);&#10;                        EditorGUI.DrawRect(borderRect, Color.cyan);&#10;                    }&#10;&#10;                    GUI.DrawTexture(iconRect, preview, ScaleMode.ScaleToFit);&#10;                }&#10;                else&#10;                {&#10;                    // Draw placeholder with proper highlighting&#10;                    Color placeholderColor = isHovered ? new Color(0.6f, 0.6f, 0.6f) : new Color(0.3f, 0.3f, 0.3f);&#10;                    EditorGUI.DrawRect(iconRect, placeholderColor);&#10;&#10;                    // Draw loading text&#10;                    GUI.color = isHovered ? Color.white : Color.gray;&#10;                    GUI.Label(iconRect, &quot;...&quot;, EditorStyles.centeredGreyMiniLabel);&#10;                    GUI.color = Color.white;&#10;                }&#10;            }&#10;&#10;            Handles.EndGUI();&#10;        }&#10;&#10;        private GameObject GetPrefabFromRadialMenu(Vector2 mousePosition)&#10;        {&#10;            int index = GetRadialMenuIndex(mousePosition);&#10;            if (index &lt; 0) return null;&#10;&#10;            var prefabsToShow = _frequentPrefabs.Count &gt; 0&#10;                ? _frequentPrefabs&#10;                : _filteredPrefabs.Take(MaxFrequentPrefabs).Select(p =&gt; p.prefab).ToList();&#10;&#10;            return index &lt; prefabsToShow.Count ? prefabsToShow[index] : null;&#10;        }&#10;&#10;        private int GetRadialMenuIndex(Vector2 mousePosition)&#10;        {&#10;            float distance = Vector2.Distance(mousePosition, _radialMenuPosition);&#10;            if (distance &lt; 20 || distance &gt; RadialMenuRadius * 0.9f) return -1; // Improved hit detection&#10;&#10;            var prefabsToShow = _frequentPrefabs.Count &gt; 0&#10;                ? _frequentPrefabs&#10;                : _filteredPrefabs.Take(MaxFrequentPrefabs).Select(p =&gt; p.prefab).ToList();&#10;&#10;            int prefabCount = Mathf.Min(prefabsToShow.Count, MaxFrequentPrefabs);&#10;            if (prefabCount == 0) return -1;&#10;&#10;            // Improved angle calculation for better selection accuracy&#10;            Vector2 direction = (mousePosition - _radialMenuPosition).normalized;&#10;            float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;&#10;&#10;            // Normalize angle to 0-360 range and adjust for starting at top&#10;            angle = (angle + 90f + 360f) % 360f;&#10;&#10;            float segmentAngle = 360f / prefabCount;&#10;            int index = Mathf.FloorToInt((angle + segmentAngle * 0.5f) / segmentAngle) % prefabCount;&#10;&#10;            return index;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Core Logic&#10;&#10;        private void StartPlacementMode(GameObject prefab)&#10;        {&#10;            if (!prefab) return;&#10;&#10;            _placementMode = true;&#10;            _selectedPrefabForPlacement = prefab;&#10;            IncrementPrefabUsage(prefab);&#10;            GUI.FocusControl(null);&#10;&#10;            Debug.Log($&quot;Started placement mode for: {prefab.name}&quot;);&#10;        }&#10;&#10;        private void ExitPlacementMode()&#10;        {&#10;            _placementMode = false;&#10;            _selectedPrefabForPlacement = null;&#10;            Debug.Log(&quot;Exited placement mode&quot;);&#10;        }&#10;&#10;        private void PlacePrefabAtPosition(GameObject prefab, Vector3 placePosition)&#10;        {&#10;            if (!prefab) return;&#10;&#10;            try&#10;            {&#10;                Undo.IncrementCurrentGroup();&#10;                GameObject instance = (GameObject)PrefabUtility.InstantiatePrefab(prefab);&#10;                Undo.RegisterCreatedObjectUndo(instance, $&quot;Place {prefab.name}&quot;);&#10;                instance.transform.position = placePosition;&#10;                Selection.activeGameObject = instance;&#10;&#10;                Debug.Log($&quot;Placed {prefab.name} at {placePosition}&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to place prefab {prefab.name}: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private Vector3 GetMouseWorldPosition(Event e)&#10;        {&#10;            Ray ray = HandleUtility.GUIPointToWorldRay(e.mousePosition);&#10;            Plane plane = new(Vector3.forward, Vector3.zero);&#10;&#10;            if (plane.Raycast(ray, out float distance))&#10;            {&#10;                return ray.GetPoint(distance);&#10;            }&#10;&#10;            return ray.origin;&#10;        }&#10;&#10;        private Vector3 SnapToGrid(Vector3 snapPosition)&#10;        {&#10;            if (_settings.pixelsPerUnit &lt;= 0) return snapPosition;&#10;&#10;            float ppu = _settings.pixelsPerUnit;&#10;            snapPosition.x = Mathf.Round(snapPosition.x * ppu) / ppu;&#10;            snapPosition.y = Mathf.Round(snapPosition.y * ppu) / ppu;&#10;            snapPosition.z = 0;&#10;&#10;            return snapPosition;&#10;        }&#10;&#10;        private void HandleKeyboardShortcuts()&#10;        {&#10;            Event e = Event.current;&#10;            if (e.type != EventType.KeyDown) return;&#10;&#10;            if (e.control || e.command)&#10;            {&#10;                switch (e.keyCode)&#10;                {&#10;                    case KeyCode.F:&#10;                        GUI.FocusControl(&quot;SearchField&quot;);&#10;                        e.Use();&#10;                        break;&#10;                    case KeyCode.R:&#10;                        LoadPrefabs();&#10;                        e.Use();&#10;                        break;&#10;                    case KeyCode.Escape:&#10;                        if (_placementMode)&#10;                        {&#10;                            ExitPlacementMode();&#10;                            e.Use();&#10;                        }&#10;&#10;                        break;&#10;                }&#10;            }&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Data Management&#10;&#10;        private void LoadPrefabs()&#10;        {&#10;            try&#10;            {&#10;                _prefabInfos.Clear();&#10;&#10;                if (!AssetDatabase.IsValidFolder(PrefabFolderPath))&#10;                {&#10;                    Debug.LogWarning($&quot;Prefab folder not found: {PrefabFolderPath}&quot;);&#10;                    return;&#10;                }&#10;&#10;                string[] guids = AssetDatabase.FindAssets(&quot;t:Prefab&quot;, new[] { PrefabFolderPath });&#10;&#10;                for (int i = 0; i &lt; guids.Length; i++)&#10;                {&#10;                    string guid = guids[i];&#10;                    string path = AssetDatabase.GUIDToAssetPath(guid);&#10;                    GameObject prefab = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);&#10;&#10;                    if (prefab != null)&#10;                    {&#10;                        _prefabInfos.Add(new PrefabInfo(prefab));&#10;                    }&#10;&#10;                    // Show progress for large collections&#10;                    if (i % 50 == 0)&#10;                    {&#10;                        EditorUtility.DisplayProgressBar(&quot;Loading Prefabs&quot;, $&quot;Processing {i}/{guids.Length}&quot;,&#10;                            (float)i / guids.Length);&#10;                    }&#10;                }&#10;&#10;                EditorUtility.ClearProgressBar();&#10;&#10;                ApplyFilters();&#10;                StartPreviewLoading();&#10;&#10;                Debug.Log($&quot;Loaded {_prefabInfos.Count} prefabs from {PrefabFolderPath}&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                EditorUtility.ClearProgressBar();&#10;                Debug.LogError($&quot;Failed to load prefabs: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ApplyFilters()&#10;        {&#10;            try&#10;            {&#10;                _filteredPrefabs.Clear();&#10;                string searchLower = _settings.searchFilter.ToLowerInvariant();&#10;&#10;                foreach (PrefabInfo prefabInfo in _prefabInfos)&#10;                {&#10;                    if (!prefabInfo.isValid || prefabInfo.prefab == null) continue;&#10;&#10;                    // Search filter&#10;                    if (!string.IsNullOrEmpty(_settings.searchFilter) &amp;&amp;&#10;                        !prefabInfo.name.ToLowerInvariant().Contains(searchLower))&#10;                    {&#10;                        continue;&#10;                    }&#10;&#10;                    // Category filter&#10;                    if (MatchesFilter(prefabInfo))&#10;                    {&#10;                        _filteredPrefabs.Add(prefabInfo);&#10;                    }&#10;                }&#10;&#10;                // Sort by usage frequency and name&#10;                _filteredPrefabs.Sort((a, b) =&gt;&#10;                {&#10;                    int usageA = _prefabUsageCount.GetValueOrDefault(a.prefab, 0);&#10;                    int usageB = _prefabUsageCount.GetValueOrDefault(b.prefab, 0);&#10;&#10;                    if (usageA != usageB)&#10;                        return usageB.CompareTo(usageA);&#10;&#10;                    return string.Compare(a.name, b.name, StringComparison.OrdinalIgnoreCase);&#10;                });&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to apply filters: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private bool MatchesFilter(PrefabInfo prefabInfo)&#10;        {&#10;            return _settings.filterType switch&#10;            {&#10;                FilterType.All =&gt; true,&#10;                FilterType.Enemies =&gt; prefabInfo.category == FilterType.Enemies,&#10;                FilterType.Containers =&gt; prefabInfo.category == FilterType.Containers,&#10;                FilterType.Others =&gt; prefabInfo.category == FilterType.Others,&#10;                _ =&gt; true&#10;            };&#10;        }&#10;&#10;        private void LoadUsageData()&#10;        {&#10;            try&#10;            {&#10;                _prefabUsageCount.Clear();&#10;                string data = EditorPrefs.GetString(UsageDataKey, &quot;&quot;);&#10;                if (string.IsNullOrEmpty(data)) return;&#10;&#10;                foreach (string entry in data.Split(';'))&#10;                {&#10;                    if (string.IsNullOrEmpty(entry)) continue;&#10;&#10;                    string[] parts = entry.Split(':');&#10;                    if (parts.Length != 2) continue;&#10;&#10;                    string path = AssetDatabase.GUIDToAssetPath(parts[0]);&#10;                    if (string.IsNullOrEmpty(path)) continue;&#10;&#10;                    GameObject prefab = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);&#10;                    if (prefab != null &amp;&amp; int.TryParse(parts[1], out int count))&#10;                    {&#10;                        _prefabUsageCount[prefab] = count;&#10;                    }&#10;                }&#10;&#10;                UpdateFrequentPrefabs();&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to load usage data: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SaveUsageData()&#10;        {&#10;            try&#10;            {&#10;                var validEntries = _prefabUsageCount&#10;                    .Where(kvp =&gt; kvp.Key != null &amp;&amp; AssetDatabase.Contains(kvp.Key))&#10;                    .Select(kvp =&gt;&#10;                    {&#10;                        string path = AssetDatabase.GetAssetPath(kvp.Key);&#10;                        string guid = AssetDatabase.AssetPathToGUID(path);&#10;                        return $&quot;{guid}:{kvp.Value}&quot;;&#10;                    });&#10;&#10;                string data = string.Join(&quot;;&quot;, validEntries);&#10;                EditorPrefs.SetString(UsageDataKey, data);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to save usage data: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private void LoadSettings()&#10;        {&#10;            try&#10;            {&#10;                string json = EditorPrefs.GetString(SettingsKey, &quot;&quot;);&#10;                if (!string.IsNullOrEmpty(json))&#10;                {&#10;                    _settings = JsonUtility.FromJson&lt;WindowSettings&gt;(json);&#10;                }&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to load settings: {e.Message}&quot;);&#10;                _settings = new WindowSettings();&#10;            }&#10;        }&#10;&#10;        private void SaveSettings()&#10;        {&#10;            try&#10;            {&#10;                string json = JsonUtility.ToJson(_settings);&#10;                EditorPrefs.SetString(SettingsKey, json);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;Failed to save settings: {e.Message}&quot;);&#10;            }&#10;        }&#10;&#10;        private void IncrementPrefabUsage(GameObject prefab)&#10;        {&#10;            if (prefab == null) return;&#10;&#10;            _prefabUsageCount.TryGetValue(prefab, out int count);&#10;            _prefabUsageCount[prefab] = count + 1;&#10;&#10;            UpdateFrequentPrefabs();&#10;            EditorApplication.delayCall += SaveUsageData;&#10;        }&#10;&#10;        private void UpdateFrequentPrefabs()&#10;        {&#10;            _frequentPrefabs.Clear();&#10;            var sortedPrefabs = _prefabUsageCount&#10;                .Where(kvp =&gt; kvp.Key != null)&#10;                .OrderByDescending(kvp =&gt; kvp.Value)&#10;                .Take(MaxFrequentPrefabs)&#10;                .Select(kvp =&gt; kvp.Key);&#10;&#10;            _frequentPrefabs.AddRange(sortedPrefabs);&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Preview System&#10;&#10;        private Texture2D GetPrefabPreview(GameObject prefab)&#10;        {&#10;            if (prefab == null) return null;&#10;&#10;            // Check cache first&#10;            if (_settings.enablePreviewCache &amp;&amp; _previewCache.TryGetValue(prefab, out Texture2D cachedPreview))&#10;            {&#10;                // Validate cached preview is still valid&#10;                if (cachedPreview != null &amp;&amp; !AssetPreview.IsLoadingAssetPreview(prefab.GetInstanceID()))&#10;                {&#10;                    return cachedPreview;&#10;                }&#10;&#10;                // Remove invalid cache entry&#10;                _previewCache.Remove(prefab);&#10;            }&#10;&#10;            // Try to get preview from Unity's AssetPreview system&#10;            Texture2D preview = AssetPreview.GetAssetPreview(prefab);&#10;&#10;            if (preview != null)&#10;            {&#10;                // Process the preview to make background transparent&#10;                Texture2D processedPreview = MakePreviewTransparent(preview);&#10;&#10;                // Cache the processed preview&#10;                if (_settings.enablePreviewCache)&#10;                {&#10;                    _previewCache[prefab] = processedPreview;&#10;                }&#10;&#10;                return processedPreview;&#10;            }&#10;&#10;            // If no preview available, check if it's still loading&#10;            if (AssetPreview.IsLoadingAssetPreview(prefab.GetInstanceID()))&#10;            {&#10;                // Force refresh to potentially generate preview&#10;                AssetPreview.GetAssetPreview(prefab);&#10;&#10;                // Queue for later retry if not already queued&#10;                if (_settings.enablePreviewCache &amp;&amp; !_previewLoadQueue.Contains(prefab))&#10;                {&#10;                    _previewLoadQueue.Enqueue(prefab);&#10;                }&#10;&#10;                return null;&#10;            }&#10;&#10;            // Try to generate a mini preview from the prefab's renderer&#10;            return GenerateCustomPreview(prefab);&#10;        }&#10;&#10;        private Texture2D MakePreviewTransparent(Texture2D originalTexture)&#10;        {&#10;            if (originalTexture == null) return null;&#10;&#10;            try&#10;            {&#10;                // Create a new readable texture&#10;                Texture2D readableTexture =&#10;                    new(originalTexture.width, originalTexture.height, TextureFormat.RGBA32, false);&#10;&#10;                // Create a RenderTexture to copy the original texture&#10;                RenderTexture renderTexture = RenderTexture.GetTemporary(originalTexture.width, originalTexture.height,&#10;                    0, RenderTextureFormat.ARGB32);&#10;&#10;                Graphics.Blit(originalTexture, renderTexture);&#10;&#10;                // Read the pixels from the RenderTexture&#10;                RenderTexture.active = renderTexture;&#10;                readableTexture.ReadPixels(new Rect(0, 0, originalTexture.width, originalTexture.height), 0, 0);&#10;                readableTexture.Apply();&#10;                RenderTexture.active = null;&#10;                RenderTexture.ReleaseTemporary(renderTexture);&#10;&#10;                // Process pixels to make background transparent&#10;                var pixels = readableTexture.GetPixels();&#10;                Color backgroundColor = pixels[0]; // Assume top-left corner is background&#10;&#10;                for (int i = 0; i &lt; pixels.Length; i++)&#10;                {&#10;                    Color pixel = pixels[i];&#10;&#10;                    // If pixel is very similar to background color, make it transparent&#10;                    float colorDistance = Vector3.Distance(&#10;                        new Vector3(pixel.r, pixel.g, pixel.b),&#10;                        new Vector3(backgroundColor.r, backgroundColor.g, backgroundColor.b)&#10;                    );&#10;&#10;                    if (colorDistance &lt; 0.1f) // Threshold for background detection&#10;                    {&#10;                        pixels[i] = new Color(pixel.r, pixel.g, pixel.b, 0f); // Make transparent&#10;                    }&#10;                    else&#10;                    {&#10;                        // Keep original alpha or make slightly transparent for blending&#10;                        pixels[i] = new Color(pixel.r, pixel.g, pixel.b, pixel.a * 0.9f);&#10;                    }&#10;                }&#10;&#10;                readableTexture.SetPixels(pixels);&#10;                readableTexture.Apply();&#10;&#10;                return readableTexture;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogWarning($&quot;Failed to make preview transparent: {e.Message}&quot;);&#10;                return originalTexture; // Return original if processing fails&#10;            }&#10;        }&#10;&#10;        private Texture2D GenerateCustomPreview(GameObject prefab)&#10;        {&#10;            try&#10;            {&#10;                // Get all renderers in the prefab&#10;                var renderers = prefab.GetComponentsInChildren&lt;Renderer&gt;();&#10;                if (renderers == null || renderers.Length == 0)&#10;                    return null;&#10;&#10;                // Create a simple colored texture based on the prefab's main material&#10;                Renderer mainRenderer = renderers[0];&#10;                if (mainRenderer.sharedMaterial != null)&#10;                {&#10;                    Color materialColor = Color.white;&#10;&#10;                    // Try to get color from various shader properties&#10;                    Material material = mainRenderer.sharedMaterial;&#10;                    if (material.HasProperty(Color1))&#10;                    {&#10;                        materialColor = material.GetColor(Color1);&#10;                    }&#10;                    else if (material.HasProperty(BaseColor))&#10;                    {&#10;                        materialColor = material.GetColor(BaseColor);&#10;                    }&#10;                    else if (material.HasProperty(MainTex) &amp;&amp; material.mainTexture)&#10;                    {&#10;                        // Use a sample from the main texture&#10;                        Texture2D texture = material.mainTexture as Texture2D;&#10;                        if (texture &amp;&amp; texture.isReadable)&#10;                        {&#10;                            materialColor = texture.GetPixel(texture.width / 2, texture.height / 2);&#10;                        }&#10;                    }&#10;&#10;                    // Create a simple 64x64 preview texture&#10;                    Texture2D customPreview = new(64, 64, TextureFormat.RGBA32, false);&#10;                    var pixels = new Color[64 * 64];&#10;&#10;                    // Create a simple gradient/pattern&#10;                    for (int y = 0; y &lt; 64; y++)&#10;                    {&#10;                        for (int x = 0; x &lt; 64; x++)&#10;                        {&#10;                            float distance = Vector2.Distance(new Vector2(x, y), new Vector2(32, 32));&#10;                            float alpha = Mathf.Clamp01(1.0f - distance / 32.0f);&#10;                            pixels[y * 64 + x] = new Color(materialColor.r, materialColor.g, materialColor.b,&#10;                                alpha * materialColor.a);&#10;                        }&#10;                    }&#10;&#10;                    customPreview.SetPixels(pixels);&#10;                    customPreview.Apply();&#10;&#10;                    // Cache the custom preview&#10;                    if (_settings.enablePreviewCache)&#10;                    {&#10;                        _previewCache[prefab] = customPreview;&#10;                    }&#10;&#10;                    return customPreview;&#10;                }&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogWarning($&quot;Failed to generate custom preview for {prefab.name}: {e.Message}&quot;);&#10;            }&#10;&#10;            return null;&#10;        }&#10;&#10;        private void ClearPreviews()&#10;        {&#10;            foreach (Texture2D preview in _previewCache.Values)&#10;            {&#10;                if (preview != null)&#10;                {&#10;                    DestroyImmediate(preview);&#10;                }&#10;            }&#10;&#10;            _previewCache.Clear();&#10;            _previewLoadQueue.Clear();&#10;        }&#10;&#10;        private void RefreshPreviewCache()&#10;        {&#10;            // Clear existing cache&#10;            ClearPreviews();&#10;&#10;            // Restart preview loading&#10;            StartPreviewLoading();&#10;&#10;            // Force repaint&#10;        }&#10;&#10;        #endregion&#10;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scenes/LevelsTemplatePipeline.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scenes/LevelsTemplatePipeline.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using UnityEditor.SceneTemplate;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;&#10;public class LevelsTemplatePipeline : ISceneTemplatePipeline&#10;{&#10;    public virtual bool IsValidTemplateForInstantiation(SceneTemplateAsset sceneTemplateAsset)&#10;    {&#10;        return true;&#10;    }&#10;&#10;    public virtual void BeforeTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, bool isAdditive, string sceneName)&#10;    {&#10;        &#10;    }&#10;&#10;    public virtual void AfterTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, Scene scene, bool isAdditive, string sceneName)&#10;    {&#10;        var sceneFolder = System.IO.Path.Combine(&quot;Assets&quot;, &quot;Scenes&quot;);&#10;        var sceneFiles = System.IO.Directory.GetFiles(sceneFolder, &quot;Level*.unity&quot;);&#10;        int levelPrefixLength = &quot;Level&quot;.Length;&#10;        int maxLevel = sceneFiles&#10;            .Select(System.IO.Path.GetFileNameWithoutExtension)&#10;            .Where(fileName =&gt; fileName.StartsWith(&quot;Level&quot;))&#10;            .Select(fileName =&gt; int.TryParse(fileName[levelPrefixLength..], out int num) ? num : 0)&#10;            .DefaultIfEmpty(0)&#10;            .Max();&#10;        string newLevelName = $&quot;Level{maxLevel + 1}&quot;;&#10;        scene.name = newLevelName;&#10;        SceneManager.SetActiveScene(scene);&#10;        Debug.Log($&quot;[LevelsTemplatePipeline] Instantiated new level: {newLevelName}&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Linq;&#10;using UnityEditor.SceneTemplate;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;&#10;public class LevelsTemplatePipeline : ISceneTemplatePipeline&#10;{&#10;    public virtual bool IsValidTemplateForInstantiation(SceneTemplateAsset sceneTemplateAsset)&#10;    {&#10;        return true;&#10;    }&#10;&#10;    public virtual void BeforeTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, bool isAdditive, string sceneName)&#10;    {&#10;        &#10;    }&#10;&#10;    public virtual void AfterTemplateInstantiation(SceneTemplateAsset sceneTemplateAsset, Scene scene, bool isAdditive, string sceneName)&#10;    {&#10;        var sceneFolder = System.IO.Path.Combine(&quot;Assets&quot;, &quot;Scenes&quot;);&#10;        var sceneFiles = System.IO.Directory.GetFiles(sceneFolder, &quot;Level*.unity&quot;);&#10;        int levelPrefixLength = &quot;Level&quot;.Length;&#10;        int maxLevel = sceneFiles&#10;            .Select(System.IO.Path.GetFileNameWithoutExtension)&#10;            .Where(fileName =&gt; fileName.StartsWith(&quot;Level&quot;))&#10;            .Select(fileName =&gt; int.TryParse(fileName[levelPrefixLength..], out int num) ? num : 0)&#10;            .DefaultIfEmpty(0)&#10;            .Max();&#10;        string newLevelName = $&quot;Level{maxLevel + 1}&quot;;&#10;        scene.name = newLevelName;&#10;        SceneManager.SetActiveScene(scene);&#10;        Debug.Log($&quot;[LevelsTemplatePipeline] Instantiated new level: {newLevelName}&quot;);&#10;&#10;        // Show save file dialog with the new scene name as default&#10;#if UNITY_EDITOR&#10;        string savePath = UnityEditor.EditorUtility.SaveFilePanel(&#10;            &quot;Save New Scene&quot;,&#10;            sceneFolder,&#10;            newLevelName,&#10;            &quot;unity&quot;&#10;        );&#10;        if (!string.IsNullOrEmpty(savePath))&#10;        {&#10;            UnityEditor.SceneManagement.EditorSceneManager.SaveScene(scene, savePath);&#10;            Debug.Log($&quot;[LevelsTemplatePipeline] Scene saved to: {savePath}&quot;);&#10;        }&#10;#endif&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/ScoreCollectionTracker.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Collectables/Score/ScoreCollectionTracker.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Events/GameEvents.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Events/GameEvents.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Core.Events&#10;{&#10;    public enum GameState&#10;    {&#10;        MainMenu,&#10;        Loading,&#10;        Playing,&#10;        Paused,&#10;        GameOver,&#10;        Victory,&#10;        Restarting&#10;    }&#10;&#10;    public struct GameStateChangedEvent&#10;    {&#10;        public GameState PreviousState;&#10;        public GameState NewState;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerHealthChangedEvent&#10;    {&#10;        public int CurrentHp;&#10;        public int MaxHp;&#10;        public int Damage;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerLivesChangedEvent&#10;    {&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Core.Events&#10;{&#10;    public enum GameState&#10;    {&#10;        MainMenu,&#10;        Loading,&#10;        Playing,&#10;        Paused,&#10;        GameOver,&#10;        Victory,&#10;        Restarting&#10;    }&#10;&#10;    public struct GameStateChangedEvent&#10;    {&#10;        public GameState PreviousState;&#10;        public GameState NewState;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerHealthChangedEvent&#10;    {&#10;        public int CurrentHp;&#10;        public int MaxHp;&#10;        public int Damage;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct PlayerLivesChangedEvent&#10;    {&#10;        public int PreviousLives;&#10;        public int CurrentLives;&#10;        public int MaxLives;&#10;        public float Timestamp;&#10;    }&#10;&#10;    public struct ScoreChangedEvent&#10;    {&#10;        public Vector3 Position;&#10;        public int ScoreAmount; // Delta amount&#10;        public int TotalScore; // Overall score&#10;    }&#10;&#10;    // Base event structure for consistency&#10;    public interface IGameEvent&#10;    {&#10;        float Timestamp { get; }&#10;    }&#10;&#10;    public struct PlayerDeathEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public Vector3 DeathPosition;&#10;    }&#10;&#10;    public struct LevelStartedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;    }&#10;&#10;    public struct LevelCompletedEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;        public string LevelName;&#10;        public float CompletionTime;&#10;    }&#10;&#10;&#10;    public struct GameOverEvent : IGameEvent&#10;    {&#10;        public float Timestamp { get; set; }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/FrogProximityJump.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/FrogProximityJump.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using Player.Components;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Emits an event when the player is within a certain distance&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class FrogProximityTrigger : MonoBehaviour, ITrigger&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float triggerDistance = 3f;&#10;        [SerializeField] private float jumpCooldown = 2f;&#10;        [SerializeField] private int checkEveryNFrames = 1;&#10;&#10;        private int _frameCounter;&#10;        private bool _grounded;&#10;        private float _lastTriggerTime;&#10;        private Transform _player;&#10;&#10;        private void Start()&#10;        {&#10;            _player = PlayerLocator.PlayerTransform;&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public bool IsTriggered { get; private set; }&#10;&#10;        public void CheckTrigger()&#10;        {&#10;            if (++_frameCounter % checkEveryNFrames != 0 || !_player) return;&#10;&#10;            Vector2 toPlayer = _player.position - transform.position;&#10;            float sqrDist = toPlayer.sqrMagnitude;&#10;            float sqrTrigger = triggerDistance * triggerDistance;&#10;&#10;            if (sqrDist &lt; sqrTrigger &amp;&amp; Time.time - _lastTriggerTime &gt; jumpCooldown &amp;&amp; _grounded)&#10;            {&#10;                IsTriggered = true;&#10;                _lastTriggerTime = Time.time;&#10;            }&#10;            else&#10;            {&#10;                IsTriggered = false;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using Player.Components;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Emits an event when the player is within a certain distance&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class FrogProximityTrigger : MonoBehaviour, ITrigger&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float triggerDistance = 3f;&#10;        [SerializeField] private float jumpCooldown = 2f;&#10;        [SerializeField] private int checkEveryNFrames = 1;&#10;&#10;        private int _frameCounter;&#10;        private bool _grounded;&#10;        private float _lastTriggerTime;&#10;        private Transform _player;&#10;&#10;        private void Start()&#10;        {&#10;            _player = PlayerLocator.PlayerTransform;&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public bool IsTriggered { get; private set; }&#10;&#10;        public void CheckTrigger()&#10;        {&#10;            if (++_frameCounter % checkEveryNFrames != 0 || !_player) return;&#10;&#10;            Vector2 toPlayer = _player.position - transform.position;&#10;            float sqrDist = toPlayer.sqrMagnitude;&#10;            float sqrTrigger = triggerDistance * triggerDistance;&#10;&#10;            if (sqrDist &lt; sqrTrigger &amp;&amp; Time.time - _lastTriggerTime &gt; jumpCooldown &amp;&amp; _grounded)&#10;            {&#10;                IsTriggered = true;&#10;                _lastTriggerTime = Time.time;&#10;            }&#10;            else&#10;            {&#10;                IsTriggered = false;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/JumpMover.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/JumpMover.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to make the enemy jump forward&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class JumpCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float jumpForceX = 2f;&#10;        [SerializeField] private float jumpForceY = 5f;&#10;&#10;        private bool _grounded;&#10;        private Rigidbody2D _rb;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (_grounded)&#10;            {&#10;                Vector2 jumpDir = new(transform.localScale.x * jumpForceX, jumpForceY);&#10;                _rb.linearVelocity = jumpDir;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to make the enemy jump forward&#10;    [RequireComponent(typeof(Rigidbody2D))]&#10;    public class JumpCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private LayerMask groundLayer;&#10;        [SerializeField] private float jumpForceX = 2f;&#10;        [SerializeField] private float jumpForceY = 5f;&#10;&#10;        private bool _grounded;&#10;        private Rigidbody2D _rb;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = true;&#10;        }&#10;&#10;        private void OnCollisionExit2D(Collision2D collision)&#10;        {&#10;            if ((1 &lt;&lt; collision.gameObject.layer &amp; groundLayer) != 0)&#10;                _grounded = false;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (_grounded)&#10;            {&#10;                Vector2 jumpDir = new(transform.localScale.x * jumpForceX, jumpForceY);&#10;                _rb.linearVelocity = jumpDir;&#10;            }&#10;        }&#10;&#10;        public void ResetState()&#10;        {&#10;            _grounded = false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/ProjectileShooter.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/ProjectileShooter.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using Weapons.Models;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to shoot a projectile at intervals&#10;    public class ProjectileShootCommand : MonoBehaviour, IAttackCommand&#10;    {&#10;        [SerializeField] private FireballWeapon fireballWeapon;&#10;        [SerializeField] private float fireInterval = 2f;&#10;&#10;        private float _lastFireTime;&#10;&#10;        private void Start()&#10;        {&#10;            fireballWeapon.Equip();&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (!fireballWeapon)&#10;                return;&#10;&#10;            if (Time.time - _lastFireTime &lt; fireInterval)&#10;                return;&#10;&#10;            fireballWeapon.Shoot();&#10;            _lastFireTime = Time.time;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using Weapons.Models;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to shoot a projectile at intervals&#10;    public class ProjectileShootCommand : MonoBehaviour, IAttackCommand&#10;    {&#10;        [SerializeField] private FireballWeapon fireballWeapon;&#10;        [SerializeField] private float fireInterval = 2f;&#10;&#10;        private float _lastFireTime;&#10;&#10;        private void Start()&#10;        {&#10;            fireballWeapon.Equip();&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            if (!fireballWeapon)&#10;                return;&#10;&#10;            if (Time.time - _lastFireTime &lt; fireInterval)&#10;                return;&#10;&#10;            fireballWeapon.Shoot();&#10;            _lastFireTime = Time.time;&#10;        }&#10;&#10;        public void ResetCooldown()&#10;        {&#10;            _lastFireTime = 0f;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/VerticalMover.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/VerticalMover.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy up and down&#10;    public class VerticalMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float amplitude = 2f;&#10;        [SerializeField] private float frequency = 0.8f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocityY = (y - _rb.position.y) / Time.fixedDeltaTime;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy up and down&#10;    public class VerticalMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float amplitude = 2f;&#10;        [SerializeField] private float frequency = 0.8f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocityY = (y - _rb.position.y) / Time.fixedDeltaTime;&#10;        }&#10;&#10;        public void ResetPosition()&#10;        {&#10;            _rb.position = new Vector2(_rb.position.x, _startY);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/WaveMover.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Behaviors/WaveMover.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy in a wave pattern&#10;    public class WaveMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float speed = 2f;&#10;        [SerializeField] private float amplitude = 1f;&#10;        [SerializeField] private float frequency = 1.11f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocity = new Vector2(-speed, (y - _rb.position.y) / Time.fixedDeltaTime);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemies.Behaviors&#10;{&#10;    // Command to move the enemy in a wave pattern&#10;    public class WaveMoveCommand : MonoBehaviour, IMovementCommand&#10;    {&#10;        [SerializeField] private float speed = 2f;&#10;        [SerializeField] private float amplitude = 1f;&#10;        [SerializeField] private float frequency = 1.11f;&#10;&#10;        private Rigidbody2D _rb;&#10;        private float _startY;&#10;&#10;        private void Awake()&#10;        {&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            _startY = transform.position.y;&#10;        }&#10;&#10;        public void Execute()&#10;        {&#10;            float t = Mathf.PingPong(Time.time * frequency, 1f);&#10;            float triangle = 2f * Mathf.Abs(t - 0.5f);&#10;            float y = _startY + (triangle - 0.5f) * 2f * amplitude;&#10;            _rb.linearVelocity = new Vector2(-speed, (y - _rb.position.y) / Time.fixedDeltaTime);&#10;        }&#10;&#10;        public void ResetPosition()&#10;        {&#10;            _rb.position = new Vector2(_rb.position.x, _startY);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/BehaviorOrchestrator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/BehaviorOrchestrator.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyBehaviorController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyBehaviorController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Wires up modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyBehaviorController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (ITriggerBehavior trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;            foreach (IMovementBehavior move in _movementBehaviors) move.Move();&#10;            foreach (IAttackBehavior attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Coordinates modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyBehaviorController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (ITriggerBehavior trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;        }&#10;&#10;        private void FixedUpdate()&#10;        {&#10;            foreach (IMovementBehavior move in _movementBehaviors) move.Move();&#10;        }&#10;&#10;        private void LateUpdate()&#10;        {&#10;            foreach (IAttackBehavior attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/EnemyController.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemies.Interfaces;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Wires up modular behaviors. Attach this to any enemy prefab.&#10;    public class EnemyController : MonoBehaviour&#10;    {&#10;        private IMovementBehavior[] _movementBehaviors;&#10;        private IAttackBehavior[] _attackBehaviors;&#10;        private ITriggerBehavior[] _triggerBehaviors;&#10;&#10;        private void Awake()&#10;        {&#10;            _movementBehaviors = GetComponents&lt;IMovementBehavior&gt;();&#10;            _attackBehaviors = GetComponents&lt;IAttackBehavior&gt;();&#10;            _triggerBehaviors = GetComponents&lt;ITriggerBehavior&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (var trigger in _triggerBehaviors) trigger.CheckTrigger();&#10;            foreach (var move in _movementBehaviors) move.Move();&#10;            foreach (var attack in _attackBehaviors) attack.Attack();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/TriggerManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Core/TriggerManager.cs" />
              <option name="originalContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using System.Linq;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Manages periodic checks for all triggers in the scene&#10;    public class TriggerManager : MonoBehaviour&#10;    {&#10;        private TriggerGroup[] _triggerGroups;&#10;&#10;        private void Awake()&#10;        {&#10;            _triggerGroups = FindObjectsOfType&lt;MonoBehaviour&gt;().OfType&lt;TriggerGroup&gt;().ToArray();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            foreach (var group in _triggerGroups)&#10;            {&#10;                group.Update();&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemies.Interfaces;&#10;using UnityEngine;&#10;using System.Linq;&#10;&#10;namespace Enemies.Core&#10;{&#10;    // Manages periodic checks for all triggers in the scene&#10;    public class TriggerManager : MonoBehaviour&#10;    {&#10;        private TriggerGroup[] _triggerGroups;&#10;&#10;        private void Awake()&#10;        {&#10;            _triggerGroups = FindObjectsOfType&lt;MonoBehaviour&gt;().OfType&lt;TriggerGroup&gt;().ToArray();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IAttackBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IAttackBehavior.cs" />
              <option name="originalContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IAttackBehavior&#10;    {&#10;        void Attack();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IAttackBehavior&#10;    {&#10;        void Attack();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IMovementBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/IMovementBehavior.cs" />
              <option name="originalContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IMovementBehavior&#10;    {&#10;        void Move();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface IMovementBehavior&#10;    {&#10;        void Move();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/ITriggerBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemies/Interfaces/ITriggerBehavior.cs" />
              <option name="originalContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface ITrigger&#10;    {&#10;        bool IsTriggered { get; }&#10;    }&#10;&#10;    public interface ITriggerBehavior&#10;    {&#10;        void CheckTrigger();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Enemies.Interfaces&#10;{&#10;    public interface ITrigger&#10;    {&#10;        bool IsTriggered { get; }&#10;        void CheckTrigger();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/Behaviors/EnemyBehaviors.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/Behaviors/EnemyBehaviors.cs" />
              <option name="updatedContent" value="namespace Enemy.Behaviors&#10;{&#10;    // Optional movement behavior&#10;    public interface IMovable&#10;    {&#10;        void Move();&#10;    }&#10;&#10;    // Optional player proximity reaction&#10;    public interface IPlayerProximityReactable&#10;    {&#10;        void OnPlayerNearby();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/BirdEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/BirdEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Bird: Moves left, goes up and down&#10;    public class BirdEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private float moveSpeed = 2f;&#10;        [SerializeField] private float verticalAmplitude = 1f;&#10;        [SerializeField] private float verticalFrequency = 1f;&#10;        private Vector3 _startPos;&#10;        private float _time;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _startPos = transform.position;&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            _time += Time.deltaTime;&#10;            float yOffset = Mathf.Sin(_time * verticalFrequency) * verticalAmplitude;&#10;            transform.position = _startPos + new Vector3(-moveSpeed * _time, yOffset, 0);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBase.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public abstract class EnemyBase : MonoBehaviour&#10;    {&#10;        protected Rigidbody2D rb;&#10;        protected Collider2D col;&#10;        protected virtual void Awake()&#10;        {&#10;            rb = GetComponent&lt;Rigidbody2D&gt;();&#10;            col = GetComponent&lt;Collider2D&gt;();&#10;        }&#10;&#10;        public virtual void Move() { }&#10;        public virtual void Attack() { }&#10;        public virtual void OnPlayerNearby() { }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBuilder.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyBuilder.cs" />
              <option name="originalContent" value="using Enemy.Behaviors;&#10;using Weapons.Models;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyBuilder&#10;    {&#10;        private readonly EnemyBase _enemy;&#10;&#10;        public EnemyBuilder(EnemyBase enemy)&#10;        {&#10;            _enemy = enemy;&#10;        }&#10;&#10;        public EnemyBuilder WithFireSnakeBehavior()&#10;        {&#10;            // Example: assign FireballWeapon if available&#10;            var fireSnake = _enemy as FireSnakeEnemy;&#10;            if (fireSnake)&#10;            {&#10;                FireballWeapon weapon = fireSnake.GetComponentInChildren&lt;FireballWeapon&gt;();&#10;                if (weapon)&#10;                {&#10;                    weapon.Equip();&#10;                    // Additional setup if needed&#10;                }&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSpiderBehavior()&#10;        {&#10;            // Assign movement or proximity logic as needed&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithBirdBehavior()&#10;        {&#10;            // Assign movement logic as needed&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSnakeBehavior()&#10;        {&#10;            // Assign jump logic as needed&#10;            var snake = _enemy as SnakeEnemy;&#10;            if (snake)&#10;            {&#10;                // Example: assign a jump movement component or set jump parameters&#10;                // (Assume SnakeEnemy implements IMovable and has a Jump method)&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithFrogBehavior()&#10;        {&#10;            // Assign jump and proximity logic as needed&#10;            var frog = _enemy as FrogEnemy;&#10;            if (frog)&#10;            {&#10;                // Example: assign a jump movement component or set jump parameters&#10;                // (Assume FrogEnemy implements IMovable and IPlayerProximityReactable)&#10;            }&#10;            return this;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Enemy.Behaviors;&#10;using Weapons.Models;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyBuilder&#10;    {&#10;        private readonly EnemyBase _enemy;&#10;&#10;        public EnemyBuilder(EnemyBase enemy)&#10;        {&#10;            _enemy = enemy;&#10;        }&#10;&#10;        public EnemyBuilder WithFireSnakeBehavior()&#10;        {&#10;            // Example: assign FireballWeapon if available&#10;            var fireSnake = _enemy as FireSnakeEnemy;&#10;            if (fireSnake)&#10;            {&#10;                FireballWeapon weapon = fireSnake.GetComponentInChildren&lt;FireballWeapon&gt;();&#10;                if (weapon)&#10;                {&#10;                    weapon.Equip();&#10;                    // Additional setup if needed&#10;                }&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSpiderBehavior()&#10;        {&#10;            // Spider: Can move up/down or stay static in air&#10;            var spider = _enemy as SpiderEnemy;&#10;            if (spider)&#10;            {&#10;                // No extra setup needed; movement handled in SpiderEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithBirdBehavior()&#10;        {&#10;            // Bird: Moves left, goes up and down&#10;            var bird = _enemy as BirdEnemy;&#10;            if (bird)&#10;            {&#10;                // No extra setup needed; movement handled in BirdEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithSnakeBehavior()&#10;        {&#10;            // Snake: Jumps forward&#10;            var snake = _enemy as SnakeEnemy;&#10;            if (snake)&#10;            {&#10;                // No extra setup needed; jump logic handled in SnakeEnemy&#10;            }&#10;            return this;&#10;        }&#10;&#10;        public EnemyBuilder WithFrogBehavior()&#10;        {&#10;            // Frog: Jumps higher/farther, jumps when player is near&#10;            var frog = _enemy as FrogEnemy;&#10;            if (frog)&#10;            {&#10;                // No extra setup needed; jump and proximity handled in FrogEnemy&#10;            }&#10;            return this;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDirector.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDirector.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public static class EnemyDirector&#10;    {&#10;        // Entry point for configuring an enemy in the scene&#10;        public static void ConstructEnemy(EnemyType type, EnemyBase enemy)&#10;        {&#10;            // The director delegates the construction to the factory&#10;            EnemyFactory.ConfigureEnemy(type, enemy);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyFactory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyFactory.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public enum EnemyType&#10;    {&#10;        FireSnake,&#10;        Spider,&#10;        Bird,&#10;        Snake,&#10;        Frog&#10;    }&#10;&#10;    public static class EnemyFactory&#10;    {&#10;        // Configures an existing enemy instance using the builder pattern&#10;        public static void ConfigureEnemy(EnemyType type, EnemyBase enemy)&#10;        {&#10;            if (enemy == null) throw new ArgumentNullException(nameof(enemy));&#10;            var builder = new EnemyBuilder(enemy);&#10;            switch (type)&#10;            {&#10;                case EnemyType.FireSnake:&#10;                    builder.WithFireSnakeBehavior();&#10;                    break;&#10;                case EnemyType.Spider:&#10;                    builder.WithSpiderBehavior();&#10;                    break;&#10;                case EnemyType.Bird:&#10;                    builder.WithBirdBehavior();&#10;                    break;&#10;                case EnemyType.Snake:&#10;                    builder.WithSnakeBehavior();&#10;                    break;&#10;                case EnemyType.Frog:&#10;                    builder.WithFrogBehavior();&#10;                    break;&#10;                default:&#10;                    break;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/FireSnakeEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/FireSnakeEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Weapons.Models;&#10;&#10;namespace Enemy&#10;{&#10;    public class FireSnakeEnemy : EnemyBase&#10;    {&#10;        [SerializeField] private FireballWeapon fireballWeapon;&#10;        [SerializeField] private float attackCooldown = 2f;&#10;        private float _nextAttackTime;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            if (fireballWeapon != null)&#10;                fireballWeapon.Equip();&#10;        }&#10;&#10;        public override void Attack()&#10;        {&#10;            if (fireballWeapon == null)&#10;                return;&#10;            if (Time.time &lt; _nextAttackTime)&#10;                return;&#10;            fireballWeapon.Shoot();&#10;            _nextAttackTime = Time.time + attackCooldown;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/FrogEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/FrogEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Frog: Jumps higher and farther, jumps when player is near&#10;    public class FrogEnemy : EnemyBase, IMovable, IPlayerProximityReactable&#10;    {&#10;        [SerializeField] private float jumpForce = 12f;&#10;        [SerializeField] private float jumpDistance = 6f;&#10;        [SerializeField] private float jumpCooldown = 2f;&#10;        private float _nextJumpTime;&#10;        private Rigidbody2D _rb;&#10;        private bool _playerNearby;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (_playerNearby &amp;&amp; Time.time &gt;= _nextJumpTime)&#10;            {&#10;                Vector2 jumpVector = new Vector2(jumpDistance, jumpForce);&#10;                _rb.AddForce(jumpVector, ForceMode2D.Impulse);&#10;                _nextJumpTime = Time.time + jumpCooldown;&#10;                _playerNearby = false; // Only jump once per proximity event&#10;            }&#10;        }&#10;&#10;        public void OnPlayerNearby()&#10;        {&#10;            _playerNearby = true;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/EnemyBase.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/EnemyBase.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/FireSnake.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/MVC/FireSnake.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/SnakeEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/SnakeEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Snake: Jumps forward&#10;    public class SnakeEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private float jumpForce = 7f;&#10;        [SerializeField] private float jumpInterval = 2f;&#10;        private float _nextJumpTime;&#10;        private Rigidbody2D _rb;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _rb = GetComponent&lt;Rigidbody2D&gt;();&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (Time.time &gt;= _nextJumpTime)&#10;            {&#10;                _rb.AddForce(Vector2.right * jumpForce, ForceMode2D.Impulse);&#10;                _nextJumpTime = Time.time + jumpInterval;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/SpiderEnemy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/SpiderEnemy.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Enemy.Behaviors;&#10;&#10;namespace Enemy&#10;{&#10;    // Spider: Can move up/down or stay static in air&#10;    public class SpiderEnemy : EnemyBase, IMovable&#10;    {&#10;        [SerializeField] private bool canMove = true;&#10;        [SerializeField] private float moveSpeed = 2f;&#10;        [SerializeField] private float moveDistance = 3f;&#10;        private Vector3 _startPos;&#10;        private bool _movingUp = true;&#10;&#10;        protected override void Awake()&#10;        {&#10;            base.Awake();&#10;            _startPos = transform.position;&#10;        }&#10;&#10;        public void Move()&#10;        {&#10;            if (!canMove) return;&#10;            float delta = moveSpeed * Time.deltaTime * (_movingUp ? 1 : -1);&#10;            transform.position += new Vector3(0, delta, 0);&#10;            if (Mathf.Abs(transform.position.y - _startPos.y) &gt; moveDistance)&#10;                _movingUp = !_movingUp;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Health.Interfaces;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class AlwaysAllowDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        public bool CanBeDamagedBy(GameObject damager) =&gt; true;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AndDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OrDamageCondition.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All layers by default&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target))&#10;                return;&#10;&#10;            int amount = _dealer?.GetDamageAmount() ?? 1;&#10;            damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using System.Linq;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class BidirectionalDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject other = collision.gameObject;&#10;            GameObject self = gameObject;&#10;&#10;            // 1. This object damages the other&#10;            TryDealDamage(self, other, _dealer, _damageConditions, targetLayers);&#10;&#10;            // 2. The other object damages this&#10;            var otherDealer = other.GetComponent&lt;IDamageDealer&gt;();&#10;            var otherConditions = other.GetComponent&lt;DamageConditionsComponent&gt;();&#10;            TryDealDamage(other, self, otherDealer, otherConditions, targetLayers);&#10;        }&#10;&#10;        private static void TryDealDamage(&#10;            GameObject dealerObj,&#10;            GameObject targetObj,&#10;            IDamageDealer dealer,&#10;            DamageConditionsComponent conditions,&#10;            LayerMask targetLayers)&#10;        {&#10;            if (dealer == null) return;&#10;            if (((1 &lt;&lt; targetObj.layer) &amp; targetLayers) == 0) return;&#10;            var damageable = targetObj.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (conditions &amp;&amp; !conditions.CanBeDamagedBy(targetObj)) return;&#10;            int amount = dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, dealerObj);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DealDamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DealDamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;        [SerializeField] private LayerMask targetLayers = ~0;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (_dealer == null) return;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0) return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target)) return;&#10;            int amount = _dealer.GetDamageAmount();&#10;            if (amount &gt; 0)&#10;                damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;&#10;// This script is now deprecated in favor of TakeDamageOnCollision for most use cases.&#10;// Please use TakeDamageOnCollision on all damageable objects instead." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            foreach (IDamageCondition cond in _conditions)&#10;            {&#10;                if (cond != null &amp;&amp; !cond.CanBeDamagedBy(damager))&#10;                    return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            return _conditions.All(cond =&gt; cond == null || cond.CanBeDamagedBy(damager));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Editor/ConditionNodeTreeDrawers.cs" />
              <option name="originalContent" value="using Health.Damage;&#10;using UnityEditor;&#10;using UnityEngine;&#10;&#10;[CustomPropertyDrawer(typeof(ConditionLeaf))]&#10;public class ConditionLeafPropertyDrawer : ConditionNodePropertyDrawer {}&#10;&#10;[CustomPropertyDrawer(typeof(AndCondition))]&#10;public class AndConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;AND Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(OrCondition))]&#10;public class OrConditionPropertyDrawer : ConditionNodePropertyDrawer {&#10;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {&#10;        EditorGUI.BeginProperty(position, label, property);&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        float y = position.y;&#10;        float width = position.width;&#10;        float lineHeight = EditorGUIUtility.singleLineHeight + 2;&#10;        // Draw header&#10;        Rect headerRect = new Rect(position.x, y, width, lineHeight);&#10;        EditorGUI.LabelField(headerRect, &quot;OR Group&quot;, EditorStyles.boldLabel);&#10;        y += lineHeight;&#10;        // Draw each child node using the full custom node UI&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                float childHeight = GetNodeHeight(childProp);&#10;                Rect childRect = new Rect(position.x + 16, y, width - 16, childHeight);&#10;                DrawNode(childRect, childProp, 1); // indent = 1 for children&#10;                y += childHeight + 2;&#10;            }&#10;            // Add button&#10;            Rect addRect = new Rect(position.x + 16, y, width - 16, lineHeight);&#10;            if (GUI.Button(addRect, &quot;+ Add Child Node&quot;)) {&#10;                childrenProp.InsertArrayElementAtIndex(childrenProp.arraySize);&#10;                var newChild = childrenProp.GetArrayElementAtIndex(childrenProp.arraySize - 1);&#10;                newChild.managedReferenceValue = new ConditionLeaf();&#10;                property.serializedObject.ApplyModifiedProperties();&#10;                property.serializedObject.Update();&#10;                EditorUtility.SetDirty(property.serializedObject.targetObject);&#10;                GUI.FocusControl(null);&#10;            }&#10;            y += lineHeight;&#10;        }&#10;        EditorGUI.EndProperty();&#10;    }&#10;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label) {&#10;        float height = EditorGUIUtility.singleLineHeight + 2; // header&#10;        var childrenProp = property.FindPropertyRelative(&quot;children&quot;);&#10;        if (childrenProp != null &amp;&amp; childrenProp.isArray) {&#10;            for (int i = 0; i &lt; childrenProp.arraySize; i++) {&#10;                var childProp = childrenProp.GetArrayElementAtIndex(i);&#10;                height += GetNodeHeight(childProp) + 2;&#10;            }&#10;            height += EditorGUIUtility.singleLineHeight + 2; // add button&#10;        }&#10;        return height;&#10;    }&#10;}&#10;&#10;[CustomPropertyDrawer(typeof(NotCondition))]&#10;public class NotConditionPropertyDrawer : ConditionNodePropertyDrawer {}&#10;" />
              <option name="updatedContent" value="// All custom property drawers for node types are now handled by ConditionNodePropertyDrawer.&#10;// This file is no longer needed and can be deleted, or you can leave it empty." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/README.md" />
              <option name="updatedContent" value="// Health/README.md&#10;&#10;# Health System Setup Guide&#10;&#10;## Folder Structure&#10;- `Core/` – Health logic&#10;- `Interfaces/` – All interfaces&#10;- `Shield/` – Shield logic&#10;- `Invincibility/` – Invincibility logic&#10;- `Damage/` – Damage logic and conditions&#10;&#10;## How to Compose Entities in Unity Editor&#10;&#10;### Player (Basic)&#10;- Add `HealthComponent` (Core)&#10;&#10;### Player with Shield&#10;- Add `HealthComponent` (Core)&#10;- Add `ShieldComponent` (Shield)&#10;&#10;### Player with Invincibility&#10;- Add `HealthComponent` (Core)&#10;- Add `InvincibilityComponent` (Invincibility)&#10;- Connect to your `IPowerUp` system to toggle invincibility&#10;&#10;### Enemy&#10;- Add `HealthComponent` (Core)&#10;&#10;### Hazard (Standard)&#10;- Add `HazardComponent` (Damage)&#10;- Add `DamageDealerComponent` (Damage)&#10;- Add a damage condition (e.g., `AlwaysAllowDamage`, `OnlyInvincibleCanDamage`, `OnlyShieldedCanDamage`) as needed&#10;- Assign the condition(s) to the `HazardComponent`'s `damageConditions` array in the Inspector&#10;&#10;### Custom Damage Conditions&#10;- Create a new MonoBehaviour implementing `IDamageCondition`&#10;- Add it to the hazard GameObject&#10;- Assign it in the `HazardComponent`&#10;&#10;## Extending&#10;- To add new damage conditions, create a new script implementing `IDamageCondition` and add it in the Editor. No need to modify existing code.&#10;&#10;## Events&#10;- Use UnityEvents or C# events on components for custom reactions (e.g., OnDeath, OnShieldBroken)&#10;&#10;## Cleanup&#10;- Remove old scripts like `ShieldActiveDisappearHazard`, `OnlyInvincibilityDamageController`, etc. after migration.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// When enabled, instantly kills any damageable object the player collides with.&#10;    /// Should be enabled only when the player is invincible.&#10;    /// &lt;/summary&gt;&#10;    [DisallowMultipleComponent]&#10;    public class PlayerInvincibleDamageDealer : MonoBehaviour, IDamageDealer&#10;    {&#10;        [SerializeField] private int damageAmount = 9999; // &quot;Kill&quot; value&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All by default&#10;&#10;        public int GetDamageAmount() =&gt; damageAmount;&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if (((1 &lt;&lt; collision.gameObject.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            var damageable = collision.gameObject.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable != null)&#10;            {&#10;                damageable.Damage(damageAmount, gameObject);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Pooling/PooledObject.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Pooling/PooledObject.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Pooling&#10;{&#10;    public class PooledObject : MonoBehaviour&#10;    {&#10;        public GameObject prefab;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>