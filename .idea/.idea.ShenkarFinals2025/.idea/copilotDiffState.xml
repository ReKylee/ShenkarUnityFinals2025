<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Audio/Data/SoundEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Audio/Data/SoundEvent.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/GameFlowManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/GameFlowManager.cs" />
              <option name="originalContent" value="using System;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Core.Events;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameFlowManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Game Settings&quot;)] [SerializeField]&#10;        private float restartDelay = 2f;&#10;&#10;        [Header(&quot;Victory Settings&quot;)] [SerializeField]&#10;        private string victorySceneName = &quot;YouWonScene&quot;;&#10;&#10;        [SerializeField] private float victoryTransitionDelay = 3f;&#10;&#10;        private string _currentLevelName = &quot;Unknown&quot;;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private float _levelStartTime;&#10;        private ISceneLoadService _sceneLoadService;&#10;&#10;        private GameState CurrentState { get; set; } = GameState.MainMenu;&#10;&#10;        private void Start()&#10;        {&#10;            _currentLevelName = GetCurrentLevelName();&#10;&#10;            // Only auto-start gameplay in actual level scenes&#10;            // Other scenes (Level Select, Start Menu, etc.) will manage their own states&#10;            if (ShouldAutoStartGameplay())&#10;            {&#10;                StartGameplay();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            UnsubscribeFromEvents();&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, GameDataCoordinator gameDataCoordinator,&#10;            ISceneLoadService sceneLoadService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            _sceneLoadService = sceneLoadService;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private static bool ShouldAutoStartGameplay()&#10;        {&#10;            // Only auto-start gameplay in actual level scenes&#10;            string sceneName = SceneManager.GetActiveScene().name;&#10;            return !sceneName.Equals(&quot;Level Select&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp;&#10;                   !sceneName.Contains(&quot;Start&quot;) &amp;&amp;&#10;                   !sceneName.Equals(&quot;YouWonScene&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private void StartGameplay()&#10;        {&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = _currentLevelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void StartLevel(string levelName)&#10;        {&#10;            _currentLevelName = levelName;&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = levelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void PauseGame()&#10;        {&#10;            if (CurrentState == GameState.Playing)&#10;                ChangeState(GameState.Paused);&#10;        }&#10;&#10;        public void ResumeGame()&#10;        {&#10;            if (CurrentState == GameState.Paused)&#10;                ChangeState(GameState.Playing);&#10;        }&#10;&#10;        public void RestartLevel()&#10;        {&#10;            string currentSceneName = SceneManager.GetActiveScene().name;&#10;            _sceneLoadService?.LoadLevel(currentSceneName);&#10;        }&#10;&#10;    &#10;&#10;        public void CompleteLevel(string currentLevelName)&#10;        {&#10;            float completionTime = Time.time - _levelStartTime;&#10;&#10;            _eventBus?.Publish(new LevelCompletedEvent&#10;            {&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void RequestLevelLoad(string levelName, string sceneName)&#10;        {&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                SceneName = sceneName&#10;            });&#10;        }&#10;&#10;        public void SelectLevel(string levelName, int levelIndex)&#10;        {&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                LevelIndex = levelIndex&#10;            });&#10;        }&#10;&#10;        public void NavigateLevel(int previousIndex, int newIndex, Vector2 direction)&#10;        {&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = newIndex,&#10;                Direction = direction&#10;            });&#10;        }&#10;&#10;        public void NavigateToLevelSelection()&#10;        {&#10;            try&#10;            {&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to navigate to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void OnGameOver(GameOverEvent gameOverEvent)&#10;        {&#10;            ChangeState(GameState.GameOver);&#10;            _gameDataCoordinator?.ResetAllData();&#10;            _sceneLoadService?.LoadLevel(&quot;StartScene&quot;);&#10;        }&#10;&#10;        private async void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            ChangeState(GameState.Victory);&#10;&#10;            // First, check if the level was already completed&#10;            bool wasAlreadyCompleted = _gameDataCoordinator.IsLevelCompleted(levelEvent.LevelName);&#10;&#10;            // Now, update the progress (marks as complete, updates best time, etc.)&#10;            _gameDataCoordinator.UpdateLevelProgress(levelEvent.LevelName, true, levelEvent.CompletionTime);&#10;&#10;            // If it's the first time completing this level, unlock the next one&#10;            if (!wasAlreadyCompleted)&#10;            {&#10;                await UnlockNextLevelByIndex(levelEvent.LevelName);&#10;            }&#10;&#10;            if (await IsGameCompletedAsync())&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] All levels completed! Transitioning to YouWonScene...&quot;);&#10;                TransitionToVictorySceneAsync();&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] Level {levelEvent.LevelName} completed. Returning to level selection...&quot;);&#10;                ReturnToLevelSelectionAsync();&#10;            }&#10;        }&#10;&#10;        private async Task UnlockNextLevelByIndex(string completedLevelName)&#10;        {&#10;            Debug.Log($&quot;[GameFlowManager] UnlockNextLevelByIndex called for: {completedLevelName}&quot;);&#10;&#10;            var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            if (allLevels == null || allLevels.Count == 0)&#10;            {&#10;                Debug.LogWarning(&quot;[GameFlowManager] No levels discovered for unlocking next level&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Found {allLevels.Count} levels total&quot;);&#10;&#10;            LevelData completedLevel = allLevels.FirstOrDefault(l =&gt; l.levelName == completedLevelName);&#10;            if (completedLevel == null)&#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] Could not find completed level: {completedLevelName}&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Completed level index: {completedLevel.levelIndex}&quot;);&#10;            int nextLevelIndex = completedLevel.levelIndex + 1;&#10;&#10;            if (nextLevelIndex &lt; allLevels.Count)&#10;            {&#10;                LevelData nextLevel = allLevels.FirstOrDefault(l =&gt; l.levelIndex == nextLevelIndex);&#10;                if (nextLevel != null)&#10;                {&#10;                    bool isAlreadyUnlocked = _gameDataCoordinator.IsLevelUnlocked(nextLevel.levelName);&#10;                    Debug.Log(&#10;                        $&quot;[GameFlowManager] Next level '{nextLevel.levelName}' (index {nextLevelIndex}) - Already unlocked: {isAlreadyUnlocked}&quot;);&#10;&#10;                    if (!isAlreadyUnlocked)&#10;                    {&#10;                        _gameDataCoordinator.UnlockLevel(nextLevel.levelName);&#10;                        Debug.Log($&quot;[GameFlowManager] Unlocked next level: {nextLevel.levelName}&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        Debug.Log($&quot;[GameFlowManager] Next level {nextLevel.levelName} was already unlocked&quot;);&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;[GameFlowManager] Could not find level with index {nextLevelIndex}&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] No more levels to unlock (completed level was the last one)&quot;);&#10;            }&#10;        }&#10;&#10;        private async Task&lt;bool&gt; IsGameCompletedAsync()&#10;        {&#10;            try&#10;            {&#10;                // Get all available levels through GameDataCoordinator&#10;                var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;&#10;                if (allLevels == null || allLevels.Count == 0)&#10;                {&#10;                    Debug.LogWarning(&quot;[GameFlowManager] No levels found in discovery service&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Get completed levels using wrapper method&#10;                var completedLevels = _gameDataCoordinator?.GetCompletedLevels();&#10;                if (completedLevels == null) return false;&#10;&#10;                // Check if all levels are in the completed list&#10;                int completedCount = 0;&#10;                foreach (LevelData level in allLevels)&#10;                {&#10;                    if (completedLevels.Contains(level.levelName))&#10;                    {&#10;                        completedCount++;&#10;                    }&#10;                }&#10;&#10;                Debug.Log(&#10;                    $&quot;[GameFlowManager] Game completion check: {completedCount}/{allLevels.Count} levels completed&quot;);&#10;&#10;                if (completedCount &gt;= allLevels.Count)&#10;                {&#10;                    Debug.Log(&quot;[GameFlowManager] All levels completed!&quot;);&#10;                    return true;&#10;                }&#10;&#10;                var remainingLevels = allLevels.Where(l =&gt; !completedLevels.Contains(l.levelName))&#10;                    .Select(l =&gt; l.levelName);&#10;&#10;                Debug.Log($&quot;[GameFlowManager] Remaining levels: {string.Join(&quot;, &quot;, remainingLevels)}&quot;);&#10;                return false;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Error checking game completion: {e}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private async void TransitionToVictorySceneAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(victoryTransitionDelay * 1000));&#10;&#10;                _eventBus?.Publish(new GameCompletedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    FinalLevelName = _currentLevelName&#10;                });&#10;&#10;                _sceneLoadService?.LoadLevel(victorySceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to transition to victory scene: {e}&quot;);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;        }&#10;&#10;        private async void ReturnToLevelSelectionAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(2f * 1000));&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to return to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnPlayerLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            bool lostLife = livesEvent.PreviousLives &gt; livesEvent.CurrentLives;&#10;            bool isGameOver = livesEvent.CurrentLives == 0;&#10;&#10;            if (isGameOver)&#10;            {&#10;                ChangeState(GameState.GameOver);&#10;                // Use selective reset to preserve score and level progress&#10;                _gameDataCoordinator?.ResetProgressData();&#10;                _eventBus?.Publish(new GameOverEvent { Timestamp = Time.time });&#10;            }&#10;&#10;            if (lostLife)&#10;            {&#10;                _eventBus?.Publish(new PlayerDeathEvent&#10;                {&#10;                    DeathPosition = PlayerLocator.PlayerTransform.position,&#10;                    Timestamp = Time.time&#10;                });&#10;            }&#10;&#10;            if (isGameOver || lostLife)&#10;            {&#10;                Time.timeScale = 0.01f;&#10;                RestartLevelAfterDelayAsync(restartDelay);&#10;            }&#10;        }&#10;&#10;        private async void RestartLevelAfterDelayAsync(float delay)&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(delay * 1000));&#10;                string currentSceneName = SceneManager.GetActiveScene().name;&#10;                _sceneLoadService?.LoadLevel(currentSceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to restart level after delay: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ChangeState(GameState newState)&#10;        {&#10;            if (CurrentState == newState) return;&#10;&#10;            GameState oldState = CurrentState;&#10;            CurrentState = newState;&#10;&#10;            _eventBus?.Publish(new GameStateChangedEvent&#10;            {&#10;                PreviousState = oldState,&#10;                NewState = newState,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private string GetCurrentLevelName() =&gt; SceneManager.GetActiveScene().name;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Core.Events;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;using Player.Components;&#10;using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using VContainer;&#10;&#10;namespace Core&#10;{&#10;    public class GameFlowManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Game Settings&quot;)] [SerializeField]&#10;        private float restartDelay = 2f;&#10;&#10;        [Header(&quot;Victory Settings&quot;)] [SerializeField]&#10;        private string victorySceneName = &quot;YouWonScene&quot;;&#10;&#10;        [SerializeField] private float victoryTransitionDelay = 3f;&#10;&#10;        private string _currentLevelName = &quot;Unknown&quot;;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private float _levelStartTime;&#10;        private ISceneLoadService _sceneLoadService;&#10;&#10;        private GameState CurrentState { get; set; } = GameState.MainMenu;&#10;&#10;        private void Start()&#10;        {&#10;            _currentLevelName = GetCurrentLevelName();&#10;&#10;            // Only auto-start gameplay in actual level scenes&#10;            // Other scenes (Level Select, Start Menu, etc.) will manage their own states&#10;            if (ShouldAutoStartGameplay())&#10;            {&#10;                StartGameplay();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            UnsubscribeFromEvents();&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, GameDataCoordinator gameDataCoordinator,&#10;            ISceneLoadService sceneLoadService)&#10;        {&#10;            _eventBus = eventBus;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;            _sceneLoadService = sceneLoadService;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private static bool ShouldAutoStartGameplay()&#10;        {&#10;            // Only auto-start gameplay in actual level scenes&#10;            string sceneName = SceneManager.GetActiveScene().name;&#10;            return !sceneName.Equals(&quot;Level Select&quot;, StringComparison.OrdinalIgnoreCase) &amp;&amp;&#10;                   !sceneName.Contains(&quot;Start&quot;) &amp;&amp;&#10;                   !sceneName.Equals(&quot;YouWonScene&quot;, StringComparison.OrdinalIgnoreCase);&#10;        }&#10;&#10;        private void StartGameplay()&#10;        {&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = _currentLevelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void StartLevel(string levelName)&#10;        {&#10;            _currentLevelName = levelName;&#10;            Time.timeScale = 1;&#10;            ChangeState(GameState.Playing);&#10;            _levelStartTime = Time.time;&#10;&#10;            _eventBus?.Publish(new LevelStartedEvent&#10;            {&#10;                LevelName = levelName,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void PauseGame()&#10;        {&#10;            if (CurrentState == GameState.Playing)&#10;                ChangeState(GameState.Paused);&#10;        }&#10;&#10;        public void ResumeGame()&#10;        {&#10;            if (CurrentState == GameState.Paused)&#10;                ChangeState(GameState.Playing);&#10;        }&#10;&#10;        public void RestartLevel()&#10;        {&#10;            string currentSceneName = SceneManager.GetActiveScene().name;&#10;            _sceneLoadService?.LoadLevel(currentSceneName);&#10;        }&#10;&#10;    &#10;&#10;        public void CompleteLevel(string currentLevelName)&#10;        {&#10;            float completionTime = Time.time - _levelStartTime;&#10;&#10;            _eventBus?.Publish(new LevelCompletedEvent&#10;            {&#10;                LevelName = currentLevelName,&#10;                CompletionTime = completionTime,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        public void RequestLevelLoad(string levelName, string sceneName)&#10;        {&#10;            _eventBus?.Publish(new LevelLoadRequestedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                SceneName = sceneName&#10;            });&#10;        }&#10;&#10;        public void SelectLevel(string levelName, int levelIndex)&#10;        {&#10;            _eventBus?.Publish(new LevelSelectedEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                LevelName = levelName,&#10;                LevelIndex = levelIndex&#10;            });&#10;        }&#10;&#10;        public void NavigateLevel(int previousIndex, int newIndex, Vector2 direction)&#10;        {&#10;            _eventBus?.Publish(new LevelNavigationEvent&#10;            {&#10;                Timestamp = Time.time,&#10;                PreviousIndex = previousIndex,&#10;                NewIndex = newIndex,&#10;                Direction = direction&#10;            });&#10;        }&#10;&#10;        public void NavigateToLevelSelection()&#10;        {&#10;            try&#10;            {&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to navigate to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Subscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Subscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private void UnsubscribeFromEvents()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;GameOverEvent&gt;(OnGameOver);&#10;            _eventBus?.Unsubscribe&lt;LevelCompletedEvent&gt;(OnLevelCompleted);&#10;            _eventBus?.Unsubscribe&lt;PlayerLivesChangedEvent&gt;(OnPlayerLivesChanged);&#10;        }&#10;&#10;        private async void OnGameOver(GameOverEvent gameOverEvent)&#10;        {&#10;            ChangeState(GameState.GameOver);&#10;            _gameDataCoordinator?.ResetAllData();&#10;            await Task.Delay(TimeSpan.FromSeconds(restartDelay));&#10;            _sceneLoadService?.LoadLevel(&quot;StartScene&quot;);&#10;        }&#10;&#10;        private async void OnLevelCompleted(LevelCompletedEvent levelEvent)&#10;        {&#10;            ChangeState(GameState.Victory);&#10;&#10;            // First, check if the level was already completed&#10;            bool wasAlreadyCompleted = _gameDataCoordinator.IsLevelCompleted(levelEvent.LevelName);&#10;&#10;            // Now, update the progress (marks as complete, updates best time, etc.)&#10;            _gameDataCoordinator.UpdateLevelProgress(levelEvent.LevelName, true, levelEvent.CompletionTime);&#10;&#10;            // If it's the first time completing this level, unlock the next one&#10;            if (!wasAlreadyCompleted)&#10;            {&#10;                await UnlockNextLevelByIndex(levelEvent.LevelName);&#10;            }&#10;&#10;            if (await IsGameCompletedAsync())&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] All levels completed! Transitioning to YouWonScene...&quot;);&#10;                TransitionToVictorySceneAsync();&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;[GameFlowManager] Level {levelEvent.LevelName} completed. Returning to level selection...&quot;);&#10;                ReturnToLevelSelectionAsync();&#10;            }&#10;        }&#10;&#10;        private async Task UnlockNextLevelByIndex(string completedLevelName)&#10;        {&#10;            Debug.Log($&quot;[GameFlowManager] UnlockNextLevelByIndex called for: {completedLevelName}&quot;);&#10;&#10;            var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            if (allLevels == null || allLevels.Count == 0)&#10;            {&#10;                Debug.LogWarning(&quot;[GameFlowManager] No levels discovered for unlocking next level&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Found {allLevels.Count} levels total&quot;);&#10;&#10;            LevelData completedLevel = allLevels.FirstOrDefault(l =&gt; l.levelName == completedLevelName);&#10;            if (completedLevel == null)&#10;            {&#10;                Debug.LogWarning($&quot;[GameFlowManager] Could not find completed level: {completedLevelName}&quot;);&#10;                return;&#10;            }&#10;&#10;            Debug.Log($&quot;[GameFlowManager] Completed level index: {completedLevel.levelIndex}&quot;);&#10;            int nextLevelIndex = completedLevel.levelIndex + 1;&#10;&#10;            if (nextLevelIndex &lt; allLevels.Count)&#10;            {&#10;                LevelData nextLevel = allLevels.FirstOrDefault(l =&gt; l.levelIndex == nextLevelIndex);&#10;                if (nextLevel != null)&#10;                {&#10;                    bool isAlreadyUnlocked = _gameDataCoordinator.IsLevelUnlocked(nextLevel.levelName);&#10;                    Debug.Log(&#10;                        $&quot;[GameFlowManager] Next level '{nextLevel.levelName}' (index {nextLevelIndex}) - Already unlocked: {isAlreadyUnlocked}&quot;);&#10;&#10;                    if (!isAlreadyUnlocked)&#10;                    {&#10;                        _gameDataCoordinator.UnlockLevel(nextLevel.levelName);&#10;                        Debug.Log($&quot;[GameFlowManager] Unlocked next level: {nextLevel.levelName}&quot;);&#10;                    }&#10;                    else&#10;                    {&#10;                        Debug.Log($&quot;[GameFlowManager] Next level {nextLevel.levelName} was already unlocked&quot;);&#10;                    }&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;[GameFlowManager] Could not find level with index {nextLevelIndex}&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.Log(&quot;[GameFlowManager] No more levels to unlock (completed level was the last one)&quot;);&#10;            }&#10;        }&#10;&#10;        private async Task&lt;bool&gt; IsGameCompletedAsync()&#10;        {&#10;            try&#10;            {&#10;                // Get all available levels through GameDataCoordinator&#10;                var allLevels = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;&#10;                if (allLevels == null || allLevels.Count == 0)&#10;                {&#10;                    Debug.LogWarning(&quot;[GameFlowManager] No levels found in discovery service&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Get completed levels using wrapper method&#10;                var completedLevels = _gameDataCoordinator?.GetCompletedLevels();&#10;                if (completedLevels == null) return false;&#10;&#10;                // Check if all levels are in the completed list&#10;                int completedCount = 0;&#10;                foreach (LevelData level in allLevels)&#10;                {&#10;                    if (completedLevels.Contains(level.levelName))&#10;                    {&#10;                        completedCount++;&#10;                    }&#10;                }&#10;&#10;                Debug.Log(&#10;                    $&quot;[GameFlowManager] Game completion check: {completedCount}/{allLevels.Count} levels completed&quot;);&#10;&#10;                if (completedCount &gt;= allLevels.Count)&#10;                {&#10;                    Debug.Log(&quot;[GameFlowManager] All levels completed!&quot;);&#10;                    return true;&#10;                }&#10;&#10;                var remainingLevels = allLevels.Where(l =&gt; !completedLevels.Contains(l.levelName))&#10;                    .Select(l =&gt; l.levelName);&#10;&#10;                Debug.Log($&quot;[GameFlowManager] Remaining levels: {string.Join(&quot;, &quot;, remainingLevels)}&quot;);&#10;                return false;&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Error checking game completion: {e}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        private async void TransitionToVictorySceneAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(victoryTransitionDelay * 1000));&#10;&#10;                _eventBus?.Publish(new GameCompletedEvent&#10;                {&#10;                    Timestamp = Time.time,&#10;                    FinalLevelName = _currentLevelName&#10;                });&#10;&#10;                _sceneLoadService?.LoadLevel(victorySceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to transition to victory scene: {e}&quot;);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;        }&#10;&#10;        private async void ReturnToLevelSelectionAsync()&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(2f * 1000));&#10;                ChangeState(GameState.LevelSelection);&#10;                _sceneLoadService?.LoadLevel(&quot;Level Select&quot;);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to return to level selection: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnPlayerLivesChanged(PlayerLivesChangedEvent livesEvent)&#10;        {&#10;            bool lostLife = livesEvent.PreviousLives &gt; livesEvent.CurrentLives;&#10;            bool isGameOver = livesEvent.CurrentLives == 0;&#10;&#10;            if (isGameOver)&#10;            {&#10;                ChangeState(GameState.GameOver);&#10;                // Use selective reset to preserve score and level progress&#10;                _gameDataCoordinator?.ResetProgressData();&#10;                _eventBus?.Publish(new GameOverEvent { Timestamp = Time.time });&#10;            }&#10;&#10;            if (lostLife)&#10;            {&#10;                _eventBus?.Publish(new PlayerDeathEvent&#10;                {&#10;                    DeathPosition = PlayerLocator.PlayerTransform.position,&#10;                    Timestamp = Time.time&#10;                });&#10;            }&#10;&#10;            if (isGameOver || lostLife)&#10;            {&#10;                Time.timeScale = 0.01f;&#10;                RestartLevelAfterDelayAsync(restartDelay);&#10;            }&#10;        }&#10;&#10;        private async void RestartLevelAfterDelayAsync(float delay)&#10;        {&#10;            try&#10;            {&#10;                await Task.Delay((int)(delay * 1000));&#10;                string currentSceneName = SceneManager.GetActiveScene().name;&#10;                _sceneLoadService?.LoadLevel(currentSceneName);&#10;            }&#10;            catch (Exception e)&#10;            {&#10;                Debug.LogError($&quot;[GameFlowManager] Failed to restart level after delay: {e}&quot;);&#10;            }&#10;        }&#10;&#10;        private void ChangeState(GameState newState)&#10;        {&#10;            if (CurrentState == newState) return;&#10;&#10;            GameState oldState = CurrentState;&#10;            CurrentState = newState;&#10;&#10;            _eventBus?.Publish(new GameStateChangedEvent&#10;            {&#10;                PreviousState = oldState,&#10;                NewState = newState,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private string GetCurrentLevelName() =&gt; SceneManager.GetActiveScene().name;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Services/AudioManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Services/AudioManager.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/AudioFeedbackService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/AudioFeedbackService.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Handles audio feedback for level selection events (Single Responsibility)&#10;    /// &lt;/summary&gt;&#10;    public class AudioFeedbackService : IAudioFeedbackService&#10;    {&#10;        private AudioSource _audioSource;&#10;&#10;        public void Initialize(AudioSource audioSource)&#10;        {&#10;            _audioSource = audioSource;&#10;        }&#10;&#10;&#10;        public void PlaySelectionSound()&#10;        {&#10;            if (_audioSource)&#10;            {&#10;                _audioSource.PlayOneShot(_audioSource.clip);&#10;            }&#10;        }&#10;&#10;        public void PlayLockedSound()&#10;        {&#10;            if (_audioSource)&#10;            {&#10;                _audioSource.PlayOneShot(_audioSource.clip);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Audio.Data;&#10;using Audio.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Handles audio feedback for level selection events using the new SOLID audio system&#10;    /// &lt;/summary&gt;&#10;    public class AudioFeedbackService : IAudioFeedbackService&#10;    {&#10;        [SerializeField] private SoundData selectionSound;&#10;        [SerializeField] private SoundData lockedSound;&#10;        &#10;        private IAudioService _audioService;&#10;        &#10;        [Inject]&#10;        public void Construct(IAudioService audioService)&#10;        {&#10;            _audioService = audioService;&#10;        }&#10;&#10;        public void Initialize(AudioSource audioSource)&#10;        {&#10;            // No longer needed with the new system, but kept for interface compatibility&#10;        }&#10;&#10;        public void SetSounds(SoundData selectionSound, SoundData lockedSound)&#10;        {&#10;            this.selectionSound = selectionSound;&#10;            this.lockedSound = lockedSound;&#10;        }&#10;&#10;        public void PlaySelectionSound()&#10;        {&#10;            if (selectionSound?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(&#10;                    selectionSound.clip,&#10;                    selectionSound.GetRandomizedVolume(),&#10;                    selectionSound.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;&#10;        public void PlayLockedSound()&#10;        {&#10;            if (lockedSound?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(&#10;                    lockedSound.clip,&#10;                    lockedSound.GetRandomizedVolume(),&#10;                    lockedSound.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/IAudioFeedbackService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/IAudioFeedbackService.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for audio feedback during level selection&#10;    /// &lt;/summary&gt;&#10;    public interface IAudioFeedbackService&#10;    {&#10;        void Initialize(AudioSource audioSource);&#10;        void PlaySelectionSound();&#10;        void PlayLockedSound();&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="using Audio.Data;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for audio feedback during level selection&#10;    ///     Updated to work with the new SOLID audio system&#10;    /// &lt;/summary&gt;&#10;    public interface IAudioFeedbackService&#10;    {&#10;        void Initialize(AudioSource audioSource);&#10;        void SetSounds(SoundData selectionSound, SoundData lockedSound);&#10;        void PlaySelectionSound();&#10;        void PlayLockedSound();&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameLifetimeScope.cs" />
              <option name="updatedContent" value="using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace StartGame&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     VContainer lifetime scope for Start Game screen&#10;    /// &lt;/summary&gt;&#10;    public class StartGameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[StartGameLifetimeScope] Configuring start game DI container...&quot;);&#10;&#10;            // Register core services needed for start screen&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ISceneLoadService, SceneLoadService&gt;(Lifetime.Singleton);&#10;&#10;            // Register core game management components&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;&#10;            // Register start game specific components&#10;            builder.RegisterComponentInHierarchy&lt;StartGameListener&gt;();&#10;&#10;            Debug.Log(&quot;[StartGameLifetimeScope] Start game DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>