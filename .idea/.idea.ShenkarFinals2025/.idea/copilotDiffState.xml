<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDeath.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Enemy/EnemyDeath.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyDeath : MonoBehaviour&#10;    {&#10;        private IHealthEvents _simpleHealthController;&#10;        private void Start()&#10;        {&#10;            _simpleHealthController = GetComponent&lt;IHealthEvents&gt;();&#10;            _simpleHealthController.OnLivesEmpty += HandleDeath;&#10;        }&#10;        private void OnDisable()&#10;        {&#10;            _simpleHealthController.OnLivesEmpty -= HandleDeath;&#10;        }&#10;&#10;        private void HandleDeath()&#10;        {&#10;            gameObject.SetActive(false);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Enemy&#10;{&#10;    public class EnemyDeath : MonoBehaviour&#10;    {&#10;        private IHealthEvents _healthEvents;&#10;        private void Start()&#10;        {&#10;            _healthEvents = GetComponent&lt;IHealthEvents&gt;();&#10;            if (_healthEvents != null)&#10;                _healthEvents.OnDeath += HandleDeath;&#10;        }&#10;        private void OnDisable()&#10;        {&#10;            if (_healthEvents != null)&#10;                _healthEvents.OnDeath -= HandleDeath;&#10;        }&#10;        private void HandleDeath()&#10;        {&#10;            gameObject.SetActive(false);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Core/HealthComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Core/HealthComponent.cs" />
              <option name="originalContent" value="using System;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Core&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HealthComponent : MonoBehaviour, IHealth&#10;    {&#10;        [SerializeField] private int maxHp = 3;&#10;        private bool _isDead;&#10;&#10;        protected void Awake()&#10;        {&#10;            CurrentHp = maxHp;&#10;        }&#10;        public int MaxHp =&gt; maxHp;&#10;        public int CurrentHp { get; private set; }&#10;        public event Action&lt;int, int&gt; OnHealthChanged;&#10;        public event Action OnDeath;&#10;&#10;        public void Damage(int amount, GameObject source = null)&#10;        {&#10;            if (_isDead) return;&#10;            CurrentHp = Mathf.Max(0, CurrentHp - amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;            if (CurrentHp == 0)&#10;            {&#10;                _isDead = true;&#10;                OnDeath?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            if (_isDead) return;&#10;            CurrentHp = Mathf.Min(MaxHp, CurrentHp + amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Core&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HealthComponent : MonoBehaviour, IHealth&#10;    {&#10;        [SerializeField] private int maxHp = 3;&#10;        private bool _isDead;&#10;&#10;        protected void Awake()&#10;        {&#10;            CurrentHp = maxHp;&#10;        }&#10;        public int MaxHp =&gt; maxHp;&#10;        public int CurrentHp { get; private set; }&#10;        public event Action&lt;int, int&gt; OnHealthChanged;&#10;        public event Action OnDeath;&#10;&#10;        public virtual void Damage(int amount, GameObject source = null)&#10;        {&#10;            if (_isDead) return;&#10;            CurrentHp = Mathf.Max(0, CurrentHp - amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;            if (CurrentHp == 0)&#10;            {&#10;                _isDead = true;&#10;                OnDeath?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            if (_isDead) return;&#10;            CurrentHp = Mathf.Min(MaxHp, CurrentHp + amount);&#10;            OnHealthChanged?.Invoke(CurrentHp, MaxHp);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/AlwaysAllowDamage.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Health.Interfaces;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class AlwaysAllowDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        public bool CanBeDamagedBy(GameObject damager) =&gt; true;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OnlyInvincibleCanDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OnlyInvincibleCanDamage.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Health.Interfaces;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class OnlyInvincibleCanDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            var inv = damager.GetComponent&lt;IInvincibility&gt;();&#10;            return inv != null &amp;&amp; inv.IsInvincible;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OnlyShieldedCanDamage.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/Conditions/OnlyShieldedCanDamage.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Health.Interfaces;&#10;&#10;namespace Health.Damage.Conditions&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class OnlyShieldedCanDamage : MonoBehaviour, IDamageCondition&#10;    {&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            var shield = damager.GetComponent&lt;IShield&gt;();&#10;            return shield != null &amp;&amp; shield.IsActive;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageDealerComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageDealerComponent.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Health.Interfaces;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DamageDealerComponent : MonoBehaviour, IDamageDealer&#10;    {&#10;        [SerializeField] private int damageAmount = 1;&#10;        public int GetDamageAmount() =&gt; damageAmount;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/DamageOnCollision.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;&#10;            // If hazard has conditions, check them&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target))&#10;                return;&#10;&#10;            int amount = _dealer?.GetDamageAmount() ?? 1;&#10;            damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class DamageOnCollision : MonoBehaviour&#10;    {&#10;        private IDamageDealer _dealer;&#10;        private DamageConditionsComponent _damageConditions;&#10;&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All layers by default&#10;&#10;        private void Awake()&#10;        {&#10;            _dealer = GetComponent&lt;IDamageDealer&gt;();&#10;            _damageConditions = GetComponent&lt;DamageConditionsComponent&gt;();&#10;        }&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            GameObject target = collision.gameObject;&#10;            if (((1 &lt;&lt; target.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            IDamageable damageable = target.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable == null) return;&#10;&#10;            // If hazard has conditions, check them&#10;            if (_damageConditions &amp;&amp; !_damageConditions.CanBeDamagedBy(target))&#10;                return;&#10;&#10;            int amount = _dealer?.GetDamageAmount() ?? 1;&#10;            damageable.Damage(amount, gameObject);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/HazardComponent.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            foreach (IDamageCondition cond in _conditions)&#10;            {&#10;                if (cond != null &amp;&amp; !cond.CanBeDamagedBy(damager))&#10;                    return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Linq;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class HazardComponent : MonoBehaviour&#10;    {&#10;        [Tooltip(&quot;Assign components implementing IDamageCondition here.&quot;)] [SerializeField]&#10;        private MonoBehaviour[] damageConditions;&#10;&#10;        private IDamageCondition[] _conditions;&#10;        private void Awake()&#10;        {&#10;            _conditions = damageConditions.Cast&lt;IDamageCondition&gt;().ToArray();&#10;        }&#10;        public bool CanBeDamagedBy(GameObject damager)&#10;        {&#10;            return _conditions.All(cond =&gt; cond == null || cond.CanBeDamagedBy(damager));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/PeriodicBypassDamageDealer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/PeriodicBypassDamageDealer.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Damage&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Applies damage every 3 seconds to the attached GameObject, bypassing shield logic.&#10;    /// &lt;/summary&gt;&#10;    [DisallowMultipleComponent]&#10;    public class PeriodicBypassDamageDealer : MonoBehaviour&#10;    {&#10;        [SerializeField] private int damageAmount = 1;&#10;        [SerializeField] private float interval = 3f;&#10;        private IBypassableDamageable _bypassable;&#10;        private Coroutine _damageRoutine;&#10;&#10;        private void Awake()&#10;        {&#10;            _bypassable = GetComponent&lt;IBypassableDamageable&gt;();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (_bypassable != null)&#10;                _damageRoutine = StartCoroutine(DamageLoop());&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (_damageRoutine != null)&#10;                StopCoroutine(_damageRoutine);&#10;        }&#10;&#10;        private IEnumerator DamageLoop()&#10;        {&#10;            while (true)&#10;            {&#10;                _bypassable.DamageBypass(damageAmount);&#10;                yield return new WaitForSeconds(interval);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Damage/ShieldBreaksHazardOnCollision.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Interfaces/HealthInterfaces.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Interfaces/HealthInterfaces.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace Health.Interfaces&#10;{&#10;    public interface IHealable&#10;    {&#10;        void Heal(int amount);&#10;    }&#10;&#10;    public interface IDamageable&#10;    {&#10;        void Damage(int amount, GameObject source = null);&#10;    }&#10;&#10;    public interface IHealthEvents&#10;    {&#10;        event Action&lt;int, int&gt; OnHealthChanged;&#10;        event Action OnDeath;&#10;    }&#10;&#10;    public interface IHealth : IHealable, IDamageable, IHealthEvents&#10;    {&#10;        int CurrentHp { get; }&#10;        int MaxHp { get; }&#10;    }&#10;&#10;    public interface IDamageDealer&#10;    {&#10;        int GetDamageAmount();&#10;    }&#10;&#10;    public interface IShield&#10;    {&#10;        bool IsActive { get; }&#10;        void BreakShield();&#10;        event Action OnShieldBroken;&#10;    }&#10;&#10;    public interface IInvincibility&#10;    {&#10;        bool IsInvincible { get; }&#10;        void SetInvincible(bool value);&#10;    }&#10;&#10;    public interface IDamageCondition&#10;    {&#10;        bool CanBeDamagedBy(GameObject damager);&#10;    }&#10;&#10;    public interface IBypassableDamageable&#10;    {&#10;        void DamageBypass(int amount);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace Health.Interfaces&#10;{&#10;    public interface IHealable&#10;    {&#10;        void Heal(int amount);&#10;    }&#10;&#10;    public interface IDamageable&#10;    {&#10;        void Damage(int amount, GameObject source = null);&#10;    }&#10;&#10;    public interface IHealthEvents&#10;    {&#10;        event Action&lt;int, int&gt; OnHealthChanged;&#10;        event Action OnDeath;&#10;    }&#10;&#10;    public interface IHealth : IHealable, IDamageable, IHealthEvents&#10;    {&#10;        int CurrentHp { get; }&#10;        int MaxHp { get; }&#10;    }&#10;&#10;    public interface IDamageDealer&#10;    {&#10;        int GetDamageAmount();&#10;    }&#10;&#10;    public interface IShield&#10;    {&#10;        bool IsActive { get; }&#10;        void BreakShield(int damageAmount);&#10;        event System.Action&lt;int&gt; OnShieldBroken;&#10;    }&#10;&#10;    public interface IInvincibility&#10;    {&#10;        bool IsInvincible { get; }&#10;        void SetInvincible(bool value);&#10;    }&#10;&#10;    public interface IDamageCondition&#10;    {&#10;        bool CanBeDamagedBy(GameObject damager);&#10;    }&#10;&#10;    public interface IBypassableDamageable&#10;    {&#10;        void DamageBypass(int amount);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Invincibility/InvincibilityComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Invincibility/InvincibilityComponent.cs" />
              <option name="originalContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Invincibility&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class InvincibilityComponent : MonoBehaviour, IInvincibility&#10;    {&#10;        public bool IsInvincible { get; private set; }&#10;        public void SetInvincible(bool value)&#10;        {&#10;            IsInvincible = value;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Invincibility&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class InvincibilityComponent : MonoBehaviour, IInvincibility, IDamageDealer&#10;    {&#10;        public bool IsInvincible { get; private set; }&#10;        public void SetInvincible(bool value)&#10;        {&#10;            IsInvincible = value;&#10;        }&#10;&#10;        public int GetDamageAmount() =&gt; IsInvincible ? 9999 : 0;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/README.md" />
              <option name="updatedContent" value="// Health/README.md&#10;&#10;# Health System Setup Guide&#10;&#10;## Folder Structure&#10;- `Core/` – Health logic&#10;- `Interfaces/` – All interfaces&#10;- `Shield/` – Shield logic&#10;- `Invincibility/` – Invincibility logic&#10;- `Damage/` – Damage logic and conditions&#10;&#10;## How to Compose Entities in Unity Editor&#10;&#10;### Player (Basic)&#10;- Add `HealthComponent` (Core)&#10;&#10;### Player with Shield&#10;- Add `HealthComponent` (Core)&#10;- Add `ShieldComponent` (Shield)&#10;&#10;### Player with Invincibility&#10;- Add `HealthComponent` (Core)&#10;- Add `InvincibilityComponent` (Invincibility)&#10;- Connect to your `IPowerUp` system to toggle invincibility&#10;&#10;### Enemy&#10;- Add `HealthComponent` (Core)&#10;&#10;### Hazard (Standard)&#10;- Add `HazardComponent` (Damage)&#10;- Add `DamageDealerComponent` (Damage)&#10;- Add a damage condition (e.g., `AlwaysAllowDamage`, `OnlyInvincibleCanDamage`, `OnlyShieldedCanDamage`) as needed&#10;- Assign the condition(s) to the `HazardComponent`'s `damageConditions` array in the Inspector&#10;&#10;### Custom Damage Conditions&#10;- Create a new MonoBehaviour implementing `IDamageCondition`&#10;- Add it to the hazard GameObject&#10;- Assign it in the `HazardComponent`&#10;&#10;## Extending&#10;- To add new damage conditions, create a new script implementing `IDamageCondition` and add it in the Editor. No need to modify existing code.&#10;&#10;## Events&#10;- Use UnityEvents or C# events on components for custom reactions (e.g., OnDeath, OnShieldBroken)&#10;&#10;## Cleanup&#10;- Remove old scripts like `ShieldActiveDisappearHazard`, `OnlyInvincibilityDamageController`, etc. after migration.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Health/Shield/ShieldComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Health/Shield/ShieldComponent.cs" />
              <option name="originalContent" value="using System;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Shield&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class ShieldComponent : MonoBehaviour, IShield&#10;    {&#10;        [SerializeField] private bool startActive = true;&#10;&#10;        private void Awake()&#10;        {&#10;            IsActive = startActive;&#10;        }&#10;        public bool IsActive { get; private set; }&#10;        public event Action&lt;int&gt; OnShieldBroken;&#10;&#10;        public void ActivateShield()&#10;        {&#10;            IsActive = true;&#10;        }&#10;        public void BreakShield(int damageAmount)&#10;        {&#10;            if (!IsActive) return;&#10;            IsActive = false;&#10;            OnShieldBroken?.Invoke(damageAmount);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Health.Shield&#10;{&#10;    [DisallowMultipleComponent]&#10;    public class ShieldComponent : MonoBehaviour, IShield, IDamageDealer&#10;    {&#10;        [SerializeField] private bool startActive = true;&#10;&#10;        private void Awake()&#10;        {&#10;            IsActive = startActive;&#10;        }&#10;        public bool IsActive { get; private set; }&#10;        public event Action&lt;int&gt; OnShieldBroken;&#10;&#10;        public void ActivateShield()&#10;        {&#10;            IsActive = true;&#10;        }&#10;        public void BreakShield(int damageAmount)&#10;        {&#10;            if (!IsActive) return;&#10;            IsActive = false;&#10;            OnShieldBroken?.Invoke(damageAmount);&#10;        }&#10;        public int GetDamageAmount() =&gt; IsActive ? 1 : 0;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerHealthController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerHealthController.cs" />
              <option name="originalContent" value="using Core;&#10;using Core.Events;&#10;using Health;&#10;using Health.Core;&#10;using Health.Interfaces;&#10;using Player.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Components&#10;{&#10;    public class PlayerHealthController : HealthComponent, IBypassableDamageable&#10;    {&#10;        [SerializeField] private BarsHealthView healthView;&#10;        private IEventBus _eventBus;&#10;        private GameFlowManager _gameFlowManager;&#10;        private IPlayerLivesService _livesService;&#10;        private IShield _shield;&#10;        private IInvincibility _invincibility;&#10;&#10;        #region VContainer Injection&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, IPlayerLivesService livesService, GameFlowManager gameFlowManager)&#10;        {&#10;            _eventBus = eventBus;&#10;            _livesService = livesService;&#10;            _gameFlowManager = gameFlowManager;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Unity Lifecycle&#10;&#10;        private new void Awake()&#10;        {&#10;            base.Awake();&#10;            _shield = GetComponent&lt;IShield&gt;();&#10;            _invincibility = GetComponent&lt;IInvincibility&gt;();&#10;        }&#10;&#10;        protected void Start()&#10;        {&#10;            healthView.UpdateDisplay(CurrentHp, MaxHp);&#10;            OnHealthChanged += HandleHealthChanged;&#10;            OnDeath += HandleHealthEmpty;&#10;        }&#10;&#10;        protected void OnDestroy()&#10;        {&#10;            OnHealthChanged -= HandleHealthChanged;&#10;            OnDeath -= HandleHealthEmpty;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Event Handlers&#10;&#10;        private void HandleHealthChanged(int hp, int maxHp)&#10;        {&#10;            healthView.UpdateDisplay(hp, maxHp);&#10;            _eventBus?.Publish(new PlayerHealthChangedEvent&#10;            {&#10;                CurrentHp = hp,&#10;                MaxHp = maxHp,&#10;                Damage = maxHp - hp,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private void HandleHealthEmpty()&#10;        {&#10;            if (_livesService == null)&#10;            {&#10;                Debug.LogError(&quot;[PlayerHealthController] _livesService is null. Ensure it is properly injected.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (!_gameFlowManager)&#10;            {&#10;                Debug.LogError(&quot;[PlayerHealthController] _gameFlowManager is null. Ensure it is properly injected.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (_livesService.TryUseLife())&#10;            {&#10;                Debug.Log(&#10;                    $&quot;[PlayerHealthController] Used a life, restored health. Lives remaining: {_livesService.CurrentLives}&quot;);&#10;&#10;                return;&#10;            }&#10;&#10;            _gameFlowManager.HandlePlayerDeath(transform.position);&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Transformation Handling&#10;&#10;        public void ActivateShield() =&gt; _shield?.BreakShield(); // Or implement activation logic if needed&#10;        public void DeactivateShield()&#10;        {&#10;            /* Implement if needed */&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Damage Handling&#10;&#10;        public override void Damage(int amount, GameObject source = null)&#10;        {&#10;            if (_invincibility is { IsInvincible: true })&#10;                return;&#10;            if (_shield is { IsActive: true })&#10;            {&#10;                _shield.BreakShield();&#10;                return;&#10;            }&#10;&#10;            base.Damage(amount, source);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Damage that bypasses transformation shield (used by continuous damage, etc.)&#10;        /// &lt;/summary&gt;&#10;        public void DamageBypass(int amount)&#10;        {&#10;            base.Damage(amount, gameObject);&#10;        }&#10;&#10;        #endregion&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Core;&#10;using Core.Events;&#10;using Health;&#10;using Health.Core;&#10;using Health.Interfaces;&#10;using Player.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Components&#10;{&#10;    public class PlayerHealthController : HealthComponent, IBypassableDamageable&#10;    {&#10;        [SerializeField] private BarsHealthView healthView;&#10;        private IEventBus _eventBus;&#10;        private GameFlowManager _gameFlowManager;&#10;        private IPlayerLivesService _livesService;&#10;        private IShield _shield;&#10;        private IInvincibility _invincibility;&#10;&#10;        #region VContainer Injection&#10;&#10;        [Inject]&#10;        public void Construct(IEventBus eventBus, IPlayerLivesService livesService, GameFlowManager gameFlowManager)&#10;        {&#10;            _eventBus = eventBus;&#10;            _livesService = livesService;&#10;            _gameFlowManager = gameFlowManager;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Unity Lifecycle&#10;&#10;        private new void Awake()&#10;        {&#10;            base.Awake();&#10;            _shield = GetComponent&lt;IShield&gt;();&#10;            _invincibility = GetComponent&lt;IInvincibility&gt;();&#10;        }&#10;&#10;        protected void Start()&#10;        {&#10;            healthView.UpdateDisplay(CurrentHp, MaxHp);&#10;            OnHealthChanged += HandleHealthChanged;&#10;            OnDeath += HandleHealthEmpty;&#10;        }&#10;&#10;        protected void OnDestroy()&#10;        {&#10;            OnHealthChanged -= HandleHealthChanged;&#10;            OnDeath -= HandleHealthEmpty;&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Event Handlers&#10;&#10;        private void HandleHealthChanged(int hp, int maxHp)&#10;        {&#10;            healthView.UpdateDisplay(hp, maxHp);&#10;            _eventBus?.Publish(new PlayerHealthChangedEvent&#10;            {&#10;                CurrentHp = hp,&#10;                MaxHp = maxHp,&#10;                Damage = maxHp - hp,&#10;                Timestamp = Time.time&#10;            });&#10;        }&#10;&#10;        private void HandleHealthEmpty()&#10;        {&#10;            if (_livesService == null)&#10;            {&#10;                Debug.LogError(&quot;[PlayerHealthController] _livesService is null. Ensure it is properly injected.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (!_gameFlowManager)&#10;            {&#10;                Debug.LogError(&quot;[PlayerHealthController] _gameFlowManager is null. Ensure it is properly injected.&quot;);&#10;                return;&#10;            }&#10;&#10;            if (_livesService.TryUseLife())&#10;            {&#10;                Debug.Log(&#10;                    $&quot;[PlayerHealthController] Used a life, restored health. Lives remaining: {_livesService.CurrentLives}&quot;);&#10;&#10;                return;&#10;            }&#10;&#10;            _gameFlowManager.HandlePlayerDeath(transform.position);&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Transformation Handling&#10;&#10;        public void ActivateShield() =&gt; _shield?.BreakShield(); // Or implement activation logic if needed&#10;        public void DeactivateShield()&#10;        {&#10;            /* Implement if needed */&#10;        }&#10;&#10;        #endregion&#10;&#10;        #region Damage Handling&#10;&#10;        public override void Damage(int amount, GameObject source = null)&#10;        {&#10;            if (_invincibility is { IsInvincible: true })&#10;                return;&#10;            if (_shield is { IsActive: true })&#10;            {&#10;                _shield.BreakShield(amount);&#10;                return;&#10;            }&#10;&#10;            base.Damage(amount, source);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Damage that bypasses transformation shield (used by continuous damage, etc.)&#10;        /// &lt;/summary&gt;&#10;        public void DamageBypass(int amount)&#10;        {&#10;            base.Damage(amount, gameObject);&#10;        }&#10;&#10;        #endregion&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerInvincibleDamageDealer.cs" />
              <option name="updatedContent" value="using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// When enabled, instantly kills any damageable object the player collides with.&#10;    /// Should be enabled only when the player is invincible.&#10;    /// &lt;/summary&gt;&#10;    [DisallowMultipleComponent]&#10;    public class PlayerInvincibleDamageDealer : MonoBehaviour, IDamageDealer&#10;    {&#10;        [SerializeField] private int damageAmount = 9999; // &quot;Kill&quot; value&#10;        [SerializeField] private LayerMask targetLayers = ~0; // All by default&#10;&#10;        public int GetDamageAmount() =&gt; damageAmount;&#10;&#10;        private void OnCollisionEnter2D(Collision2D collision)&#10;        {&#10;            if (((1 &lt;&lt; collision.gameObject.layer) &amp; targetLayers) == 0)&#10;                return;&#10;            var damageable = collision.gameObject.GetComponent&lt;IDamageable&gt;();&#10;            if (damageable != null)&#10;            {&#10;                damageable.Damage(damageAmount, gameObject);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/TransformationManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/TransformationManager.cs" />
              <option name="originalContent" value="using System;&#10;using GabrielBigardi.SpriteAnimator;&#10;using Health.Interfaces;&#10;using Player.Interfaces;&#10;using UnityEngine;&#10;using Weapons;&#10;using Weapons.Services;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Orchestrates transformations&#10;    /// &lt;/summary&gt;&#10;    public class TransformationManager : MonoBehaviour, ITransformationCoordinator&#10;    {&#10;        private PlayerHealthController _healthController;&#10;&#10;        private WeaponType _pendingWeapon = WeaponType.None;&#10;        private IShield _shield;&#10;        private TransformationVisualEffects _visualEffects;&#10;        private WeaponManagerService _weaponManager;&#10;&#10;        private bool IsTransformed { get; set; }&#10;&#10;        private void Awake()&#10;        {&#10;            _visualEffects = GetComponent&lt;TransformationVisualEffects&gt;();&#10;            _weaponManager = GetComponentInChildren&lt;WeaponManagerService&gt;();&#10;            _healthController = GetComponent&lt;PlayerHealthController&gt;();&#10;            _shield = GetComponent&lt;IShield&gt;();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            if (_shield is not null)&#10;                _shield.OnShieldBroken += OnShieldDamageAbsorbed;&#10;&#10;            if (_visualEffects)&#10;                _visualEffects.OnEffectComplete += OnVisualEffectComplete;&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            if (_shield is not null)&#10;                _shield.OnShieldBroken -= OnShieldDamageAbsorbed;&#10;&#10;            if (_visualEffects)&#10;                _visualEffects.OnEffectComplete -= OnVisualEffectComplete;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Apply transformation by coordinating all necessary components&#10;        /// &lt;/summary&gt;&#10;        public void ApplyTransformation(SpriteAnimationObject animationObject, Sprite transitionTexture,&#10;            WeaponType weapon)&#10;        {&#10;            if (!ValidateDependencies()) return;&#10;            IsTransformed = true;&#10;            // Activate shield protection (if shield exists)&#10;            _healthController?.ActivateShield();&#10;            // Disable attacking during visual effect&#10;            _weaponManager.canAttack = false;&#10;            // Cache weapon for after effect completion&#10;            _pendingWeapon = weapon;&#10;            // Start visual transformation effect&#10;            _visualEffects.PlayTransformationEffect(transitionTexture, animationObject);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Revert transformation by coordinating all necessary components&#10;        /// &lt;/summary&gt;&#10;        public void RevertTransformation()&#10;        {&#10;            if (!ValidateDependencies()) return;&#10;            if (!IsTransformed) return;&#10;            IsTransformed = false;&#10;            _visualEffects.RevertToOriginalState();&#10;            _weaponManager.RevertFromTemporaryWeapon();&#10;            // Deactivate shield (if shield exists)&#10;            _healthController?.DeactivateShield();&#10;            _weaponManager.canAttack = true;&#10;            OnDetransformationComplete?.Invoke();&#10;            Debug.Log(&quot;[TransformationManager] Transformation reverted&quot;);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Event raised when transformation process completes&#10;        /// &lt;/summary&gt;&#10;        public event Action OnTransformationComplete;&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Event raised when detransformation process completes&#10;        /// &lt;/summary&gt;&#10;        public event Action OnDetransformationComplete;&#10;&#10;        private void OnVisualEffectComplete()&#10;        {&#10;            // Visual effect completed, now apply gameplay changes&#10;            _weaponManager.canAttack = true;&#10;            _weaponManager.SwitchToTemporaryWeapon(_pendingWeapon);&#10;&#10;            OnTransformationComplete?.Invoke();&#10;&#10;            Debug.Log(&quot;[TransformationManager] Transformation complete&quot;);&#10;        }&#10;&#10;        private void OnShieldDamageAbsorbed(int damageAmount)&#10;        {&#10;            RevertTransformation();&#10;        }&#10;&#10;        private bool ValidateDependencies()&#10;        {&#10;            if (!_visualEffects || !_weaponManager || !_healthController)&#10;            {&#10;                Debug.LogError(&quot;[TransformationManager] Missing required dependencies&quot;);&#10;                return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using GabrielBigardi.SpriteAnimator;&#10;using Health.Interfaces;&#10;using Player.Interfaces;&#10;using UnityEngine;&#10;using Weapons;&#10;using Weapons.Services;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Orchestrates transformations&#10;    /// &lt;/summary&gt;&#10;    public class TransformationManager : MonoBehaviour, ITransformationCoordinator&#10;    {&#10;        [Header(&quot;Dependencies&quot;)]&#10;        [SerializeField] private TransformationVisualEffects _visualEffects;&#10;        [SerializeField] private WeaponManagerService _weaponManager;&#10;        [SerializeField] private IShield _shield;&#10;&#10;        private WeaponType _pendingWeapon = WeaponType.None;&#10;        private bool _isTransformed;&#10;&#10;        private void Awake()&#10;        {&#10;            if (!_visualEffects) _visualEffects = GetComponent&lt;TransformationVisualEffects&gt;();&#10;            if (!_weaponManager) _weaponManager = GetComponentInChildren&lt;WeaponManagerService&gt;();&#10;            if (_shield == null) _shield = GetComponent&lt;IShield&gt;();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (_shield != null)&#10;                _shield.OnShieldBroken += OnShieldDamageAbsorbed;&#10;            if (_visualEffects)&#10;                _visualEffects.OnEffectComplete += OnVisualEffectComplete;&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (_shield != null)&#10;                _shield.OnShieldBroken -= OnShieldDamageAbsorbed;&#10;            if (_visualEffects)&#10;                _visualEffects.OnEffectComplete -= OnVisualEffectComplete;&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Apply transformation by coordinating all necessary components&#10;        /// &lt;/summary&gt;&#10;        public void ApplyTransformation(SpriteAnimationObject animationObject, Sprite transitionTexture,&#10;            WeaponType weapon)&#10;        {&#10;            if (!ValidateDependencies()) return;&#10;            _isTransformed = true;&#10;            // Activate shield protection (if shield exists)&#10;            _shield?.BreakShield(-1); // Or use a dedicated Activate method if you have one&#10;            _weaponManager.canAttack = false;&#10;            // Cache weapon for after effect completion&#10;            _pendingWeapon = weapon;&#10;            // Start visual transformation effect&#10;            _visualEffects.PlayTransformationEffect(transitionTexture, animationObject);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Revert transformation by coordinating all necessary components&#10;        /// &lt;/summary&gt;&#10;        public void RevertTransformation()&#10;        {&#10;            if (!ValidateDependencies() || !_isTransformed) return;&#10;            _isTransformed = false;&#10;            _visualEffects.RevertToOriginalState();&#10;            _weaponManager.RevertFromTemporaryWeapon();&#10;            // Deactivate shield (if shield exists)&#10;            // If you have a Deactivate method, call it here&#10;            _weaponManager.canAttack = true;&#10;            OnDetransformationComplete?.Invoke();&#10;            Debug.Log(&quot;[TransformationManager] Transformation reverted&quot;);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Event raised when transformation process completes&#10;        /// &lt;/summary&gt;&#10;        public event Action OnTransformationComplete;&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Event raised when detransformation process completes&#10;        /// &lt;/summary&gt;&#10;        public event Action OnDetransformationComplete;&#10;&#10;        private void OnVisualEffectComplete()&#10;        {&#10;            // Visual effect completed, now apply gameplay changes&#10;            _weaponManager.canAttack = true;&#10;            _weaponManager.SwitchToTemporaryWeapon(_pendingWeapon);&#10;&#10;            OnTransformationComplete?.Invoke();&#10;&#10;            Debug.Log(&quot;[TransformationManager] Transformation complete&quot;);&#10;        }&#10;&#10;        private void OnShieldDamageAbsorbed(int damageAmount)&#10;        {&#10;            RevertTransformation();&#10;        }&#10;&#10;        private bool ValidateDependencies()&#10;        {&#10;            if (!_visualEffects || !_weaponManager || !_shield)&#10;            {&#10;                Debug.LogError(&quot;[TransformationManager] Missing required dependencies&quot;);&#10;                return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/PowerUps/Invincibility/InvincibilityEffect.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/PowerUps/Invincibility/InvincibilityEffect.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using Health.Components;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace PowerUps.Invincibility&#10;{&#10;&#10;    public class InvincibilityEffect : MonoBehaviour, IInvincibilityDealer&#10;    {&#10;        [SerializeField] private GameObject effectObject;&#10;        private PlayerDamageController _dc;&#10;&#10;        private void Awake()&#10;        {&#10;            _dc = GetComponent&lt;PlayerDamageController&gt;();&#10;        }&#10;        public int GetDamageAmount() =&gt; _dc.IsInvulnerable ? 10 : 0;&#10;        public void Activate(float duration)&#10;        {&#10;            if (!_dc) return;&#10;            StartCoroutine(RunEffect(duration));&#10;        }&#10;&#10;        private IEnumerator RunEffect(float duration)&#10;        {&#10;            _dc.IsInvulnerable = true;&#10;            effectObject?.SetActive(true);&#10;&#10;            yield return new WaitForSeconds(duration);&#10;&#10;            _dc.IsInvulnerable = false;&#10;            effectObject?.SetActive(false);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using Health.Components;&#10;using Health.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace PowerUps.Invincibility&#10;{&#10;&#10;    public class InvincibilityEffect : MonoBehaviour&#10;    {&#10;        [SerializeField] private GameObject effectObject;&#10;        private IInvincibility _invincibility;&#10;&#10;        private void Awake()&#10;        {&#10;            _invincibility = GetComponent&lt;IInvincibility&gt;();&#10;        }&#10;&#10;        public void Activate(float duration)&#10;        {&#10;            if (_invincibility == null) return;&#10;            StartCoroutine(RunEffect(duration));&#10;        }&#10;&#10;        private IEnumerator RunEffect(float duration)&#10;        {&#10;            // Activate invincibility&#10;            if (_invincibility is Health.Invincibility.InvincibilityComponent invComp)&#10;                invComp.SetInvincible(true);&#10;            effectObject?.SetActive(true);&#10;&#10;            yield return new WaitForSeconds(duration);&#10;&#10;            // Deactivate invincibility&#10;            if (_invincibility is Health.Invincibility.InvincibilityComponent invComp2)&#10;                invComp2.SetInvincible(false);&#10;            effectObject?.SetActive(false);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>