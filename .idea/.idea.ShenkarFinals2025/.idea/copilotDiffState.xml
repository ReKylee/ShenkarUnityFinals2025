<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Audio/Data/SoundData.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Audio/Data/SoundData.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;using Random = UnityEngine.Random;&#10;&#10;namespace Audio.Data&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Simple sound data container without ScriptableObjects&#10;    /// &lt;/summary&gt;&#10;    [Serializable]&#10;    public class SoundData&#10;    {&#10;        [Header(&quot;Audio Clip&quot;)] public AudioClip clip;&#10;&#10;        [Header(&quot;Settings&quot;)] [Range(0f, 1f)] public float volume = 1f;&#10;&#10;        [Range(0.1f, 3f)] public float pitch = 1f;&#10;        [Range(0f, 0.5f)] public float randomVolumeVariance;&#10;        [Range(0f, 0.5f)] public float randomPitchVariance;&#10;&#10;        [Header(&quot;3D Audio&quot;)] public bool use3D;&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Get randomized volume within variance range&#10;        /// &lt;/summary&gt;&#10;        public float GetRandomizedVolume() =&gt; volume + Random.Range(-randomVolumeVariance, randomVolumeVariance);&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Get randomized pitch within variance range&#10;        /// &lt;/summary&gt;&#10;        public float GetRandomizedPitch() =&gt; pitch + Random.Range(-randomPitchVariance, randomPitchVariance);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;using UnityEngine.Audio;&#10;using Random = UnityEngine.Random;&#10;&#10;namespace Audio.Data&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Simple sound data container with mixer channel support&#10;    /// &lt;/summary&gt;&#10;    [Serializable]&#10;    public class SoundData&#10;    {&#10;        [Header(&quot;Audio Clip&quot;)] public AudioClip clip;&#10;&#10;        [Header(&quot;Mixer Settings&quot;)] public AudioMixerGroup mixerGroup;&#10;&#10;        [Header(&quot;Settings&quot;)] [Range(0f, 1f)] public float volume = 1f;&#10;&#10;        [Range(0.1f, 3f)] public float pitch = 1f;&#10;        [Range(0f, 0.5f)] public float randomVolumeVariance = 0f;&#10;        [Range(0f, 0.5f)] public float randomPitchVariance = 0f;&#10;&#10;        [Header(&quot;3D Audio&quot;)] public bool use3D = false;&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Get randomized volume within variance range&#10;        /// &lt;/summary&gt;&#10;        public float GetRandomizedVolume() =&gt;&#10;            volume + Random.Range(-randomVolumeVariance, randomVolumeVariance);&#10;&#10;        /// &lt;summary&gt;&#10;        ///     Get randomized pitch within variance range&#10;        /// &lt;/summary&gt;&#10;        public float GetRandomizedPitch() =&gt;&#10;            pitch + Random.Range(-randomPitchVariance, randomPitchVariance);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Audio/Data/SoundEvent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Audio/Data/SoundEvent.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Audio/Services/AudioService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Audio/Services/AudioService.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Audio.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Main audio service implementation following SOLID principles&#10;    ///     Single Responsibility: Manages all audio playback&#10;    ///     Open/Closed: Extensible through interfaces&#10;    ///     Dependency Inversion: Depends on abstractions&#10;    ///     Now managed as a singleton through VContainer instead of DontDestroyOnLoad&#10;    /// &lt;/summary&gt;&#10;    public class AudioService : MonoBehaviour, IAudioService&#10;    {&#10;        public static AudioService Instance { get; private set; }&#10;&#10;        [SerializeField] private AudioConfig audioConfig = new AudioConfig();&#10;&#10;        private AudioSource _musicSource;&#10;        private List&lt;AudioSource&gt; _sfxSources;&#10;        private List&lt;AudioSource&gt; _managedAudioSources;&#10;        private int _currentSfxIndex = 0;&#10;&#10;        private float _masterVolume = 1f;&#10;        private float _sfxVolume = 1f;&#10;        private float _musicVolume = 1f;&#10;&#10;        private void Awake()&#10;        {&#10;            if (Instance != null &amp;&amp; Instance != this)&#10;            {&#10;                Destroy(gameObject);&#10;                return;&#10;            }&#10;&#10;            Instance = this;&#10;            DontDestroyOnLoad(gameObject);&#10;&#10;            InitializeAudioSources();&#10;            InitializeManagedAudioSources();&#10;            LoadVolumeSettings();&#10;        }&#10;&#10;        public void PlaySound(AudioClip clip, float volume = 1f, float pitch = 1f)&#10;        {&#10;            if (!clip) return;&#10;&#10;            AudioSource availableSource = GetAvailableSfxSource();&#10;            if (!availableSource) return;&#10;&#10;            ConfigureSfxSource(availableSource, clip, volume, pitch);&#10;            availableSource.Play();&#10;        }&#10;&#10;        public void PlaySound(SoundData soundData)&#10;        {&#10;            if (!soundData?.clip) return;&#10;&#10;            PlaySound(soundData.clip, soundData.volume, soundData.pitch);&#10;        }&#10;&#10;        public void PlaySoundAtPosition(AudioClip clip, Vector3 position, float volume = 1f, float pitch = 1f)&#10;        {&#10;            if (!clip) return;&#10;&#10;            // Create temporary audio source at position for 3D audio&#10;            GameObject tempAudioObject = new($&quot;TempAudio_{clip.name}&quot;);&#10;            tempAudioObject.transform.position = position;&#10;&#10;            AudioSource tempSource = tempAudioObject.AddComponent&lt;AudioSource&gt;();&#10;            ConfigureSfxSource(tempSource, clip, volume, pitch, true);&#10;&#10;            tempSource.Play();&#10;&#10;            // Destroy after clip finishes&#10;            Destroy(tempAudioObject, clip.length);&#10;        }&#10;&#10;        public void PlaySoundAtPosition(SoundData soundData, Vector3 position)&#10;        {&#10;            if (soundData?.clip == null) return;&#10;&#10;            // Create temporary audio source at position for 3D audio&#10;            GameObject tempAudioObject = new($&quot;TempAudio_{soundData.clip.name}&quot;);&#10;            tempAudioObject.transform.position = position;&#10;&#10;            AudioSource tempSource = tempAudioObject.AddComponent&lt;AudioSource&gt;();&#10;            ConfigureSfxSourceWithSoundData(tempSource, soundData, true);&#10;&#10;            tempSource.Play();&#10;&#10;            // Destroy after clip finishes&#10;            Destroy(tempAudioObject, soundData.clip.length);&#10;        }&#10;&#10;        public void PlayMusic(AudioClip clip, float volume = 1f, bool loop = true)&#10;        {&#10;            if (!clip || !_musicSource) return;&#10;&#10;            _musicSource.clip = clip;&#10;            _musicSource.volume = volume * _musicVolume * _masterVolume;&#10;            _musicSource.loop = loop;&#10;            _musicSource.Play();&#10;        }&#10;&#10;        public void StopMusic()&#10;        {&#10;            _musicSource?.Stop();&#10;        }&#10;&#10;        public void StopAll()&#10;        {&#10;            // Stop music source&#10;            _musicSource?.Stop();&#10;&#10;            // Stop all SFX sources&#10;            foreach (AudioSource sfxSource in _sfxSources)&#10;            {&#10;                sfxSource.Stop();&#10;            }&#10;&#10;            // Stop all managed audio sources&#10;            foreach (AudioSource managedSource in _managedAudioSources)&#10;            {&#10;                managedSource.Stop();&#10;            }&#10;        }&#10;&#10;        public void SetMasterVolume(float volume)&#10;        {&#10;            _masterVolume = Mathf.Clamp01(volume);&#10;            UpdateAllVolumes();&#10;        }&#10;&#10;        public void SetSFXVolume(float volume)&#10;        {&#10;            _sfxVolume = Mathf.Clamp01(volume);&#10;        }&#10;&#10;        public void SetMusicVolume(float volume)&#10;        {&#10;            _musicVolume = Mathf.Clamp01(volume);&#10;            if (_musicSource &amp;&amp; _musicSource.isPlaying)&#10;            {&#10;                _musicSource.volume = _musicSource.volume * _musicVolume * _masterVolume;&#10;            }&#10;        }&#10;&#10;        private void InitializeAudioSources()&#10;        {&#10;            // Create dedicated music source&#10;            _musicSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            _musicSource.loop = true;&#10;            _musicSource.playOnAwake = false;&#10;&#10;            // Create pool of SFX sources for concurrent sounds&#10;            _sfxSources = new List&lt;AudioSource&gt;();&#10;            int maxSources = audioConfig.maxConcurrentSounds;&#10;&#10;            for (int i = 0; i &lt; maxSources; i++)&#10;            {&#10;                AudioSource sfxSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;                sfxSource.playOnAwake = false;&#10;                sfxSource.loop = false;&#10;                _sfxSources.Add(sfxSource);&#10;            }&#10;        }&#10;&#10;        private void InitializeManagedAudioSources()&#10;        {&#10;            _managedAudioSources = new List&lt;AudioSource&gt;();&#10;&#10;            foreach (var audioSource in GetComponentsInChildren&lt;AudioSource&gt;())&#10;            {&#10;                if (audioSource != _musicSource &amp;&amp; !_sfxSources.Contains(audioSource))&#10;                {&#10;                    _managedAudioSources.Add(audioSource);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void LoadVolumeSettings()&#10;        {&#10;            _masterVolume = audioConfig.masterVolume;&#10;            _sfxVolume = audioConfig.sfxVolume;&#10;            _musicVolume = audioConfig.musicVolume;&#10;        }&#10;&#10;        private AudioSource GetAvailableSfxSource()&#10;        {&#10;            // Find an available (not playing) source&#10;            foreach (AudioSource source in _sfxSources)&#10;            {&#10;                if (!source.isPlaying)&#10;                {&#10;                    return source;&#10;                }&#10;            }&#10;&#10;            // If all sources are busy, use round-robin&#10;            AudioSource roundRobinSource = _sfxSources[_currentSfxIndex];&#10;            _currentSfxIndex = (_currentSfxIndex + 1) % _sfxSources.Count;&#10;            return roundRobinSource;&#10;        }&#10;&#10;        private void ConfigureSfxSource(AudioSource source, AudioClip clip, float volume, float pitch,&#10;            bool is3D = false)&#10;        {&#10;            source.clip = clip;&#10;            source.volume = volume * _sfxVolume * _masterVolume;&#10;            source.pitch = pitch;&#10;&#10;            source.spatialBlend = is3D ? 1f : audioConfig.spatialBlend;&#10;            source.minDistance = audioConfig.minDistance;&#10;            source.maxDistance = audioConfig.maxDistance;&#10;        }&#10;&#10;        private void ConfigureSfxSourceWithSoundData(AudioSource source, SoundData soundData, bool forceIs3D = false)&#10;        {&#10;            source.clip = soundData.clip;&#10;            source.volume = soundData.GetRandomizedVolume() * _sfxVolume * _masterVolume;&#10;            source.pitch = soundData.GetRandomizedPitch();&#10;            &#10;            // Set mixer group if provided&#10;            if (soundData.mixerGroup != null)&#10;            {&#10;                source.outputAudioMixerGroup = soundData.mixerGroup;&#10;            }&#10;&#10;            bool is3D = forceIs3D || soundData.use3D;&#10;            source.spatialBlend = is3D ? 1f : audioConfig.spatialBlend;&#10;            source.minDistance = audioConfig.minDistance;&#10;            source.maxDistance = audioConfig.maxDistance;&#10;        }&#10;&#10;        private void UpdateAllVolumes()&#10;        {&#10;            // Update music volume&#10;            if (_musicSource &amp;&amp; _musicSource.isPlaying)&#10;            {&#10;                float currentMusicVolume = _musicSource.volume / (_musicVolume * _masterVolume);&#10;                _musicSource.volume = currentMusicVolume * _musicVolume * _masterVolume;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace Audio.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Main audio service implementation following SOLID principles&#10;    ///     Single Responsibility: Manages all audio playback&#10;    ///     Open/Closed: Extensible through interfaces&#10;    ///     Dependency Inversion: Depends on abstractions&#10;    ///     Now managed as a singleton through VContainer instead of DontDestroyOnLoad&#10;    /// &lt;/summary&gt;&#10;    public class AudioService : MonoBehaviour, IAudioService&#10;    {&#10;        public static AudioService Instance { get; private set; }&#10;&#10;        [SerializeField] private AudioConfig audioConfig = new AudioConfig();&#10;&#10;        private AudioSource _musicSource;&#10;        private List&lt;AudioSource&gt; _sfxSources;&#10;        private List&lt;AudioSource&gt; _managedAudioSources;&#10;        private int _currentSfxIndex = 0;&#10;&#10;        private float _masterVolume = 1f;&#10;        private float _sfxVolume = 1f;&#10;        private float _musicVolume = 1f;&#10;&#10;        private void Awake()&#10;        {&#10;            if (Instance != null &amp;&amp; Instance != this)&#10;            {&#10;                Destroy(gameObject);&#10;                return;&#10;            }&#10;&#10;            Instance = this;&#10;            DontDestroyOnLoad(gameObject);&#10;&#10;            InitializeAudioSources();&#10;            InitializeManagedAudioSources();&#10;            LoadVolumeSettings();&#10;        }&#10;&#10;        public void PlaySound(AudioClip clip, float volume = 1f, float pitch = 1f)&#10;        {&#10;            if (!clip) return;&#10;&#10;            AudioSource availableSource = GetAvailableSfxSource();&#10;            if (!availableSource) return;&#10;&#10;            ConfigureSfxSource(availableSource, clip, volume, pitch);&#10;            availableSource.Play();&#10;        }&#10;&#10;        public void PlaySound(SoundData soundData)&#10;        {&#10;            if (!soundData?.clip) return;&#10;&#10;            PlaySound(soundData.clip, soundData.volume, soundData.pitch);&#10;        }&#10;&#10;        public void PlaySoundAtPosition(AudioClip clip, Vector3 position, float volume = 1f, float pitch = 1f)&#10;        {&#10;            if (!clip) return;&#10;&#10;            // Create temporary audio source at position for 3D audio&#10;            GameObject tempAudioObject = new($&quot;TempAudio_{clip.name}&quot;);&#10;            tempAudioObject.transform.position = position;&#10;&#10;            AudioSource tempSource = tempAudioObject.AddComponent&lt;AudioSource&gt;();&#10;            ConfigureSfxSource(tempSource, clip, volume, pitch, true);&#10;&#10;            tempSource.Play();&#10;&#10;            // Destroy after clip finishes&#10;            Destroy(tempAudioObject, clip.length);&#10;        }&#10;&#10;        public void PlaySoundAtPosition(SoundData soundData, Vector3 position)&#10;        {&#10;            if (soundData?.clip == null) return;&#10;&#10;            // Create temporary audio source at position for 3D audio&#10;            GameObject tempAudioObject = new($&quot;TempAudio_{soundData.clip.name}&quot;);&#10;            tempAudioObject.transform.position = position;&#10;&#10;            AudioSource tempSource = tempAudioObject.AddComponent&lt;AudioSource&gt;();&#10;            ConfigureSfxSourceWithSoundData(tempSource, soundData, true);&#10;&#10;            tempSource.Play();&#10;&#10;            // Destroy after clip finishes&#10;            Destroy(tempAudioObject, soundData.clip.length);&#10;        }&#10;&#10;        public void PlayMusic(AudioClip clip, float volume = 1f, bool loop = true)&#10;        {&#10;            if (!clip || !_musicSource) return;&#10;&#10;            _musicSource.clip = clip;&#10;            _musicSource.volume = volume * _musicVolume * _masterVolume;&#10;            _musicSource.loop = loop;&#10;            _musicSource.Play();&#10;        }&#10;&#10;        public void StopMusic()&#10;        {&#10;            _musicSource?.Stop();&#10;        }&#10;&#10;        public void StopAll()&#10;        {&#10;            // Stop music source&#10;            _musicSource?.Stop();&#10;&#10;            // Stop all SFX sources&#10;            foreach (AudioSource sfxSource in _sfxSources)&#10;            {&#10;                sfxSource.Stop();&#10;            }&#10;&#10;            // Stop all managed audio sources&#10;            foreach (AudioSource managedSource in _managedAudioSources)&#10;            {&#10;                managedSource.Stop();&#10;            }&#10;        }&#10;&#10;        public void SetMasterVolume(float volume)&#10;        {&#10;            _masterVolume = Mathf.Clamp01(volume);&#10;            UpdateAllVolumes();&#10;        }&#10;&#10;        public void SetSFXVolume(float volume)&#10;        {&#10;            _sfxVolume = Mathf.Clamp01(volume);&#10;        }&#10;&#10;        public void SetMusicVolume(float volume)&#10;        {&#10;            _musicVolume = Mathf.Clamp01(volume);&#10;            if (_musicSource &amp;&amp; _musicSource.isPlaying)&#10;            {&#10;                _musicSource.volume = _musicSource.volume * _musicVolume * _masterVolume;&#10;            }&#10;        }&#10;&#10;        private void InitializeAudioSources()&#10;        {&#10;            // Create dedicated music source&#10;            _musicSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;            _musicSource.loop = true;&#10;            _musicSource.playOnAwake = false;&#10;&#10;            // Create pool of SFX sources for concurrent sounds&#10;            _sfxSources = new List&lt;AudioSource&gt;();&#10;            int maxSources = audioConfig.maxConcurrentSounds;&#10;&#10;            for (int i = 0; i &lt; maxSources; i++)&#10;            {&#10;                AudioSource sfxSource = gameObject.AddComponent&lt;AudioSource&gt;();&#10;                sfxSource.playOnAwake = false;&#10;                sfxSource.loop = false;&#10;                _sfxSources.Add(sfxSource);&#10;            }&#10;        }&#10;&#10;        private void InitializeManagedAudioSources()&#10;        {&#10;            _managedAudioSources = new List&lt;AudioSource&gt;();&#10;&#10;            foreach (var audioSource in GetComponentsInChildren&lt;AudioSource&gt;())&#10;            {&#10;                if (audioSource != _musicSource &amp;&amp; !_sfxSources.Contains(audioSource))&#10;                {&#10;                    _managedAudioSources.Add(audioSource);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void LoadVolumeSettings()&#10;        {&#10;            _masterVolume = audioConfig.masterVolume;&#10;            _sfxVolume = audioConfig.sfxVolume;&#10;            _musicVolume = audioConfig.musicVolume;&#10;        }&#10;&#10;        private AudioSource GetAvailableSfxSource()&#10;        {&#10;            // Find an available (not playing) source&#10;            foreach (AudioSource source in _sfxSources)&#10;            {&#10;                if (!source.isPlaying)&#10;                {&#10;                    return source;&#10;                }&#10;            }&#10;&#10;            // If all sources are busy, use round-robin&#10;            AudioSource roundRobinSource = _sfxSources[_currentSfxIndex];&#10;            _currentSfxIndex = (_currentSfxIndex + 1) % _sfxSources.Count;&#10;            return roundRobinSource;&#10;        }&#10;&#10;        private void ConfigureSfxSource(AudioSource source, AudioClip clip, float volume, float pitch,&#10;            bool is3D = false)&#10;        {&#10;            source.clip = clip;&#10;            source.volume = volume * _sfxVolume * _masterVolume;&#10;            source.pitch = pitch;&#10;&#10;            source.spatialBlend = is3D ? 1f : audioConfig.spatialBlend;&#10;            source.minDistance = audioConfig.minDistance;&#10;            source.maxDistance = audioConfig.maxDistance;&#10;        }&#10;&#10;        private void ConfigureSfxSourceWithSoundData(AudioSource source, SoundData soundData, bool forceIs3D = false)&#10;        {&#10;            source.clip = soundData.clip;&#10;            source.volume = soundData.GetRandomizedVolume() * _sfxVolume * _masterVolume;&#10;            source.pitch = soundData.GetRandomizedPitch();&#10;            &#10;            // Set mixer group if provided&#10;            if (soundData.mixerGroup != null)&#10;            {&#10;                source.outputAudioMixerGroup = soundData.mixerGroup;&#10;            }&#10;&#10;            bool is3D = forceIs3D || soundData.use3D;&#10;            source.spatialBlend = is3D ? 1f : audioConfig.spatialBlend;&#10;            source.minDistance = audioConfig.minDistance;&#10;            source.maxDistance = audioConfig.maxDistance;&#10;        }&#10;&#10;        private void UpdateAllVolumes()&#10;        {&#10;            // Update music volume&#10;            if (_musicSource &amp;&amp; _musicSource.isPlaying)&#10;            {&#10;                float currentMusicVolume = _musicSource.volume / (_musicVolume * _masterVolume);&#10;                _musicSource.volume = currentMusicVolume * _musicVolume * _masterVolume;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Data/IGameDataService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Data/IGameDataService.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Threading.Tasks;&#10;using LevelSelection;&#10;using LevelSelection.Services;&#10;&#10;namespace Core.Data&#10;{&#10;    public interface IGameDataService&#10;    {&#10;        GameData CurrentData { get; }&#10;        void UpdateLives(int lives);&#10;        void UpdateScore(int score);&#10;        void AddFruitCollected();&#10;        void UpdateBestTime(string levelName, float time);&#10;        void UpdateCurrentLevel(string levelName);&#10;        void UnlockLevel(string levelName);&#10;        void ResetAllData();&#10;        void SaveData();&#10;        &#10;        // Level data operations that should go through GameDataService&#10;        void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime);&#10;        Task&lt;List&lt;LevelData&gt;&gt; GetLevelDataAsync(ILevelDiscoveryService discoveryService);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#13;&#10;using System.Collections.Generic;&#13;&#10;using System.Threading.Tasks;&#13;&#10;using LevelSelection;&#13;&#10;using LevelSelection.Services;&#13;&#10;&#13;&#10;namespace Core.Data&#13;&#10;{&#13;&#10;    public interface IGameDataService&#13;&#10;    {&#13;&#10;        GameData CurrentData { get; }&#13;&#10;        void UpdateLives(int lives);&#13;&#10;        void UpdateScore(int score);&#13;&#10;        void AddFruitCollected();&#13;&#10;        void UpdateBestTime(string levelName, float time);&#13;&#10;        void UpdateCurrentLevel(string levelName);&#13;&#10;        void UnlockLevel(string levelName);&#13;&#10;        void ResetAllData();&#13;&#10;        void SaveData();&#13;&#10;        void ResetProgressData(); // New method for selective reset&#13;&#10;        event Action&lt;GameData&gt; OnDataChanged;&#13;&#10;        &#13;&#10;        // Level data operations that should go through GameDataService&#13;&#10;        void UpdateLevelProgress(string levelName, bool isCompleted, float completionTime);&#13;&#10;        Task&lt;List&lt;LevelData&gt;&gt; GetLevelDataAsync(ILevelDiscoveryService discoveryService);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Core/Services/AudioManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Core/Services/AudioManager.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/EndLevelZone.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/EndLevelZone.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using Core;&#10;using ModularCharacterController.Core;&#10;using Player.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Trigger zone that detects when the player completes a level.&#10;    ///     Its only responsibility is to notify the GameFlowManager.&#10;    /// &lt;/summary&gt;&#10;    [RequireComponent(typeof(Collider2D))]&#10;    public class EndLevelZone : MonoBehaviour&#10;    {&#10;        [Header(&quot;Level Completion Settings&quot;)] [SerializeField]&#10;        private string currentLevelName;&#10;&#10;        [SerializeField] private string nextLevelName;&#10;        [SerializeField] private float completionDelay = 2f;&#10;&#10;        [Header(&quot;Audio&quot;)] [SerializeField] private SoundData completionSound;&#10;&#10;        private GameFlowManager _gameFlowManager;&#10;        private bool _hasTriggered;&#10;        private HealthBonusService _healthBonusService;&#10;&#10;&#10;        private void OnTriggerEnter2D(Collider2D other)&#10;        {&#10;            // Check if player entered&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !_hasTriggered)&#10;            {&#10;                Rigidbody2D rb = other.GetComponent&lt;Rigidbody2D&gt;();&#10;                InputHandler input = other.GetComponent&lt;InputHandler&gt;();&#10;                StartCoroutine(CompleteLevel(rb, input));&#10;            }&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(GameFlowManager gameFlowManager, HealthBonusService healthBonusService)&#10;        {&#10;            _gameFlowManager = gameFlowManager;&#10;            _healthBonusService = healthBonusService;&#10;        }&#10;&#10;        private IEnumerator CompleteLevel(Rigidbody2D rb, InputHandler input)&#10;        {&#10;            _hasTriggered = true;&#10;&#10;            // Stop all music immediately when level is completed&#10;            _audioService?.StopMusic();&#10;&#10;            // Take control from the player&#10;            if (input)&#10;            {&#10;                input.enabled = false;&#10;            }&#10;&#10;            if (rb)&#10;            {&#10;                rb.linearVelocity = Vector2.zero;&#10;            }&#10;&#10;            // Make the player walk right&#10;            const float walkDuration = 1.3f;&#10;            float timer = 0f;&#10;            while (timer &lt; walkDuration)&#10;            {&#10;                if (rb)&#10;                {&#10;                    rb.linearVelocityX = 2f;&#10;                }&#10;&#10;                timer += Time.fixedDeltaTime;&#10;                yield return new WaitForFixedUpdate();&#10;            }&#10;&#10;            Debug.Log($&quot;[EndLevelZone] Player completed level: {currentLevelName}&quot;);&#10;&#10;            // Play completion sound using the new audio system&#10;            if (completionSound?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(completionSound);&#10;            }&#10;&#10;            bool bonusComplete = false;&#10;            if (_healthBonusService)&#10;            {&#10;                Debug.Log(&quot;[EndLevelZone] Starting health bonus calculation...&quot;);&#10;                _healthBonusService.CalculateHealthBonus(() =&gt; bonusComplete = true);&#10;&#10;                // Wait for bonus calculation to complete&#10;                yield return new WaitUntil(() =&gt; bonusComplete);&#10;                Debug.Log(&quot;[EndLevelZone] Health bonus calculation finished&quot;);&#10;            }&#10;&#10;            yield return new WaitForSeconds(completionDelay);&#10;&#10;            _gameFlowManager?.CompleteLevel(currentLevelName);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using Core;&#10;using ModularCharacterController.Core;&#10;using Player.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Trigger zone that detects when the player completes a level.&#10;    ///     Its only responsibility is to notify the GameFlowManager.&#10;    /// &lt;/summary&gt;&#10;    [RequireComponent(typeof(Collider2D))]&#10;    public class EndLevelZone : MonoBehaviour&#10;    {&#10;        [Header(&quot;Level Completion Settings&quot;)] [SerializeField]&#10;        private string currentLevelName;&#10;&#10;        [SerializeField] private string nextLevelName;&#10;        [SerializeField] private float completionDelay = 2f;&#10;&#10;        [Header(&quot;Audio&quot;)] [SerializeField] private SoundData completionSound;&#10;&#10;        private GameFlowManager _gameFlowManager;&#10;        private bool _hasTriggered;&#10;        private HealthBonusService _healthBonusService;&#10;&#10;&#10;        private void OnTriggerEnter2D(Collider2D other)&#10;        {&#10;            // Check if player entered&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !_hasTriggered)&#10;            {&#10;                Rigidbody2D rb = other.GetComponent&lt;Rigidbody2D&gt;();&#10;                InputHandler input = other.GetComponent&lt;InputHandler&gt;();&#10;                StartCoroutine(CompleteLevel(rb, input));&#10;            }&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(GameFlowManager gameFlowManager, HealthBonusService healthBonusService)&#10;        {&#10;            _gameFlowManager = gameFlowManager;&#10;            _healthBonusService = healthBonusService;&#10;        }&#10;&#10;        private IEnumerator CompleteLevel(Rigidbody2D rb, InputHandler input)&#10;        {&#10;            _hasTriggered = true;&#10;&#10;            // Stop all music immediately when level is completed&#10;            AudioService.Instance?.StopMusic();&#10;&#10;            // Take control from the player&#10;            if (input)&#10;            {&#10;                input.enabled = false;&#10;            }&#10;&#10;            if (rb)&#10;            {&#10;                rb.linearVelocity = Vector2.zero;&#10;            }&#10;&#10;            // Make the player walk right&#10;            const float walkDuration = 1.3f;&#10;            float timer = 0f;&#10;            while (timer &lt; walkDuration)&#10;            {&#10;                if (rb)&#10;                {&#10;                    rb.linearVelocityX = 2f;&#10;                }&#10;&#10;                timer += Time.fixedDeltaTime;&#10;                yield return new WaitForFixedUpdate();&#10;            }&#10;&#10;            Debug.Log($&quot;[EndLevelZone] Player completed level: {currentLevelName}&quot;);&#10;&#10;            // Play completion sound using the new audio system&#10;            if (completionSound?.clip)&#10;            {&#10;                AudioService.Instance?.PlaySound(completionSound);&#10;            }&#10;&#10;            bool bonusComplete = false;&#10;            if (_healthBonusService)&#10;            {&#10;                Debug.Log(&quot;[EndLevelZone] Starting health bonus calculation...&quot;);&#10;                _healthBonusService.CalculateHealthBonus(() =&gt; bonusComplete = true);&#10;&#10;                // Wait for bonus calculation to complete&#10;                yield return new WaitUntil(() =&gt; bonusComplete);&#10;                Debug.Log(&quot;[EndLevelZone] Health bonus calculation finished&quot;);&#10;            }&#10;&#10;            yield return new WaitForSeconds(completionDelay);&#10;&#10;            _gameFlowManager?.CompleteLevel(currentLevelName);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/LevelSelectionController.cs" />
              <option name="originalContent" value="using System.Threading.Tasks;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using Core;&#10;using Core.Events;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Controls level selection functionality using the new SOLID audio system directly&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Configuration&quot;)] [SerializeField]&#10;        private bool autoActivateOnStart = true;&#10;&#10;        [Header(&quot;UI References&quot;)] [SerializeField]&#10;        private GameObject selectorObject;&#10;&#10;        [SerializeField] private ItemSelectScreen itemSelectScreen;&#10;&#10;        [Header(&quot;Input&quot;)] [SerializeField] private InputActionReference navigateAction;&#10;&#10;        [SerializeField] private InputActionReference submitAction;&#10;&#10;        [Header(&quot;Audio&quot;)] [SerializeField] private SoundData selectionSound;&#10;&#10;        [SerializeField] private SoundData lockedSound;&#10;&#10;        private IAudioService _audioService;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private GameFlowManager _gameFlowManager;&#10;        private IInputFilterService _inputFilterService;&#10;        private IItemSelectService _itemSelectService;&#10;        private ILevelNavigationService _navigationService;&#10;        private ISceneLoadService _sceneLoadService;&#10;        private ISelectorService _selectorService;&#10;&#10;        public bool IsActive { get; private set; }&#10;&#10;        private async void Start()&#10;        {&#10;            await InitializeAsync();&#10;&#10;            if (autoActivateOnStart)&#10;            {&#10;                Activate();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            _selectorService?.Update();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.Enable();&#10;                navigateAction.action.performed += OnNavigate;&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnSubmit;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.performed -= OnNavigate;&#10;                navigateAction.action.Disable();&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.performed -= OnSubmit;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            ILevelNavigationService navigationService,&#10;            IEventBus eventBus,&#10;            ISelectorService selectorService,&#10;            IInputFilterService inputFilterService,&#10;            IAudioService audioService,&#10;            IItemSelectService itemSelectService,&#10;            ISceneLoadService sceneLoadService,&#10;            GameFlowManager gameFlowManager,&#10;            GameDataCoordinator gameDataCoordinator)&#10;        {&#10;            _navigationService = navigationService;&#10;            _eventBus = eventBus;&#10;            _selectorService = selectorService;&#10;            _inputFilterService = inputFilterService;&#10;            _audioService = audioService;&#10;            _itemSelectService = itemSelectService;&#10;            _sceneLoadService = sceneLoadService;&#10;            _gameFlowManager = gameFlowManager;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private async Task InitializeAsync()&#10;        {&#10;            InitializeServices();&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                _gameFlowManager.PauseGame();&#10;            }&#10;&#10;            var levelData = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            await _navigationService.InitializeAsync(levelData);&#10;&#10;            // Configure navigation service with grid width (hardcoded since config removed)&#10;            _navigationService.SetGridWidth(4); // Default grid width&#10;        }&#10;&#10;        private void InitializeServices()&#10;        {&#10;            _selectorService.Initialize(selectorObject);&#10;            _inputFilterService.Initialize();&#10;            _itemSelectService.Initialize(itemSelectScreen, _sceneLoadService);&#10;&#10;            _itemSelectService.OnStateChanged += OnItemSelectStateChanged;&#10;        }&#10;&#10;        private void OnItemSelectStateChanged(bool isActive)&#10;        {&#10;            _selectorService.SetVisible(!isActive);&#10;            _inputFilterService.SetEnabled(!isActive);&#10;        }&#10;&#10;        private void OnNavigate(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;&#10;            Vector2 direction = context.ReadValue&lt;Vector2&gt;();&#10;&#10;            if (_inputFilterService.ProcessNavigationInput(direction, out Vector2 filteredDirection))&#10;            {&#10;                _navigationService.NavigateInDirection(filteredDirection);&#10;            }&#10;        }&#10;&#10;        private void OnSubmit(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;&#10;            _navigationService.SelectCurrentLevel();&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            _selectorService.MoveToCurrentLevel(_navigationService);&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent selectionEvent)&#10;        {&#10;            LevelData levelData = _navigationService.CurrentLevel;&#10;            bool isUnlocked = _gameDataCoordinator?.IsLevelUnlocked(levelData?.levelName) ?? false;&#10;&#10;            if (levelData != null &amp;&amp; !isUnlocked)&#10;            {&#10;                PlayLockedSound();&#10;                return;&#10;            }&#10;&#10;            PlaySelectionSound();&#10;&#10;            string sceneName = _sceneLoadService.GetSceneNameForLevel(levelData);&#10;            _itemSelectService.ShowItemSelect(selectionEvent.LevelName, sceneName);&#10;        }&#10;&#10;        private void OnLevelLoadRequested(LevelLoadRequestedEvent loadEvent)&#10;        {&#10;            _gameDataCoordinator?.UpdateCurrentLevel(loadEvent.LevelName);&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                // Use StartLevel with the correct level name when loading from level selection&#10;                _gameFlowManager.StartLevel(loadEvent.LevelName);&#10;            }&#10;&#10;            _sceneLoadService.LoadLevel(loadEvent.SceneName);&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            IsActive = true;&#10;            _navigationService?.Activate();&#10;&#10;            if (_navigationService?.CurrentIndex &gt;= 0)&#10;            {&#10;                _selectorService?.MoveToCurrentLevel(_navigationService);&#10;            }&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            IsActive = false;&#10;            _navigationService?.Deactivate();&#10;        }&#10;&#10;        public void SetCurrentLevel(int levelIndex)&#10;        {&#10;            _navigationService?.SetCurrentIndex(levelIndex);&#10;        }&#10;&#10;        private void PlaySelectionSound()&#10;        {&#10;            if (selectionSound?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(selectionSound);&#10;            }&#10;        }&#10;&#10;        private void PlayLockedSound()&#10;        {&#10;            if (lockedSound?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(lockedSound);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Threading.Tasks;&#10;using Audio.Data;&#10;using Audio.Interfaces;&#10;using Core;&#10;using Core.Events;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using UnityEngine.InputSystem;&#10;using VContainer;&#10;&#10;namespace LevelSelection&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Controls level selection functionality using the new SOLID audio system directly&#10;    /// &lt;/summary&gt;&#10;    public class LevelSelectionController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Configuration&quot;)] [SerializeField]&#10;        private bool autoActivateOnStart = true;&#10;&#10;        [Header(&quot;UI References&quot;)] [SerializeField]&#10;        private GameObject selectorObject;&#10;&#10;        [SerializeField] private ItemSelectScreen itemSelectScreen;&#10;&#10;        [Header(&quot;Input&quot;)] [SerializeField] private InputActionReference navigateAction;&#10;&#10;        [SerializeField] private InputActionReference submitAction;&#10;&#10;        [Header(&quot;Audio&quot;)] [SerializeField] private SoundData selectionSound;&#10;&#10;        [SerializeField] private SoundData lockedSound;&#10;&#10;        private IEventBus _eventBus;&#10;        private GameDataCoordinator _gameDataCoordinator;&#10;        private GameFlowManager _gameFlowManager;&#10;        private IInputFilterService _inputFilterService;&#10;        private IItemSelectService _itemSelectService;&#10;        private ILevelNavigationService _navigationService;&#10;        private ISceneLoadService _sceneLoadService;&#10;        private ISelectorService _selectorService;&#10;&#10;        public bool IsActive { get; private set; }&#10;&#10;        private async void Start()&#10;        {&#10;            await InitializeAsync();&#10;&#10;            if (autoActivateOnStart)&#10;            {&#10;                Activate();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            _selectorService?.Update();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.Enable();&#10;                navigateAction.action.performed += OnNavigate;&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.Enable();&#10;                submitAction.action.performed += OnSubmit;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            if (navigateAction != null)&#10;            {&#10;                navigateAction.action.performed -= OnNavigate;&#10;                navigateAction.action.Disable();&#10;            }&#10;&#10;            if (submitAction != null)&#10;            {&#10;                submitAction.action.performed -= OnSubmit;&#10;                submitAction.action.Disable();&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            _eventBus?.Unsubscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Unsubscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Unsubscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        [Inject]&#10;        public void Construct(&#10;            ILevelNavigationService navigationService,&#10;            IEventBus eventBus,&#10;            ISelectorService selectorService,&#10;            IInputFilterService inputFilterService,&#10;            IItemSelectService itemSelectService,&#10;            ISceneLoadService sceneLoadService,&#10;            GameFlowManager gameFlowManager,&#10;            GameDataCoordinator gameDataCoordinator)&#10;        {&#10;            _navigationService = navigationService;&#10;            _eventBus = eventBus;&#10;            _selectorService = selectorService;&#10;            _inputFilterService = inputFilterService;&#10;            _itemSelectService = itemSelectService;&#10;            _sceneLoadService = sceneLoadService;&#10;            _gameFlowManager = gameFlowManager;&#10;            _gameDataCoordinator = gameDataCoordinator;&#10;&#10;            SubscribeToEvents();&#10;        }&#10;&#10;        private async Task InitializeAsync()&#10;        {&#10;            InitializeServices();&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                _gameFlowManager.PauseGame();&#10;            }&#10;&#10;            var levelData = await _gameDataCoordinator.DiscoverLevelsAsync();&#10;            await _navigationService.InitializeAsync(levelData);&#10;&#10;            // Configure navigation service with grid width (hardcoded since config removed)&#10;            _navigationService.SetGridWidth(4); // Default grid width&#10;        }&#10;&#10;        private void InitializeServices()&#10;        {&#10;            _selectorService.Initialize(selectorObject);&#10;            _inputFilterService.Initialize();&#10;            _itemSelectService.Initialize(itemSelectScreen, _sceneLoadService);&#10;&#10;            _itemSelectService.OnStateChanged += OnItemSelectStateChanged;&#10;        }&#10;&#10;        private void OnItemSelectStateChanged(bool isActive)&#10;        {&#10;            _selectorService.SetVisible(!isActive);&#10;            _inputFilterService.SetEnabled(!isActive);&#10;        }&#10;&#10;        private void OnNavigate(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;&#10;            Vector2 direction = context.ReadValue&lt;Vector2&gt;();&#10;&#10;            if (_inputFilterService.ProcessNavigationInput(direction, out Vector2 filteredDirection))&#10;            {&#10;                _navigationService.NavigateInDirection(filteredDirection);&#10;            }&#10;        }&#10;&#10;        private void OnSubmit(InputAction.CallbackContext context)&#10;        {&#10;            if (!IsActive || _itemSelectService.IsActive) return;&#10;&#10;            _navigationService.SelectCurrentLevel();&#10;        }&#10;&#10;        private void SubscribeToEvents()&#10;        {&#10;            _eventBus?.Subscribe&lt;LevelNavigationEvent&gt;(OnLevelNavigation);&#10;            _eventBus?.Subscribe&lt;LevelSelectedEvent&gt;(OnLevelSelected);&#10;            _eventBus?.Subscribe&lt;LevelLoadRequestedEvent&gt;(OnLevelLoadRequested);&#10;        }&#10;&#10;        private void OnLevelNavigation(LevelNavigationEvent navigationEvent)&#10;        {&#10;            _selectorService.MoveToCurrentLevel(_navigationService);&#10;        }&#10;&#10;        private void OnLevelSelected(LevelSelectedEvent selectionEvent)&#10;        {&#10;            LevelData levelData = _navigationService.CurrentLevel;&#10;            bool isUnlocked = _gameDataCoordinator?.IsLevelUnlocked(levelData?.levelName) ?? false;&#10;&#10;            if (levelData != null &amp;&amp; !isUnlocked)&#10;            {&#10;                PlayLockedSound();&#10;                return;&#10;            }&#10;&#10;            PlaySelectionSound();&#10;&#10;            string sceneName = _sceneLoadService.GetSceneNameForLevel(levelData);&#10;            _itemSelectService.ShowItemSelect(selectionEvent.LevelName, sceneName);&#10;        }&#10;&#10;        private void OnLevelLoadRequested(LevelLoadRequestedEvent loadEvent)&#10;        {&#10;            _gameDataCoordinator?.UpdateCurrentLevel(loadEvent.LevelName);&#10;&#10;            if (_gameFlowManager != null)&#10;            {&#10;                // Use StartLevel with the correct level name when loading from level selection&#10;                _gameFlowManager.StartLevel(loadEvent.LevelName);&#10;            }&#10;&#10;            _sceneLoadService.LoadLevel(loadEvent.SceneName);&#10;        }&#10;&#10;        public void Activate()&#10;        {&#10;            IsActive = true;&#10;            _navigationService?.Activate();&#10;&#10;            if (_navigationService?.CurrentIndex &gt;= 0)&#10;            {&#10;                _selectorService?.MoveToCurrentLevel(_navigationService);&#10;            }&#10;        }&#10;&#10;        public void Deactivate()&#10;        {&#10;            IsActive = false;&#10;            _navigationService?.Deactivate();&#10;        }&#10;&#10;        public void SetCurrentLevel(int levelIndex)&#10;        {&#10;            _navigationService?.SetCurrentIndex(levelIndex);&#10;        }&#10;&#10;        private void PlaySelectionSound()&#10;        {&#10;            if (selectionSound?.clip)&#10;            {&#10;                AudioService.Instance?.PlaySound(selectionSound);&#10;            }&#10;        }&#10;&#10;        private void PlayLockedSound()&#10;        {&#10;            if (lockedSound?.clip)&#10;            {&#10;                AudioService.Instance?.PlaySound(lockedSound);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/AudioFeedbackService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/AudioFeedbackService.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Handles audio feedback for level selection events (Single Responsibility)&#10;    /// &lt;/summary&gt;&#10;    public class AudioFeedbackService : IAudioFeedbackService&#10;    {&#10;        private AudioSource _audioSource;&#10;&#10;        public void Initialize(AudioSource audioSource)&#10;        {&#10;            _audioSource = audioSource;&#10;        }&#10;&#10;&#10;        public void PlaySelectionSound()&#10;        {&#10;            if (_audioSource)&#10;            {&#10;                _audioSource.PlayOneShot(_audioSource.clip);&#10;            }&#10;        }&#10;&#10;        public void PlayLockedSound()&#10;        {&#10;            if (_audioSource)&#10;            {&#10;                _audioSource.PlayOneShot(_audioSource.clip);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Audio.Data;&#10;using Audio.Interfaces;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Handles audio feedback for level selection events using the new SOLID audio system&#10;    /// &lt;/summary&gt;&#10;    public class AudioFeedbackService : IAudioFeedbackService&#10;    {&#10;        [SerializeField] private SoundData selectionSound;&#10;        [SerializeField] private SoundData lockedSound;&#10;        &#10;        private IAudioService _audioService;&#10;        &#10;        [Inject]&#10;        public void Construct(IAudioService audioService)&#10;        {&#10;            _audioService = audioService;&#10;        }&#10;&#10;        public void Initialize(AudioSource audioSource)&#10;        {&#10;            // No longer needed with the new system, but kept for interface compatibility&#10;        }&#10;&#10;        public void SetSounds(SoundData selectionSound, SoundData lockedSound)&#10;        {&#10;            this.selectionSound = selectionSound;&#10;            this.lockedSound = lockedSound;&#10;        }&#10;&#10;        public void PlaySelectionSound()&#10;        {&#10;            if (selectionSound?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(&#10;                    selectionSound.clip,&#10;                    selectionSound.GetRandomizedVolume(),&#10;                    selectionSound.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;&#10;        public void PlayLockedSound()&#10;        {&#10;            if (lockedSound?.clip &amp;&amp; _audioService != null)&#10;            {&#10;                _audioService.PlaySound(&#10;                    lockedSound.clip,&#10;                    lockedSound.GetRandomizedVolume(),&#10;                    lockedSound.GetRandomizedPitch()&#10;                );&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/IAudioFeedbackService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LevelSelection/Services/IAudioFeedbackService.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for audio feedback during level selection&#10;    /// &lt;/summary&gt;&#10;    public interface IAudioFeedbackService&#10;    {&#10;        void Initialize(AudioSource audioSource);&#10;        void PlaySelectionSound();&#10;        void PlayLockedSound();&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="using Audio.Data;&#10;using UnityEngine;&#10;&#10;namespace LevelSelection.Services&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Service responsible for audio feedback during level selection&#10;    ///     Updated to work with the new SOLID audio system&#10;    /// &lt;/summary&gt;&#10;    public interface IAudioFeedbackService&#10;    {&#10;        void Initialize(AudioSource audioSource);&#10;        void SetSounds(SoundData selectionSound, SoundData lockedSound);&#10;        void PlaySelectionSound();&#10;        void PlayLockedSound();&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerSoundController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Player/Components/PlayerSoundController.cs" />
              <option name="originalContent" value="using Audio.Data;&#10;using Audio.Interfaces;&#10;using Audio.Services;&#10;using Collectables.Score;&#10;using Health.Interfaces;&#10;using ModularCharacterController.Core;&#10;using ModularCharacterController.Core.Components;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Unified player audio controller that handles both sound events and audio playback&#10;    ///     Combines event subscription logic with SOLID audio system integration&#10;    /// &lt;/summary&gt;&#10;    public class PlayerSoundController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Player Sound Events&quot;)] [SerializeField]&#10;        private SoundData jumpSound;&#10;&#10;        [SerializeField] private SoundData collectSound;&#10;        [SerializeField] private SoundData deathSound;&#10;        [SerializeField] private SoundData attackSound;&#10;        private MccGroundCheck _groundCheck;&#10;        private IHealthEvents _health;&#10;        private InputHandler _inputHandler;&#10;&#10;        private void Awake()&#10;        {&#10;            _health = GetComponent&lt;IHealthEvents&gt;();&#10;            _inputHandler = GetComponent&lt;InputHandler&gt;();&#10;            _groundCheck = GetComponent&lt;MccGroundCheck&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            InputContext input = _inputHandler.CurrentInput;&#10;            if (input.AttackPressed)&#10;            {&#10;                AudioService.Instance?.PlaySound(attackSound);&#10;                return;&#10;            }&#10;            &#10;            if (input.JumpPressed &amp;&amp; !_groundCheck.IsGrounded)&#10;            {&#10;                AudioService.Instance?.PlaySound(jumpSound);&#10;            }&#10;&#10;        }&#10;&#10;&#10;        private void OnEnable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected += OnScoreCollected;&#10;&#10;            if (_health != null)&#10;            {&#10;                _health.OnDeath += OnDeath;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected -= OnScoreCollected;&#10;&#10;            if (_health != null)&#10;            {&#10;                _health.OnDeath -= OnDeath;&#10;            }&#10;        }&#10;&#10;&#10;        #region Event Handlers&#10;&#10;        private void OnScoreCollected(int score, Vector3 position)&#10;        {&#10;            AudioService.Instance?.PlaySoundAtPosition(collectSound, position);&#10;        }&#10;&#10;        private void OnDeath()&#10;        {&#10;            AudioService.Instance?.PlaySound(deathSound);&#10;        }&#10;&#10;        #endregion&#10;&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Audio.Data;&#10;using Audio.Interfaces;&#10;using Audio.Services;&#10;using Collectables.Score;&#10;using Health.Interfaces;&#10;using ModularCharacterController.Core;&#10;using ModularCharacterController.Core.Components;&#10;using UnityEngine;&#10;using VContainer;&#10;&#10;namespace Player.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     Unified player audio controller that handles both sound events and audio playback&#10;    ///     Combines event subscription logic with SOLID audio system integration&#10;    /// &lt;/summary&gt;&#10;    public class PlayerSoundController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Player Sound Events&quot;)] [SerializeField]&#10;        private SoundData jumpSound;&#10;&#10;        [SerializeField] private SoundData collectSound;&#10;        [SerializeField] private SoundData deathSound;&#10;        [SerializeField] private SoundData attackSound;&#10;        private MccGroundCheck _groundCheck;&#10;        private IHealthEvents _health;&#10;        private InputHandler _inputHandler;&#10;        private bool _jumpSoundPlayed;&#10;&#10;        private void Awake()&#10;        {&#10;            _health = GetComponent&lt;IHealthEvents&gt;();&#10;            _inputHandler = GetComponent&lt;InputHandler&gt;();&#10;            _groundCheck = GetComponent&lt;MccGroundCheck&gt;();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            InputContext input = _inputHandler.CurrentInput;&#10;&#10;            if (input.JumpPressed &amp;&amp; _groundCheck.IsGrounded &amp;&amp; !_jumpSoundPlayed)&#10;            {&#10;                AudioService.Instance?.PlaySound(jumpSound);&#10;                _jumpSoundPlayed = true;&#10;            }&#10;&#10;            if (!input.JumpPressed)&#10;            {&#10;                _jumpSoundPlayed = false;&#10;            }&#10;&#10;            if (input.AttackPressed)&#10;            {&#10;                AudioService.Instance?.PlaySound(attackSound);&#10;            }&#10;        }&#10;&#10;&#10;        private void OnEnable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected += OnScoreCollected;&#10;&#10;            if (_health != null)&#10;            {&#10;                _health.OnDeath += OnDeath;&#10;            }&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            ScoreCollectable.OnScoreCollected -= OnScoreCollected;&#10;&#10;            if (_health != null)&#10;            {&#10;                _health.OnDeath -= OnDeath;&#10;            }&#10;        }&#10;&#10;&#10;        #region Event Handlers&#10;&#10;        private void OnScoreCollected(int score, Vector3 position)&#10;        {&#10;            AudioService.Instance?.PlaySoundAtPosition(collectSound, position);&#10;        }&#10;&#10;        private void OnDeath()&#10;        {&#10;            AudioService.Instance?.PlaySound(deathSound);&#10;        }&#10;&#10;        #endregion&#10;&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameLifetimeScope.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/StartGame/StartGameLifetimeScope.cs" />
              <option name="updatedContent" value="using Core;&#10;using Core.Data;&#10;using Core.Events;&#10;using Core.Services;&#10;using LevelSelection.Services;&#10;using UnityEngine;&#10;using VContainer;&#10;using VContainer.Unity;&#10;&#10;namespace StartGame&#10;{&#10;    /// &lt;summary&gt;&#10;    ///     VContainer lifetime scope for Start Game screen&#10;    /// &lt;/summary&gt;&#10;    public class StartGameLifetimeScope : LifetimeScope&#10;    {&#10;        protected override void Configure(IContainerBuilder builder)&#10;        {&#10;            Debug.Log(&quot;[StartGameLifetimeScope] Configuring start game DI container...&quot;);&#10;&#10;            // Register core services needed for start screen&#10;            builder.Register&lt;IEventBus, EventBus&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataRepository, JsonGameDataRepository&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IGameDataService, GameDataService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;IAutoSaveService, AutoSaveService&gt;(Lifetime.Singleton);&#10;            builder.Register&lt;ISceneLoadService, SceneLoadService&gt;(Lifetime.Singleton);&#10;&#10;            // Register core game management components&#10;            builder.RegisterComponentInHierarchy&lt;GameFlowManager&gt;();&#10;            builder.RegisterComponentInHierarchy&lt;GameDataCoordinator&gt;();&#10;&#10;            // Register start game specific components&#10;            builder.RegisterComponentInHierarchy&lt;StartGameListener&gt;();&#10;&#10;            Debug.Log(&quot;[StartGameLifetimeScope] Start game DI container configured successfully.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>